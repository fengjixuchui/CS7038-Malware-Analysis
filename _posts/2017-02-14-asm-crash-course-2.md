---
title: Assembly Language Crash Course (Pt. 2), A Deeper Dive
tags:
 - malware
 - lecture
 - C
 - x86
 - x86-64
 - asm
 - CFG
 - Decompilation
---
## {{page.title}}

This lecture focuses more on the core internals of x86-64 assembly (which is a 64-bit superset
of the 32-bit x86 instruction set).

The following topics are discussed:
* Assembly language representations (AT&T/UNIX versus Intel/Microsoft syntax):
  [http://www.imada.sdu.dk/Courses/DM18/Litteratur/IntelnATT.htm](http://www.imada.sdu.dk/Courses/DM18/Litteratur/IntelnATT.htm)
* Variable length instruction format
* Binary instruction layout (generalized, with some case-specific examples)
* x86-64 register set
* Memory addressing modes (7 variants!)

Additionally, this lecture includes a demostration using the in-class compiled program from
[Lecture W05.2](/2017/02/09/asm-crash-course-1.html). In this example, we examine a number of
specific instructions that were generated from our C program's compilation. We discuss how the
bytes generated in the file correspond to components of an instruction, and then also use a
hex viewing utility to examine those instructions in their native context.

## Helpful reference tables

* [x86-64/32 Register set](#x86-6432-registers)
* [x86 Addressing Modes](#x86-addressing-modes)

Slides: [lecture-w06.pdf (PDF)](/lecture-slides/lecture-w06.pdf)

Video: [CS7038: Wk06 - Assembly Language Crash Course](https://youtu.be/JiC0TnYtXXU?list=PLFvh_k-n27Cmh2VYc3e24s5_toZbgSPVE)

<iframe width="560" height="315"
 src="https://www.youtube.com/embed/JiC0TnYtXXU?list=PLFvh_k-n27Cmh2VYc3e24s5_toZbgSPVE"
 frameborder="0" allowfullscreen></iframe>

### x86-64/32 Registers

|----------------------+----------+---------------------------------------------------------------------+----------------------+----------------------+----------------|
| 64-bit Register Name | Rnn Name | Name (Description)                                                  | 32-bit register name | 16-bit Register name | 8-bit high/low |
|----------------------|----------|---------------------------------------------------------------------|----------------------|----------------------|----------------|
| RAX                  |   R0     | Accumulator (frequently result storage)                             | EAX                  | AX                   | AH/AL          |
| RCX                  |   R1     | Counter (frequently used as <tt>i</tt> in iterations/loops)         | ECX                  | CX                   | CH/CL          |
| RDX                  |   R2     | Data (frequently used as additional arg in operations)              | EDX                  | DX                   | DH/DL          |
| RBX                  |   R3     | Base (frequently used as base address or counter)                   | EBX                  | BX                   | BH/BL          |
| RSP                  |   R4     | Stack Pointer (used internally to keep track of top of CPU stack)   | ESP                  | SP                   |                |
| RBP                  |   R5     | Base Pointer (frequently used to keep track of bottom of CPU stack) | EBP                  | BP                   |                |
| RSI                  |   R6     | Source Index (keeps track of indexes in source arrays)              | ESI                  | SI                   |                |
| RDI                  |   R7     | Destination Index (keeps track of indexes in destination arrays)    | EDI                  | DI                   |                |
| R8-R15               |  R8-R15  | Additional general-purpose registers only avail. in 64-bit          |                      |                      |                |
|----------------------+----------+---------------------------------------------------------------------+----------------------+----------------------+----------------|

For many of the registers, you may access fragments of them using their synonyms. Editing AH, for example, will modify the bits 15..8 in register RAX (EAX, AX, etc...).
The fragments address the following bit ranges in their respective registers:

* **RxX/RxI/RxP**: Bits 63..0 (full 64-bit register)
* **ExX/ExI/ExP**: Bits 31..0 (lower half)
* **xX/xI/xP**: Bits 15..0 (lower quarter)
* **xH**: Bits 15..8 (byte index 1)
* **xL**: Bits 7..0 (byte index 0, lower-most byte)

There are also a number of limited-use, system, and context-specific registers that are part of the architecture. I will not go into these
at this time.

### x86 Addressing Modes

The x86 instruction set also has a number of addressing modes. These represent instruction variants that provide various mechanisms
to work with constant (hard-coded data), data present in registers, and data present in memory.

|----------------------+-------------------------------+-------------------------------------------+---------------------------------------------------------|
| Addr. Mode Name      | AT&T/UNIX example             | Intel/Microsoft Equivalent                | Description of example                                  |
|----------------------|-------------------------------|-------------------------------------------|---------------------------------------------------------|
| Immediate            | <code>movq&nbsp;$0x0a,&nbsp;%rbx</code> | <code>MOV&nbsp;RBX,&nbsp;0Ah</code>                 | Copy constant <tt>0x0a</tt> into register RBX           |
| Register             | <code>movq&nbsp;%rax,&nbsp;%rbx</code>  | <code>MOV&nbsp;RBX,&nbsp;RAX</code>                 | Copy data from RAX into RBX                             |
| Direct Memory        | <code>movq&nbsp;0x1000,&nbsp;%rbx</code>| <code>MOV&nbsp;RBX,&nbsp;QWORD&nbsp;PTR&nbsp;[1000h]</code>   | Copy 64-bit data from memory loc. 0x1000 into RBX       |
| Register Indirect    | <code>movq&nbsp;(%rbx),&nbsp;%rbp</code>| <code>MOV&nbsp;RBP,&nbsp;[RBX]</code>               | Copy 64-bit data from memory loc. stored in RBX into RBP|
| Register Indirect w/ displacement | <code>movq&nbsp;0x08(%rbx),&nbsp;%rbp</code>| <code>MOV&nbsp;RBP,&nbsp;08h[RBX]</code>| Copy 64-bit data from memory location RBX+0x08 into RBP|
| Scaled Register Indirect w/ displacement | <code>movq&nbsp;0x08(,%rbx,4),&nbsp;%rbp</code>| <code>MOV&nbsp;RBP,&nbsp;08h[RBX*04h]</code>| Copy 64-bit data from memory location [(RBX*0x04)+0x08] into RBP|
| Scaled Register Indirect w/ displacement + base reg. | <code>movq&nbsp;0x08(%rsi,%rbx,4),&nbsp;%rbp</code>| <code>MOV&nbsp;RBP,&nbsp;08h[RSI][RBX*04h]</code>| Copy 64-bit data from memory location [(RBX*0x04)+RSI+0x08] into RBP|
|----------------------+-------------------------------+-------------------------------------------+---------------------------------------------------------|

[home](/)
