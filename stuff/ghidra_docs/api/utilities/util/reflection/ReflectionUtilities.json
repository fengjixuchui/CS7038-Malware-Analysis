{
  "name": "ReflectionUtilities",
  "comment": "",
  "javadoc": "",
  "static": false,
  "implements": [],
  "extends": "java.lang.Object",
  "fields": [
    {
      "name": "JAVA_AWT_PATTERN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"java.awt\""
    },
    {
      "name": "JAVA_REFLECT_PATTERN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"java.lang.reflect\""
    },
    {
      "name": "JDK_INTERNAL_REFLECT_PATTERN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"jdk.internal.reflect\""
    },
    {
      "name": "SWING_JAVA_PATTERN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"java.swing\""
    },
    {
      "name": "SWING_JAVAX_PATTERN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"javax.swing\""
    },
    {
      "name": "SUN_AWT_PATTERN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"sun.awt\""
    },
    {
      "name": "SUN_REFLECT_PATTERN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"sun.reflect\""
    },
    {
      "name": "SECURITY_PATTERN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"java.security\""
    },
    {
      "name": "JUNIT_PATTERN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\".junit\""
    },
    {
      "name": "MOCKIT_PATTERN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"mockit\""
    }
  ],
  "methods": [
    {
      "name": "\u003cinit\u003e",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "locateStaticFieldObjectOnClass",
      "comment": "Locates the field of the name fieldName on the given \n class.  If the given class does not contain the field, then this \n method will recursively call up containingClass\u0027s \n implementation tree looking for a parent implementation of the \n requested field.",
      "javadoc": "Locates the field of the name \u003ccode\u003efieldName\u003c/code\u003e on the given \n class.  If the given class does not contain the field, then this \n method will recursively call up \u003ccode\u003econtainingClass\u003c/code\u003e\u0027s \n implementation tree looking for a parent implementation of the \n requested field.\n@param fieldName The name of the field to locate.\n@param containingClass The class that contains the desired field.\n@return The Field object that matches the given name, or null if not\n         suitable field could be found.",
      "static": true,
      "params": [
        {
          "name": "fieldName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "The name of the field to locate."
        },
        {
          "name": "containingClass",
          "type_long": "java.lang.Class\u003c?\u003e",
          "type_short": "Class",
          "comment": "The class that contains the desired field."
        }
      ],
      "return": {
        "type_long": "java.lang.reflect.Field",
        "type_short": "Field",
        "comment": "The Field object that matches the given name, or null if not\n         suitable field could be found."
      },
      "throws": []
    },
    {
      "name": "locateFieldObjectOnClass",
      "comment": "Locates the field of the name fieldName on the given \n class.  If the given class does not contain the field, then this \n method will recursively call up containingClass\u0027s \n implementation tree looking for a parent implementation of the \n requested field.",
      "javadoc": "Locates the field of the name \u003ccode\u003efieldName\u003c/code\u003e on the given \n class.  If the given class does not contain the field, then this \n method will recursively call up \u003ccode\u003econtainingClass\u003c/code\u003e\u0027s \n implementation tree looking for a parent implementation of the \n requested field.\n@param fieldName The name of the field to locate.\n@param containingClass The class that contains the desired field.\n@return The Field object that matches the given name, or null if not\n         suitable field could be found.",
      "static": true,
      "params": [
        {
          "name": "fieldName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "The name of the field to locate."
        },
        {
          "name": "containingClass",
          "type_long": "java.lang.Class\u003c?\u003e",
          "type_short": "Class",
          "comment": "The class that contains the desired field."
        }
      ],
      "return": {
        "type_long": "java.lang.reflect.Field",
        "type_short": "Field",
        "comment": "The Field object that matches the given name, or null if not\n         suitable field could be found."
      },
      "throws": []
    },
    {
      "name": "locateMethodObjectOnClass",
      "comment": "Locates the method of the name methodName on the given \n class.  If the given class does not contain the method, then this \n method will recursively call up containingClass\u0027s \n implementation tree looking for a parent implementation of the \n requested method.",
      "javadoc": "Locates the method of the name \u003ccode\u003emethodName\u003c/code\u003e on the given \n class.  If the given class does not contain the method, then this \n method will recursively call up \u003ccode\u003econtainingClass\u003c/code\u003e\u0027s \n implementation tree looking for a parent implementation of the \n requested method.\n@param methodName The name of the method to locate.\n@param containingClass The class that contains the desired method.\n@param parameterTypes The parameters of the desired method (may be null).\n@return The Method object that matches the given name, or null if not\n         suitable method could be found.",
      "static": true,
      "params": [
        {
          "name": "methodName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "The name of the method to locate."
        },
        {
          "name": "containingClass",
          "type_long": "java.lang.Class\u003c?\u003e",
          "type_short": "Class",
          "comment": "The class that contains the desired method."
        },
        {
          "name": "parameterTypes",
          "type_long": "java.lang.Class\u003c?\u003e[]",
          "type_short": "java.lang.Class\u003c?\u003e[]",
          "comment": "The parameters of the desired method (may be null)."
        }
      ],
      "return": {
        "type_long": "java.lang.reflect.Method",
        "type_short": "Method",
        "comment": "The Method object that matches the given name, or null if not\n         suitable method could be found."
      },
      "throws": []
    },
    {
      "name": "locateConstructorOnClass",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "containingClass",
          "type_long": "java.lang.Class\u003c?\u003e",
          "type_short": "Class",
          "comment": ""
        },
        {
          "name": "parameterTypes",
          "type_long": "java.lang.Class\u003c?\u003e[]",
          "type_short": "java.lang.Class\u003c?\u003e[]",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.reflect.Constructor\u003c?\u003e",
        "type_short": "Constructor",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "locateFieldByTypeOnClass",
      "comment": "Get the first field specification contained within containingClass which has the type classType.\n This method is only really useful if it is known that only a single field of \n classType exists within the containingClass hierarchy.",
      "javadoc": "Get the first field specification contained within containingClass which has the type classType.\n This method is only really useful if it is known that only a single field of \n classType exists within the containingClass hierarchy.\n@param classType the class\n@param containingClass the class that contains a field of the given type\n@return field which corresponds to type classType or null",
      "static": true,
      "params": [
        {
          "name": "classType",
          "type_long": "java.lang.Class\u003c?\u003e",
          "type_short": "Class",
          "comment": "the class"
        },
        {
          "name": "containingClass",
          "type_long": "java.lang.Class\u003c?\u003e",
          "type_short": "Class",
          "comment": "the class that contains a field of the given type"
        }
      ],
      "return": {
        "type_long": "java.lang.reflect.Field",
        "type_short": "Field",
        "comment": "field which corresponds to type classType or null"
      },
      "throws": []
    },
    {
      "name": "getClassNameOlderThan",
      "comment": "Returns the class name of the entry in the stack that comes before all references to the\n given classes.  This is useful for figuring out at runtime who is calling a particular\n method. \n \n This method can take multiple classes, but you really only need to pass the oldest \n class of disinterest.",
      "javadoc": "Returns the class name of the entry in the stack that comes before all references to the\n given classes.  This is useful for figuring out at runtime who is calling a particular\n method. \n \u003cp\u003e\n This method can take multiple classes, but you really only need to pass the oldest \n class of disinterest.\n@param classes the classes to ignore\n@return the desired class name",
      "static": true,
      "params": [
        {
          "name": "classes",
          "type_long": "java.lang.Class\u003c?\u003e[]",
          "type_short": "java.lang.Class\u003c?\u003e[]",
          "comment": "the classes to ignore"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the desired class name"
      },
      "throws": []
    },
    {
      "name": "createThrowableWithStackOlderThan",
      "comment": "Creates a throwable whose stack trace is based upon the current call stack, with any \n information coming before, and including, the given classes removed.\n \n This method can take multiple classes, but you really only need to pass the oldest \n class of disinterest.",
      "javadoc": "Creates a throwable whose stack trace is based upon the current call stack, with any \n information coming before, and including, the given classes removed.\n \u003cp\u003e\n This method can take multiple classes, but you really only need to pass the oldest \n class of disinterest.\n@param classes the classes to ignore\n@return the new throwable",
      "static": true,
      "params": [
        {
          "name": "classes",
          "type_long": "java.lang.Class\u003c?\u003e[]",
          "type_short": "java.lang.Class\u003c?\u003e[]",
          "comment": "the classes to ignore"
        }
      ],
      "return": {
        "type_long": "java.lang.Throwable",
        "type_short": "Throwable",
        "comment": "the new throwable"
      },
      "throws": []
    },
    {
      "name": "movePastStackTracePattern",
      "comment": "Finds the first occurrence of the given pattern and then stops filtering when it finds \n something that is not that pattern",
      "javadoc": "Finds the first occurrence of the given pattern and then stops filtering when it finds \n something that is not that pattern\n@param trace the trace to update\n@param pattern the non-regex patterns used to perform a \n \t\t\t\t  {@link String#contains(CharSequence)} on each {@link StackTraceElement} line\n@return the updated trace",
      "static": true,
      "params": [
        {
          "name": "trace",
          "type_long": "java.lang.StackTraceElement[]",
          "type_short": "java.lang.StackTraceElement[]",
          "comment": "the trace to update"
        },
        {
          "name": "pattern",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the non-regex patterns used to perform a \n \t\t\t\t  String#contains(CharSequence) on each StackTraceElement line"
        }
      ],
      "return": {
        "type_long": "java.lang.StackTraceElement[]",
        "type_short": "java.lang.StackTraceElement[]",
        "comment": "the updated trace"
      },
      "throws": []
    },
    {
      "name": "filterStackTrace",
      "comment": "Uses the given patterns to remove elements from the given stack trace.     \n The current implementation will simply perform a toString() on each element and\n then check to see if that string contains any of the patterns.",
      "javadoc": "Uses the given \u003ccode\u003epatterns\u003c/code\u003e to remove elements from the given stack trace.     \n The current implementation will simply perform a \u003ccode\u003etoString()\u003c/code\u003e on each element and\n then check to see if that string contains any of the \u003ccode\u003epatterns\u003c/code\u003e.\n@param trace the trace to filter\n@param patterns the non-regex patterns used to perform a \n \t\t\t\t   {@link String#contains(CharSequence)} on each {@link StackTraceElement}\n \t\t\t\t   line.\n@return the filtered trace",
      "static": true,
      "params": [
        {
          "name": "trace",
          "type_long": "java.lang.StackTraceElement[]",
          "type_short": "java.lang.StackTraceElement[]",
          "comment": "the trace to filter"
        },
        {
          "name": "patterns",
          "type_long": "java.lang.String[]",
          "type_short": "java.lang.String[]",
          "comment": "the non-regex patterns used to perform a \n \t\t\t\t   String#contains(CharSequence) on each StackTraceElement\n \t\t\t\t   line."
        }
      ],
      "return": {
        "type_long": "java.lang.StackTraceElement[]",
        "type_short": "java.lang.StackTraceElement[]",
        "comment": "the filtered trace"
      },
      "throws": []
    },
    {
      "name": "createFilteredThrowable",
      "comment": "A convenience method to create a throwable, filtering any lines that contain the given\n non-regex patterns.  This can be useful for emitting diagnostic stack traces.",
      "javadoc": "A convenience method to create a throwable, filtering any lines that contain the given\n non-regex patterns.  This can be useful for emitting diagnostic stack traces.\n@param patterns the non-regex patterns used to perform a \n \t\t\t\t   {@link String#contains(CharSequence)} on each {@link StackTraceElement}\n \t\t\t\t   line.\n@return the new throwable",
      "static": true,
      "params": [
        {
          "name": "patterns",
          "type_long": "java.lang.String[]",
          "type_short": "java.lang.String[]",
          "comment": "the non-regex patterns used to perform a \n \t\t\t\t   String#contains(CharSequence) on each StackTraceElement\n \t\t\t\t   line."
        }
      ],
      "return": {
        "type_long": "java.lang.Throwable",
        "type_short": "Throwable",
        "comment": "the new throwable"
      },
      "throws": []
    },
    {
      "name": "createJavaFilteredThrowable",
      "comment": "A convenience method to create a throwable, filtering boiler-plate Java-related \n lines (e.g., AWT, Swing, Security, etc).  \n This can be useful for emitting diagnostic stack traces with reduced noise.",
      "javadoc": "A convenience method to create a throwable, filtering boiler-plate Java-related \n lines (e.g., AWT, Swing, Security, etc).  \n This can be useful for emitting diagnostic stack traces with reduced noise.\n@return the new throwable",
      "static": true,
      "params": [],
      "return": {
        "type_long": "java.lang.Throwable",
        "type_short": "Throwable",
        "comment": "the new throwable"
      },
      "throws": []
    },
    {
      "name": "createJavaFilteredThrowableString",
      "comment": "A convenience method to create a throwable, filtering boiler-plate Java-related \n lines (e.g., AWT, Swing, Security, etc).  \n This can be useful for emitting diagnostic stack traces with reduced noise.  \n \n This method differs from #createJavaFilteredThrowable() in that this method\n returns a String, which is useful when printing log messages without having to directly\n print the stack trace.",
      "javadoc": "A convenience method to create a throwable, filtering boiler-plate Java-related \n lines (e.g., AWT, Swing, Security, etc).  \n This can be useful for emitting diagnostic stack traces with reduced noise.  \n \n \u003cp\u003eThis method differs from {@link #createJavaFilteredThrowable()} in that this method\n returns a String, which is useful when printing log messages without having to directly\n print the stack trace.\n@return the new throwable",
      "static": true,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the new throwable"
      },
      "throws": []
    },
    {
      "name": "filterJavaThrowable",
      "comment": "A convenience method to take a throwable, filter boiler-plate Java-related \n lines (e.g., AWT, Swing, Security, etc).  \n This can be useful for emitting diagnostic stack traces with reduced noise.",
      "javadoc": "A convenience method to take a throwable, filter boiler-plate Java-related \n lines (e.g., AWT, Swing, Security, etc).  \n This can be useful for emitting diagnostic stack traces with reduced noise.\n@param t the throwable to filter\n@return the throwable",
      "static": true,
      "params": [
        {
          "name": "t",
          "type_long": "java.lang.Throwable",
          "type_short": "Throwable",
          "comment": "the throwable to filter"
        }
      ],
      "return": {
        "type_long": "java.lang.Throwable",
        "type_short": "Throwable",
        "comment": "the throwable"
      },
      "throws": []
    },
    {
      "name": "containsAny",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "s",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "patterns",
          "type_long": "java.lang.String[]",
          "type_short": "java.lang.String[]",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "createStackTraceForAllThreads",
      "comment": "Returns a string which is a printout of a stack trace for each thread running in the\n current JVM",
      "javadoc": "Returns a string which is a printout of a stack trace for each thread running in the\n current JVM\n@return the stack trace string",
      "static": true,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the stack trace string"
      },
      "throws": []
    },
    {
      "name": "getSharedHierarchy",
      "comment": "Returns an ordered set of interfaces and classes that are shared amongst the items in \n the list.\n \n The order of the items is as they are first encountered, favoring interfaces before \n classes.  Further, interface hierarchies are examined before concrete parent extensions.\n \n If the given items have no parents in common, then the result will be a list with\n only Object.class.",
      "javadoc": "Returns an ordered set of interfaces and classes that are shared amongst the items in \n the list.\n \u003cp\u003e\n The order of the items is as they are first encountered, favoring interfaces before \n classes.  Further, interface hierarchies are examined before concrete parent extensions.\n \u003cp\u003e\n If the given items have no parents in common, then the result will be a list with\n only \u003ccode\u003eObject.class\u003c/code\u003e.\n@param list the items to examine\n@return the set of items",
      "static": true,
      "params": [
        {
          "name": "list",
          "type_long": "java.util.List\u003c?\u003e",
          "type_short": "List",
          "comment": "the items to examine"
        }
      ],
      "return": {
        "type_long": "java.util.LinkedHashSet\u003cjava.lang.Class\u003c?\u003e\u003e",
        "type_short": "LinkedHashSet",
        "comment": "the set of items"
      },
      "throws": []
    },
    {
      "name": "getSharedParents",
      "comment": "Returns an ordered set of parent interfaces and classes that are shared \n amongst the items in the list.\n \n The order of the items is as they are first encountered, favoring interfaces before \n classes.  Further, interface hierarchies are examined before concrete parent extensions.\n \n If the given items have no parents in common, then the result will be a list with\n only Object.class.",
      "javadoc": "Returns an ordered set of parent interfaces and classes that are shared \n amongst the items in the list.\n \u003cp\u003e\n The order of the items is as they are first encountered, favoring interfaces before \n classes.  Further, interface hierarchies are examined before concrete parent extensions.\n \u003cp\u003e\n If the given items have no parents in common, then the result will be a list with\n only \u003ccode\u003eObject.class\u003c/code\u003e.\n@param list the items to examine\n@return the set of items",
      "static": true,
      "params": [
        {
          "name": "list",
          "type_long": "java.util.List\u003c?\u003e",
          "type_short": "List",
          "comment": "the items to examine"
        }
      ],
      "return": {
        "type_long": "java.util.LinkedHashSet\u003cjava.lang.Class\u003c?\u003e\u003e",
        "type_short": "LinkedHashSet",
        "comment": "the set of items"
      },
      "throws": []
    },
    {
      "name": "stackTraceToString",
      "comment": "Turns the given Throwable into a String version of its \n Throwable#printStackTrace() method.",
      "javadoc": "Turns the given {@link Throwable} into a String version of its \n {@link Throwable#printStackTrace()} method.\n@param t the throwable\n@return the string",
      "static": true,
      "params": [
        {
          "name": "t",
          "type_long": "java.lang.Throwable",
          "type_short": "Throwable",
          "comment": "the throwable"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the string"
      },
      "throws": []
    },
    {
      "name": "stackTraceToString",
      "comment": "Turns the given Throwable into a String version of its \n Throwable#printStackTrace() method.",
      "javadoc": "Turns the given {@link Throwable} into a String version of its \n {@link Throwable#printStackTrace()} method.\n@param message the preferred message to use.  If null, the throwable message will be used\n@param t the throwable\n@return the string",
      "static": true,
      "params": [
        {
          "name": "message",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the preferred message to use.  If null, the throwable message will be used"
        },
        {
          "name": "t",
          "type_long": "java.lang.Throwable",
          "type_short": "Throwable",
          "comment": "the throwable"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the string"
      },
      "throws": []
    },
    {
      "name": "getAllParents",
      "comment": "Returns an order set of all interfaces implemented and classes extended for the entire\n type structure of the given class. \n \n If Object.class is passed to this method, then it will be returned in the \n result of this method.",
      "javadoc": "Returns an order set of all interfaces implemented and classes extended for the entire\n type structure of the given class. \n \u003cp\u003e\n If \u003ccode\u003eObject.class\u003c/code\u003e is passed to this method, then it will be returned in the \n result of this method.\n@param c the class to introspect\n@return the set of parents",
      "static": true,
      "params": [
        {
          "name": "c",
          "type_long": "java.lang.Class\u003c?\u003e",
          "type_short": "Class",
          "comment": "the class to introspect"
        }
      ],
      "return": {
        "type_long": "java.util.LinkedHashSet\u003cjava.lang.Class\u003c?\u003e\u003e",
        "type_short": "LinkedHashSet",
        "comment": "the set of parents"
      },
      "throws": []
    },
    {
      "name": "doGetAllParents",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "c",
          "type_long": "java.lang.Class\u003c?\u003e",
          "type_short": "Class",
          "comment": ""
        },
        {
          "name": "accumulator",
          "type_long": "java.util.LinkedHashSet\u003cjava.lang.Class\u003c?\u003e\u003e",
          "type_short": "LinkedHashSet",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getTypeArguments",
      "comment": "Returns the type arguments for the given base class and extension.\n \n Caveat: this lookup will only work if the given child class is a concrete class that\n has its type arguments specified.  For example, these cases will work:\n \n \t\t// anonymous class definition\n \t\tListString myList \u003d new ArrayListString() {\n\t\t\t...\n\t\t};\n\n\t\t// class definition\n\t\tpublic class MyList implements ListString {\n  \n \n Whereas this case will not work:\n \n \t\t// local variable with the type specified\n \t\tListString myList \u003d new ArrayListString();\n \n \n Note: a null entry in the result list will exist for any type that was unrecoverable",
      "javadoc": "Returns the type arguments for the given base class and extension.\n \n \u003cp\u003eCaveat: this lookup will only work if the given child class is a concrete class that\n has its type arguments specified.  For example, these cases will work:\n \u003cpre\u003e\n \t\t// anonymous class definition\n \t\tList\u0026lt;String\u0026gt; myList \u003d new ArrayList\u0026lt;String\u0026gt;() {\n\t\t\t...\n\t\t};\n\n\t\t// class definition\n\t\tpublic class MyList implements List\u0026lt;String\u0026gt; {\n \u003c/pre\u003e \n \n Whereas this case will not work:\n \u003cpre\u003e\n \t\t// local variable with the type specified\n \t\tList\u0026lt;String\u0026gt; myList \u003d new ArrayList\u0026lt;String\u0026gt;();\n \u003c/pre\u003e\n \n \u003cp\u003eNote: a null entry in the result list will exist for any type that was unrecoverable\n@param \u003cT\u003e the type of the base and child class\n@param baseClass the base class\n@param childClass the child class\n@return the type arguments",
      "static": true,
      "params": [
        {
          "name": "baseClass",
          "type_long": "java.lang.Class\u003cT\u003e",
          "type_short": "Class",
          "comment": "the base class"
        },
        {
          "name": "childClass",
          "type_long": "java.lang.Class\u003c? extends T\u003e",
          "type_short": "Class",
          "comment": "the child class"
        }
      ],
      "return": {
        "type_long": "java.util.List\u003cjava.lang.Class\u003c?\u003e\u003e",
        "type_short": "List",
        "comment": "the type arguments"
      },
      "throws": []
    },
    {
      "name": "walkClassHierarchyAndResolveTypes",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "baseClass",
          "type_long": "java.lang.Class\u003cT\u003e",
          "type_short": "Class",
          "comment": ""
        },
        {
          "name": "resolvedTypes",
          "type_long": "java.util.Map\u003cjava.lang.reflect.Type,java.lang.reflect.Type\u003e",
          "type_short": "Map",
          "comment": ""
        },
        {
          "name": "type",
          "type_long": "java.lang.reflect.Type",
          "type_short": "Type",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.reflect.Type",
        "type_short": "Type",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "equals",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "type",
          "type_long": "java.lang.reflect.Type",
          "type_short": "Type",
          "comment": ""
        },
        {
          "name": "c",
          "type_long": "java.lang.Class\u003c?\u003e",
          "type_short": "Class",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getClass",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "type",
          "type_long": "java.lang.reflect.Type",
          "type_short": "Type",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.Class\u003c?\u003e",
        "type_short": "Class",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "resolveBaseClassTypeArguments",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "resolvedTypes",
          "type_long": "java.util.Map\u003cjava.lang.reflect.Type,java.lang.reflect.Type\u003e",
          "type_short": "Map",
          "comment": ""
        },
        {
          "name": "genericTypeArguments",
          "type_long": "java.lang.reflect.Type[]",
          "type_short": "java.lang.reflect.Type[]",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.util.List\u003cjava.lang.Class\u003c?\u003e\u003e",
        "type_short": "List",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getDeclaredTypeArguments",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "type",
          "type_long": "java.lang.reflect.Type",
          "type_short": "Type",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.reflect.Type[]",
        "type_short": "java.lang.reflect.Type[]",
        "comment": ""
      },
      "throws": []
    }
  ]
}
