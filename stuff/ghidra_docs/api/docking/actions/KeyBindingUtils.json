{
  "name": "KeyBindingUtils",
  "comment": "A class to provide utilities for system key bindings, such as importing and\n exporting key binding configurations.",
  "javadoc": "A class to provide utilities for system key bindings, such as importing and\n exporting key binding configurations.\n@since Tracker Id 329",
  "static": false,
  "implements": [],
  "extends": "java.lang.Object",
  "fields": [
    {
      "name": "LAST_KEY_BINDING_EXPORT_DIRECTORY",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"LastKeyBindingExportDirectory\""
    },
    {
      "name": "RELEASED",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"released\""
    },
    {
      "name": "TYPED",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"typed\""
    },
    {
      "name": "PRESSED",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"pressed\""
    },
    {
      "name": "SHIFT",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"Shift\""
    },
    {
      "name": "CTRL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"Ctrl\""
    },
    {
      "name": "CONTROL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"Control\""
    },
    {
      "name": "ALT",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"Alt\""
    },
    {
      "name": "META",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"Meta\""
    },
    {
      "name": "MODIFIER_SEPARATOR",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"-\""
    },
    {
      "name": "log",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "org.apache.logging.log4j.Logger",
      "type_short": "Logger",
      "constant_value": null
    },
    {
      "name": "PREFERENCES_FILE_EXTENSION",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\".kbxml\""
    },
    {
      "name": "FILE_FILTER",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "ghidra.util.filechooser.GhidraFileFilter",
      "type_short": "GhidraFileFilter",
      "constant_value": null
    }
  ],
  "methods": [
    {
      "name": "\u003cinit\u003e",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "importKeyBindings",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [],
      "return": {
        "type_long": "ghidra.framework.options.ToolOptions",
        "type_short": "ToolOptions",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "createOptionsforKeybindings",
      "comment": "Imports key bindings from a location selected by the user.\n \n If there is a problem reading the data then the user will be shown an\n error dialog.",
      "javadoc": "Imports key bindings from a location selected by the user.\n \u003cp\u003e\n If there is a problem reading the data then the user will be shown an\n error dialog.\n@param inputStream the input stream from which to read options\n@return An options object that is composed of key binding names and their\n         associated keystrokes.",
      "static": true,
      "params": [
        {
          "name": "inputStream",
          "type_long": "java.io.InputStream",
          "type_short": "InputStream",
          "comment": "the input stream from which to read options"
        }
      ],
      "return": {
        "type_long": "ghidra.framework.options.ToolOptions",
        "type_short": "ToolOptions",
        "comment": "An options object that is composed of key binding names and their\n         associated keystrokes."
      },
      "throws": []
    },
    {
      "name": "exportKeyBindings",
      "comment": "Saves the key bindings from the provided options object to a file chosen\n by the user.\n \n If there is a problem writing the data then the user will be shown an\n error dialog.",
      "javadoc": "Saves the key bindings from the provided options object to a file chosen\n by the user.\n \u003cp\u003e\n If there is a problem writing the data then the user will be shown an\n error dialog.\n@param keyBindingOptions The options that contains key binding data.",
      "static": true,
      "params": [
        {
          "name": "keyBindingOptions",
          "type_long": "ghidra.framework.options.ToolOptions",
          "type_short": "ToolOptions",
          "comment": "The options that contains key binding data."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "retargetEvent",
      "comment": "Changes the given key event to the new source component and then dispatches that event.\n This method is intended for clients that wish to effectively take a key event given to\n one component and give it to another component.\n \n This method exists to deal with the complicated nature of key event processing and\n how our (not Java\u0027s) framework processes key event bindings to trigger actions.  If not\n for our special processing of action key bindings, then this method would not be\n necessary.\n \n This is seldom-used code; if you don\u0027t know when to use this code, then don\u0027t.",
      "javadoc": "Changes the given key event to the new source component and then dispatches that event.\n This method is intended for clients that wish to effectively take a key event given to\n one component and give it to another component.\n \n \u003cp\u003eThis method exists to deal with the complicated nature of key event processing and\n how our (not Java\u0027s) framework processes key event bindings to trigger actions.  If not\n for our special processing of action key bindings, then this method would not be\n necessary.\n \n \u003cp\u003e\u003cb\u003eThis is seldom-used code; if you don\u0027t know when to use this code, then don\u0027t.\u003c/b\u003e\n@param newSource the new target of the event\n@param e the existing event",
      "static": true,
      "params": [
        {
          "name": "newSource",
          "type_long": "java.awt.Component",
          "type_short": "Component",
          "comment": "the new target of the event"
        },
        {
          "name": "e",
          "type_long": "java.awt.event.KeyEvent",
          "type_short": "KeyEvent",
          "comment": "the existing event"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "registerAction",
      "comment": "A convenience method to register the given action with the given\n component. This is not usually done, as the action system is usually\n managed by the application\u0027s tool. However, for actions that are not\n registered with a tool, they can instead be bound to a component, hence\n this method.\n \n The given action must have a keystroke assigned, or this method will do\n nothing.",
      "javadoc": "A convenience method to register the given action with the given\n component. This is not usually done, as the action system is usually\n managed by the application\u0027s tool. However, for actions that are not\n registered with a tool, they can instead be bound to a component, hence\n this method.\n \u003cp\u003e\n The given action must have a keystroke assigned, or this method will do\n nothing.\n@param component the component to which the given action will be bound\n@param action the action to bind",
      "static": true,
      "params": [
        {
          "name": "component",
          "type_long": "javax.swing.JComponent",
          "type_short": "JComponent",
          "comment": "the component to which the given action will be bound"
        },
        {
          "name": "action",
          "type_long": "docking.action.DockingAction",
          "type_short": "DockingAction",
          "comment": "the action to bind"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "registerAction",
      "comment": "A convenience method to register the given action with the given\n component. This is not usually done, as the action system is usually\n managed by the application\u0027s tool. However, for actions that are not\n registered with a tool, they can instead be bound to a component, hence\n this method.\n \n The given action must have a keystroke assigned, or this method will do\n nothing.\n \n \n A typical use-case is to register an existing docking action with a text\n component, which is needed because the docking key event processing will\n not execute docking- registered actions if a text component has focus.",
      "javadoc": "A convenience method to register the given action with the given\n component. This is not usually done, as the action system is usually\n managed by the application\u0027s tool. However, for actions that are not\n registered with a tool, they can instead be bound to a component, hence\n this method.\n \u003cp\u003e\n The given action must have a keystroke assigned, or this method will do\n nothing.\n \n \u003cp\u003e\n A typical use-case is to register an existing docking action with a text\n component, which is needed because the docking key event processing will\n not execute docking- registered actions if a text component has focus.\n@param component the component to which the given action will be bound\n@param action the action to bind\n@param contextProvider the provider of the context",
      "static": true,
      "params": [
        {
          "name": "component",
          "type_long": "javax.swing.JComponent",
          "type_short": "JComponent",
          "comment": "the component to which the given action will be bound"
        },
        {
          "name": "action",
          "type_long": "docking.action.DockingAction",
          "type_short": "DockingAction",
          "comment": "the action to bind"
        },
        {
          "name": "contextProvider",
          "type_long": "docking.action.ActionContextProvider",
          "type_short": "ActionContextProvider",
          "comment": "the provider of the context"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "registerAction",
      "comment": "A convenience method to register the given action with the given\n component. This is not usually done, as the action system is usually\n managed by the application\u0027s tool. However, for actions that are not\n registered with a tool, they can instead be bound to a component, hence\n this method.\n \n The given action must have a keystroke assigned, or this method will do\n nothing.\n \n \n A typical use-case is to register an existing docking action with a text\n component, which is needed because the docking key event processing will\n not execute docking- registered actions if a text component has focus.",
      "javadoc": "A convenience method to register the given action with the given\n component. This is not usually done, as the action system is usually\n managed by the application\u0027s tool. However, for actions that are not\n registered with a tool, they can instead be bound to a component, hence\n this method.\n \u003cp\u003e\n The given action must have a keystroke assigned, or this method will do\n nothing.\n \n \u003cp\u003e\n A typical use-case is to register an existing docking action with a text\n component, which is needed because the docking key event processing will\n not execute docking- registered actions if a text component has focus.\n@param component the component to which the given action will be bound\n@param action the action to bind\n@param contextProvider the provider of the context\n@param focusCondition see {@link JComponent} for more info; the default\n            is usually {@link JComponent#WHEN_FOCUSED}",
      "static": true,
      "params": [
        {
          "name": "component",
          "type_long": "javax.swing.JComponent",
          "type_short": "JComponent",
          "comment": "the component to which the given action will be bound"
        },
        {
          "name": "action",
          "type_long": "docking.action.DockingAction",
          "type_short": "DockingAction",
          "comment": "the action to bind"
        },
        {
          "name": "contextProvider",
          "type_long": "docking.action.ActionContextProvider",
          "type_short": "ActionContextProvider",
          "comment": "the provider of the context"
        },
        {
          "name": "focusCondition",
          "type_long": "int",
          "type_short": "int",
          "comment": "see JComponent for more info; the default\n            is usually JComponent#WHEN_FOCUSED"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "registerAction",
      "comment": "Registers the given action with the given key binding on the given\n component.",
      "javadoc": "Registers the given action with the given key binding on the given\n component.\n@param component the component to which the action will be registered\n@param keyStroke the keystroke for to which the action will be bound\n@param action the action to execute when the given keystroke is triggered\n@param focusCondition the focus condition under which to bind the action\n            ({@link JComponent#getInputMap(int)}).  See {@link JComponent} for more info;\n            the default is usually {@link JComponent#WHEN_FOCUSED}",
      "static": true,
      "params": [
        {
          "name": "component",
          "type_long": "javax.swing.JComponent",
          "type_short": "JComponent",
          "comment": "the component to which the action will be registered"
        },
        {
          "name": "keyStroke",
          "type_long": "javax.swing.KeyStroke",
          "type_short": "KeyStroke",
          "comment": "the keystroke for to which the action will be bound"
        },
        {
          "name": "action",
          "type_long": "javax.swing.Action",
          "type_short": "Action",
          "comment": "the action to execute when the given keystroke is triggered"
        },
        {
          "name": "focusCondition",
          "type_long": "int",
          "type_short": "int",
          "comment": "the focus condition under which to bind the action\n            (JComponent#getInputMap(int)).  See JComponent for more info;\n            the default is usually JComponent#WHEN_FOCUSED"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "clearKeyBinding",
      "comment": "Allows the client to clear Java key bindings when the client is creating a docking\n action.   Without this call, any actions bound to the given component will prevent an\n action with the same key binding from firing.  This is useful when your\n application is using tool-level key bindings that share the same\n keystroke as a built-in Java action, such as Ctrl-C for the copy action.",
      "javadoc": "Allows the client to clear Java key bindings when the client is creating a docking\n action.   Without this call, any actions bound to the given component will prevent an\n action with the same key binding from firing.  This is useful when your\n application is using tool-level key bindings that share the same\n keystroke as a built-in Java action, such as Ctrl-C for the copy action.\n@param component the component for which to clear the key binding\n@param action the action from which to get the key binding",
      "static": true,
      "params": [
        {
          "name": "component",
          "type_long": "javax.swing.JComponent",
          "type_short": "JComponent",
          "comment": "the component for which to clear the key binding"
        },
        {
          "name": "action",
          "type_long": "docking.action.DockingActionIf",
          "type_short": "DockingActionIf",
          "comment": "the action from which to get the key binding"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "clearKeyBinding",
      "comment": "Allows clients to clear Java key bindings. This is useful when your\n application is using tool-level key bindings that share the same\n keystroke as a built-in Java action, such as Ctrl-C for the copy action.\n \n Note: this method clears the key binding for the\n JComponent#WHEN_FOCUSED and\n JComponent#WHEN_ANCESTOR_OF_FOCUSED_COMPONENT focus conditions.",
      "javadoc": "Allows clients to clear Java key bindings. This is useful when your\n application is using tool-level key bindings that share the same\n keystroke as a built-in Java action, such as Ctrl-C for the copy action.\n \u003cp\u003e\n Note: this method clears the key binding for the\n {@link JComponent#WHEN_FOCUSED} and\n {@link JComponent#WHEN_ANCESTOR_OF_FOCUSED_COMPONENT} focus conditions.\n@param component the component for which to clear the key binding\n@param keyStroke the keystroke of the binding to be cleared\n@see #clearKeyBinding(JComponent, KeyStroke, int)",
      "static": true,
      "params": [
        {
          "name": "component",
          "type_long": "javax.swing.JComponent",
          "type_short": "JComponent",
          "comment": "the component for which to clear the key binding"
        },
        {
          "name": "keyStroke",
          "type_long": "javax.swing.KeyStroke",
          "type_short": "KeyStroke",
          "comment": "the keystroke of the binding to be cleared"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "clearKeyBinding",
      "comment": "Allows clients to clear Java key bindings. This is useful when your\n application is using tool-level key bindings that share the same\n keystroke as a built-in Java action, such as Ctrl-C for the copy action.",
      "javadoc": "Allows clients to clear Java key bindings. This is useful when your\n application is using tool-level key bindings that share the same\n keystroke as a built-in Java action, such as Ctrl-C for the copy action.\n@param component the component for which to clear the key binding\n@param keyStroke the keystroke of the binding to be cleared\n@param focusCondition the particular focus condition under which the\n            given keystroke is used (see\n            {@link JComponent#getInputMap(int)}).",
      "static": true,
      "params": [
        {
          "name": "component",
          "type_long": "javax.swing.JComponent",
          "type_short": "JComponent",
          "comment": "the component for which to clear the key binding"
        },
        {
          "name": "keyStroke",
          "type_long": "javax.swing.KeyStroke",
          "type_short": "KeyStroke",
          "comment": "the keystroke of the binding to be cleared"
        },
        {
          "name": "focusCondition",
          "type_long": "int",
          "type_short": "int",
          "comment": "the particular focus condition under which the\n            given keystroke is used (see\n            JComponent#getInputMap(int))."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "clearKeyBinding",
      "comment": "Clears the currently assigned Java key binding for the action by the given name.  This\n method will find the currently assigned key binding, if any, and then remove it.",
      "javadoc": "Clears the currently assigned Java key binding for the action by the given name.  This\n method will find the currently assigned key binding, if any, and then remove it.\n@param component the component for which to clear the key binding\n@param actionName the name of the action that should not have a key binding\n@see LookAndFeel",
      "static": true,
      "params": [
        {
          "name": "component",
          "type_long": "javax.swing.JComponent",
          "type_short": "JComponent",
          "comment": "the component for which to clear the key binding"
        },
        {
          "name": "actionName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the action that should not have a key binding"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getAction",
      "comment": "Returns the registered action for the given keystroke, or null of no\n action is bound to that keystroke.",
      "javadoc": "Returns the registered action for the given keystroke, or null of no\n action is bound to that keystroke.\n@param component the component for which to check the binding\n@param keyStroke the keystroke for which to find a bound action\n@param focusCondition the focus condition under which to check for the\n            binding ({@link JComponent#getInputMap(int)})\n@return the action registered to the given keystroke, or null of no\n         action is registered",
      "static": true,
      "params": [
        {
          "name": "component",
          "type_long": "javax.swing.JComponent",
          "type_short": "JComponent",
          "comment": "the component for which to check the binding"
        },
        {
          "name": "keyStroke",
          "type_long": "javax.swing.KeyStroke",
          "type_short": "KeyStroke",
          "comment": "the keystroke for which to find a bound action"
        },
        {
          "name": "focusCondition",
          "type_long": "int",
          "type_short": "int",
          "comment": "the focus condition under which to check for the\n            binding (JComponent#getInputMap(int))"
        }
      ],
      "return": {
        "type_long": "javax.swing.Action",
        "type_short": "Action",
        "comment": "the action registered to the given keystroke, or null of no\n         action is registered"
      },
      "throws": []
    },
    {
      "name": "getAllActionsByFullName",
      "comment": "A utility method to get all key binding actions.  This method will\n only return actions that support KeyBindingType.\n \n The mapping returned provides a list of items because it is possible for there to\n exists multiple actions with the same name and owner.  (This can happen when multiple copies\n of a component provider are shown, each with their own set of actions that share the\n same name.)",
      "javadoc": "A utility method to get all key binding actions.  This method will\n only return actions that support {@link KeyBindingType key bindings}.\n \n \u003cp\u003eThe mapping returned provides a list of items because it is possible for there to\n exists multiple actions with the same name and owner.  (This can happen when multiple copies\n of a component provider are shown, each with their own set of actions that share the\n same name.)\n@param tool the tool containing the actions\n@return the actions mapped by their full name (e.g., \u0027Name (OwnerName)\u0027)",
      "static": true,
      "params": [
        {
          "name": "tool",
          "type_long": "docking.Tool",
          "type_short": "Tool",
          "comment": "the tool containing the actions"
        }
      ],
      "return": {
        "type_long": "java.util.Map\u003cjava.lang.String,java.util.List\u003cdocking.action.DockingActionIf\u003e\u003e",
        "type_short": "Map",
        "comment": "the actions mapped by their full name (e.g., \u0027Name (OwnerName)\u0027)"
      },
      "throws": []
    },
    {
      "name": "getKeyBindingActionsForOwner",
      "comment": "A utility method to get all key binding actions that have the given owner.\n This method will remove duplicate actions and will only return actions\n that support KeyBindingType.",
      "javadoc": "A utility method to get all key binding actions that have the given owner.\n This method will remove duplicate actions and will only return actions\n that support {@link KeyBindingType key bindings}.\n@param tool the tool containing the actions\n@param owner the action owner name\n@return the actions",
      "static": true,
      "params": [
        {
          "name": "tool",
          "type_long": "docking.Tool",
          "type_short": "Tool",
          "comment": "the tool containing the actions"
        },
        {
          "name": "owner",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the action owner name"
        }
      ],
      "return": {
        "type_long": "java.util.Set\u003cdocking.action.DockingActionIf\u003e",
        "type_short": "Set",
        "comment": "the actions"
      },
      "throws": []
    },
    {
      "name": "getActions",
      "comment": "Returns all actions that match the given owner and name",
      "javadoc": "Returns all actions that match the given owner and name\n@param allActions the universe of actions\n@param owner the owner\n@param name the name\n@return the actions",
      "static": true,
      "params": [
        {
          "name": "allActions",
          "type_long": "java.util.Set\u003cdocking.action.DockingActionIf\u003e",
          "type_short": "Set",
          "comment": "the universe of actions"
        },
        {
          "name": "owner",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the owner"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name"
        }
      ],
      "return": {
        "type_long": "java.util.Set\u003cdocking.action.DockingActionIf\u003e",
        "type_short": "Set",
        "comment": "the actions"
      },
      "throws": []
    },
    {
      "name": "adaptDockingActionToNonContextAction",
      "comment": "Takes the existing docking action and allows it to be registered with\n Swing components\n \n \n The new action will not be correctly wired into the Docking Action\n Context system. This means that the given docking action should not rely\n on DockingAction#isEnabledForContext(docking.ActionContext) to\n work when called from the Swing widget.",
      "javadoc": "Takes the existing docking action and allows it to be registered with\n Swing components\n \n \u003cp\u003e\n The new action will not be correctly wired into the Docking Action\n Context system. This means that the given docking action should not rely\n on {@link DockingAction#isEnabledForContext(docking.ActionContext)} to\n work when called from the Swing widget.\n@param action the docking action to adapt to a Swing {@link Action}\n@return the new action",
      "static": true,
      "params": [
        {
          "name": "action",
          "type_long": "docking.action.DockingAction",
          "type_short": "DockingAction",
          "comment": "the docking action to adapt to a Swing Action"
        }
      ],
      "return": {
        "type_long": "javax.swing.Action",
        "type_short": "Action",
        "comment": "the new action"
      },
      "throws": []
    },
    {
      "name": "assertSameDefaultKeyBindings",
      "comment": "Checks each action in the given collection against the given new action to make sure that\n they share the same default key binding.",
      "javadoc": "Checks each action in the given collection against the given new action to make sure that\n they share the same default key binding.\n@param newAction the action to check\n@param existingActions the actions that have already been checked",
      "static": true,
      "params": [
        {
          "name": "newAction",
          "type_long": "docking.action.DockingActionIf",
          "type_short": "DockingActionIf",
          "comment": "the action to check"
        },
        {
          "name": "existingActions",
          "type_long": "java.util.Collection\u003cdocking.action.DockingActionIf\u003e",
          "type_short": "Collection",
          "comment": "the actions that have already been checked"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "logDifferentKeyBindingsWarnigMessage",
      "comment": "Logs a warning message for the two given actions to signal that they do not share the\n same default key binding",
      "javadoc": "Logs a warning message for the two given actions to signal that they do not share the\n same default key binding\n@param newAction the new action\n@param existingAction the action that has already been validated\n@param existingDefaultKs the current validated key stroke",
      "static": true,
      "params": [
        {
          "name": "newAction",
          "type_long": "docking.action.DockingActionIf",
          "type_short": "DockingActionIf",
          "comment": "the new action"
        },
        {
          "name": "existingAction",
          "type_long": "docking.action.DockingActionIf",
          "type_short": "DockingActionIf",
          "comment": "the action that has already been validated"
        },
        {
          "name": "existingDefaultKs",
          "type_long": "javax.swing.KeyStroke",
          "type_short": "KeyStroke",
          "comment": "the current validated key stroke"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "validateKeyStroke",
      "comment": "Updates the given data with system-independent versions of key modifiers.  For example,\n the control key will be converted to the command key on the Mac.",
      "javadoc": "Updates the given data with system-independent versions of key modifiers.  For example,\n the \u003ccode\u003econtrol\u003c/code\u003e key will be converted to the \u003ccode\u003ecommand\u003c/code\u003e key on the Mac.\n@param keyStroke the keystroke to validate\n@return the potentially changed keystroke",
      "static": true,
      "params": [
        {
          "name": "keyStroke",
          "type_long": "javax.swing.KeyStroke",
          "type_short": "KeyStroke",
          "comment": "the keystroke to validate"
        }
      ],
      "return": {
        "type_long": "javax.swing.KeyStroke",
        "type_short": "KeyStroke",
        "comment": "the potentially changed keystroke"
      },
      "throws": []
    },
    {
      "name": "parseKeyStroke",
      "comment": "Convert the toString() form of the keyStroke.\n In Java 1.4.2 and earlier, Ctrl-M is returned as \"keyCode CtrlM-P\"\n and we want it to look like: \"Ctrl-M\".\n In Java 1.5.0, Ctrl-M is returned as \"ctrl pressed M\"\n and we want it to look like: \"Ctrl-M\".\n In Java 11 we have seen toString() values get printed with repeated text, such\n as: \"shift ctrl pressed SHIFT\".  We want to trim off the repeated modifiers.",
      "javadoc": "Convert the toString() form of the keyStroke.\n \u003cbr\u003eIn Java 1.4.2 and earlier, Ctrl-M is returned as \"keyCode CtrlM-P\"\n and we want it to look like: \"Ctrl-M\".\n \u003cbr\u003eIn Java 1.5.0, Ctrl-M is returned as \"ctrl pressed M\"\n and we want it to look like: \"Ctrl-M\".\n \u003cbr\u003eIn Java 11 we have seen toString() values get printed with repeated text, such\n as: \"shift ctrl pressed SHIFT\".  We want to trim off the repeated modifiers.\n@param keyStroke the key stroke\n@return the string value; the empty string if the key stroke is null",
      "static": true,
      "params": [
        {
          "name": "keyStroke",
          "type_long": "javax.swing.KeyStroke",
          "type_short": "KeyStroke",
          "comment": "the key stroke"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the string value; the empty string if the key stroke is null"
      },
      "throws": []
    },
    {
      "name": "indexOf",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "source",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "search",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "offset",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isShift",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "mask",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isAlt",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "mask",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isControl",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "mask",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isMeta",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "mask",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "parseKeyStroke",
      "comment": "Parses the given text into a KeyStroke.  This method relies upon\n KeyStroke#getKeyStroke(String) for parsing.  Before making that call, this method\n will perform fixup on the given text for added flexibility.  For example, the given\n text may contain spaces or dashes as the separators between parts in the string.  Also,\n the text is converted such that it is not case-sensitive.  So, the following example\n formats are allowed:\n \n    Alt-F\n    alt p\n    Ctrl-Alt-Z\n    ctrl Z\n \n \n Note: The returned keystroke will always correspond to a  event,\n regardless of the value passed in (pressed, typed or released).",
      "javadoc": "Parses the given text into a KeyStroke.  This method relies upon\n {@link KeyStroke#getKeyStroke(String)} for parsing.  Before making that call, this method\n will perform fixup on the given text for added flexibility.  For example, the given\n text may contain spaces or dashes as the separators between parts in the string.  Also,\n the text is converted such that it is not case-sensitive.  So, the following example\n formats are allowed:\n \u003cpre\u003e\n    Alt-F\n    alt p\n    Ctrl-Alt-Z\n    ctrl Z\n \u003c/pre\u003e\n \n \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e The returned keystroke will always correspond to a {@code pressed} event,\n regardless of the value passed in (pressed, typed or released).\n@param keyStroke the key stroke\n@return the new key stroke (as returned by  {@link KeyStroke#getKeyStroke(String)}",
      "static": true,
      "params": [
        {
          "name": "keyStroke",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the key stroke"
        }
      ],
      "return": {
        "type_long": "javax.swing.KeyStroke",
        "type_short": "KeyStroke",
        "comment": "the new key stroke (as returned by  KeyStroke#getKeyStroke(String)"
      },
      "throws": []
    },
    {
      "name": "isIgnored",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "action",
          "type_long": "docking.action.DockingActionIf",
          "type_short": "DockingActionIf",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getKeyStroke",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "data",
          "type_long": "docking.action.KeyBindingData",
          "type_short": "KeyBindingData",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "javax.swing.KeyStroke",
        "type_short": "KeyStroke",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getInputStreamForFile",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "startingDir",
          "type_long": "java.io.File",
          "type_short": "File",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.io.InputStream",
        "type_short": "InputStream",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getOutputStreamForFile",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "startingDir",
          "type_long": "java.io.File",
          "type_short": "File",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.io.OutputStream",
        "type_short": "OutputStream",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getStartingDir",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [],
      "return": {
        "type_long": "java.io.File",
        "type_short": "File",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getFileFromUser",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "startingDir",
          "type_long": "java.io.File",
          "type_short": "File",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.io.File",
        "type_short": "File",
        "comment": ""
      },
      "throws": []
    }
  ]
}
