{
  "name": "LoaderInfoHeader",
  "comment": "See Apple\u0027s -- PEFBinaryFormat.h\n ",
  "javadoc": "See Apple\u0027s -- PEFBinaryFormat.h\n \u003cpre\u003e{@literal\n struct PEFLoaderInfoHeader {\n     SInt32  mainSection;              // Section containing the main symbol, -1 \u003d\u003e none.\n     UInt32  mainOffset;               // Offset of main symbol.\n     SInt32  initSection;              // Section containing the init routine\u0027s TVector, -1 \u003d\u003e none.\n     UInt32  initOffset;               // Offset of the init routine\u0027s TVector.\n     SInt32  termSection;              // Section containing the term routine\u0027s TVector, -1 \u003d\u003e none.\n     UInt32  termOffset;               // Offset of the term routine\u0027s TVector.\n     UInt32  importedLibraryCount;     // Number of imported libraries.  (\u0027l\u0027)\n     UInt32  totalImportedSymbolCount; // Total number of imported symbols.  (\u0027i\u0027)\n     UInt32  relocSectionCount;        // Number of sections with relocations.  (\u0027r\u0027)\n     UInt32  relocInstrOffset;         // Offset of the relocation instructions.\n     UInt32  loaderStringsOffset;      // Offset of the loader string table.\n     UInt32  exportHashOffset;         // Offset of the export hash table.\n     UInt32  exportHashTablePower;     // Export hash table size as log 2.  (Log2(\u0027h\u0027))\n     UInt32  exportedSymbolCount;      // Number of exported symbols.  (\u0027e\u0027)\n };\n }\u003c/pre\u003e",
  "static": false,
  "implements": [
    "ghidra.app.util.bin.StructConverter"
  ],
  "extends": "java.lang.Object",
  "fields": [
    {
      "name": "SIZEOF",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "56"
    },
    {
      "name": "_section",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.app.util.bin.format.pef.SectionHeader",
      "type_short": "SectionHeader",
      "constant_value": null
    },
    {
      "name": "mainSection",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "mainOffset",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "initSection",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "initOffset",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "termSection",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "termOffset",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "importedLibraryCount",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "totalImportedSymbolCount",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "relocSectionCount",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "relocInstrOffset",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "loaderStringsOffset",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "exportHashOffset",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "exportHashTablePower",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "exportedSymbolCount",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "_importedLibraries",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.util.List\u003cghidra.app.util.bin.format.pef.ImportedLibrary\u003e",
      "type_short": "List",
      "constant_value": null
    },
    {
      "name": "_importedSymbols",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.util.List\u003cghidra.app.util.bin.format.pef.ImportedSymbol\u003e",
      "type_short": "List",
      "constant_value": null
    },
    {
      "name": "_relocations",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.util.List\u003cghidra.app.util.bin.format.pef.LoaderRelocationHeader\u003e",
      "type_short": "List",
      "constant_value": null
    },
    {
      "name": "_exportedHashSlots",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.util.List\u003cghidra.app.util.bin.format.pef.ExportedSymbolHashSlot\u003e",
      "type_short": "List",
      "constant_value": null
    },
    {
      "name": "_exportedSymbolKeys",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.util.List\u003cghidra.app.util.bin.format.pef.ExportedSymbolKey\u003e",
      "type_short": "List",
      "constant_value": null
    },
    {
      "name": "_exportedSymbols",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.util.List\u003cghidra.app.util.bin.format.pef.ExportedSymbol\u003e",
      "type_short": "List",
      "constant_value": null
    }
  ],
  "methods": [
    {
      "name": "\u003cinit\u003e",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "reader",
          "type_long": "ghidra.app.util.bin.BinaryReader",
          "type_short": "BinaryReader",
          "comment": ""
        },
        {
          "name": "section",
          "type_long": "ghidra.app.util.bin.format.pef.SectionHeader",
          "type_short": "SectionHeader",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "getMainSection",
      "comment": "The mainSection field (4 bytes) specifies the number \n of the section in this container that contains the main \n symbol. If the fragment does not have a main symbol, \n this field is set to -1.",
      "javadoc": "The mainSection field (4 bytes) specifies the number \n of the section in this container that contains the main \n symbol. If the fragment does not have a main symbol, \n this field is set to -1.\n@return number of section containing main symbol",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "number of section containing main symbol"
      },
      "throws": []
    },
    {
      "name": "getMainOffset",
      "comment": "The mainOffset field (4 bytes) indicates the offset (in bytes) from the \n beginning of the section to the main symbol.",
      "javadoc": "The mainOffset field (4 bytes) indicates the offset (in bytes) from the \n beginning of the section to the main symbol.\n@return offset to the main symbol",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "offset to the main symbol"
      },
      "throws": []
    },
    {
      "name": "getInitSection",
      "comment": "The initSection field (4 bytes) contains the number of the \n section containing the initialization function\u0027s transition \n vector. If no initialization function exists, this field is set to -1.",
      "javadoc": "The initSection field (4 bytes) contains the number of the \n section containing the initialization function\u0027s transition \n vector. If no initialization function exists, this field is set to -1.\n@return number of the section containing the initialization function\u0027s transition vector",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "number of the section containing the initialization function\u0027s transition vector"
      },
      "throws": []
    },
    {
      "name": "getInitOffset",
      "comment": "The initOffset field (4 bytes) indicates the offset (in bytes) from the \n beginning of the section to the initialization function\u0027s transition vector.",
      "javadoc": "The initOffset field (4 bytes) indicates the offset (in bytes) from the \n beginning of the section to the initialization function\u0027s transition vector.\n@return offset to initialization function\u0027s transition vector",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "offset to initialization function\u0027s transition vector"
      },
      "throws": []
    },
    {
      "name": "getTermSection",
      "comment": "The termSection field (4 bytes) contains the number of the section containing \n the termination routine\u0027s transition vector. If no termination routine exists, \n this field is set to -1.",
      "javadoc": "The termSection field (4 bytes) contains the number of the section containing \n the termination routine\u0027s transition vector. If no termination routine exists, \n this field is set to -1.\n@return number of the section containing the termination routine\u0027s transition vector",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "number of the section containing the termination routine\u0027s transition vector"
      },
      "throws": []
    },
    {
      "name": "getTermOffset",
      "comment": "The termOffset field (4 bytes) indicates the offset \n (in bytes) from the beginning of the section to the termination routine\u0027s \n transition vector.",
      "javadoc": "The termOffset field (4 bytes) indicates the offset \n (in bytes) from the beginning of the section to the termination routine\u0027s \n transition vector.\n@return offset to termination routine\u0027s transition vector",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "offset to termination routine\u0027s transition vector"
      },
      "throws": []
    },
    {
      "name": "getImportedLibraryCount",
      "comment": "The importedLibraryCount field (4 bytes) indicates the \n number of imported libraries.",
      "javadoc": "The importedLibraryCount field (4 bytes) indicates the \n number of imported libraries.\n@return number of imported libraries",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "number of imported libraries"
      },
      "throws": []
    },
    {
      "name": "getTotalImportedSymbolCount",
      "comment": "The totalImportedSymbolCount field (4 bytes) \n indicates the total number of imported symbols.",
      "javadoc": "The totalImportedSymbolCount field (4 bytes) \n indicates the total number of imported symbols.\n@return number of imported symbols",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "number of imported symbols"
      },
      "throws": []
    },
    {
      "name": "getRelocSectionCount",
      "comment": "The relocSectionCount field (4 bytes) indicates the \n number of sections containing load-time relocations.",
      "javadoc": "The relocSectionCount field (4 bytes) indicates the \n number of sections containing load-time relocations.\n@return number of sections containing load-time relocations",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "number of sections containing load-time relocations"
      },
      "throws": []
    },
    {
      "name": "getRelocInstrOffset",
      "comment": "The relocInstrOffset field (4 bytes) indicates the offset (in bytes) from the \n beginning of the loader section to the start of the relocations area.",
      "javadoc": "The relocInstrOffset field (4 bytes) indicates the offset (in bytes) from the \n beginning of the loader section to the start of the relocations area.\n@return offset to the relocations",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "offset to the relocations"
      },
      "throws": []
    },
    {
      "name": "getLoaderStringsOffset",
      "comment": "The loaderStringsOffset field (4 bytes) indicates the offset \n (in bytes) from the beginning of the loader \n section to the start of the loader string table.",
      "javadoc": "The loaderStringsOffset field (4 bytes) indicates the offset \n (in bytes) from the beginning of the loader \n section to the start of the loader string table.\n@return offset to the loader string table",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "offset to the loader string table"
      },
      "throws": []
    },
    {
      "name": "getExportHashOffset",
      "comment": "The exportHashOffset field (4 bytes) indicates the offset \n (in bytes) from the beginning of the loader section \n to the start of the export hash table. The hash table should be 4-byte aligned \n with padding added if necessary.",
      "javadoc": "The exportHashOffset field (4 bytes) indicates the offset \n (in bytes) from the beginning of the loader section \n to the start of the export hash table. The hash table should be 4-byte aligned \n with padding added if necessary.\n@return offset to the export hash table",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "offset to the export hash table"
      },
      "throws": []
    },
    {
      "name": "getExportHashTablePower",
      "comment": "The exportHashTablePower field (4 bytes) indicates the \n number of hash index values (that is, the number of entries in the \n hash table). The number of entries is specified as a power of two. For example, \n a value of 0 indicates one entry, while a value of 2 indicates four entries. If \n no exports exist, the hash table still contains one entry, and the value of this \n field is 0.",
      "javadoc": "The exportHashTablePower field (4 bytes) indicates the \n number of hash index values (that is, the number of entries in the \n hash table). The number of entries is specified as a power of two. For example, \n a value of 0 indicates one entry, while a value of 2 indicates four entries. If \n no exports exist, the hash table still contains one entry, and the value of this \n field is 0.\n@return number of hash index values",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "number of hash index values"
      },
      "throws": []
    },
    {
      "name": "getExportedSymbolCount",
      "comment": "The exportedSymbolCount field (4 bytes) indicates the number of \n symbols exported from this container.",
      "javadoc": "The exportedSymbolCount field (4 bytes) indicates the number of \n symbols exported from this container.\n@return number of symbols exported from this container",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "number of symbols exported from this container"
      },
      "throws": []
    },
    {
      "name": "getSection",
      "comment": "Returns the section corresponding to this loader.",
      "javadoc": "Returns the section corresponding to this loader.\n@return the section corresponding to this loader",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.format.pef.SectionHeader",
        "type_short": "SectionHeader",
        "comment": "the section corresponding to this loader"
      },
      "throws": []
    },
    {
      "name": "findLibrary",
      "comment": "Finds the PEF library that contains the specified imported symbol index.",
      "javadoc": "Finds the PEF library that contains the specified imported symbol index.\n@param symbolIndex the imported symbol index\n@return PEF library that contains the specified imported symbol index",
      "static": false,
      "params": [
        {
          "name": "symbolIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the imported symbol index"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.pef.ImportedLibrary",
        "type_short": "ImportedLibrary",
        "comment": "PEF library that contains the specified imported symbol index"
      },
      "throws": []
    },
    {
      "name": "getImportedLibraries",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.List\u003cghidra.app.util.bin.format.pef.ImportedLibrary\u003e",
        "type_short": "List",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getImportedSymbols",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.List\u003cghidra.app.util.bin.format.pef.ImportedSymbol\u003e",
        "type_short": "List",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getRelocations",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.List\u003cghidra.app.util.bin.format.pef.LoaderRelocationHeader\u003e",
        "type_short": "List",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getExportedHashSlots",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.List\u003cghidra.app.util.bin.format.pef.ExportedSymbolHashSlot\u003e",
        "type_short": "List",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getExportedSymbolKeys",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.List\u003cghidra.app.util.bin.format.pef.ExportedSymbolKey\u003e",
        "type_short": "List",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getExportedSymbols",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.List\u003cghidra.app.util.bin.format.pef.ExportedSymbol\u003e",
        "type_short": "List",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "toDataType",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.data.DataType",
        "type_short": "DataType",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": ""
        },
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    }
  ]
}
