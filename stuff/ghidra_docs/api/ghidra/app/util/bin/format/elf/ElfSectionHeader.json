{
  "name": "ElfSectionHeader",
  "comment": "A class to represent the Elf32_Shdr data structure.\n \n \n typedef  int32_t  Elf32_Sword;\n typedef uint32_t  Elf32_Word;\n typedef uint32_t  Elf32_Addr;\n \n typedef struct {\n     Elf32_Word    sh_name;       //Section name (string tbl index)\n     Elf32_Word    sh_type;       //Section type\n     Elf32_Word    sh_flags;      //Section flags\n     Elf32_Addr    sh_addr;       //Section virtual addr at execution\n     Elf32_Off     sh_offset;     //Section file offset\n     Elf32_Word    sh_size;       //Section size in bytes\n     Elf32_Word    sh_link;       //Link to another section\n     Elf32_Word    sh_info;       //Additional section information\n     Elf32_Word    sh_addralign;  //Section alignment\n     Elf32_Word    sh_entsize;    //Entry size if section holds table *\n } Elf32_Shdr;\n \n typedef  uint32_t  Elf64_Word;\n typedef  uint64_t  Elf64_Xword;\n typedef  uint64_t  Elf64_Addr;\n typedef  uint64_t  Elf64_Off;\n \n typedef struct {\n     Elf64_Word    sh_name;       //Section name (string tbl index)\n     Elf64_Word    sh_type;       //Section type\n     Elf64_Xword   sh_flags;      //Section flags\n     Elf64_Addr    sh_addr;       //Section virtual addr at execution\n     Elf64_Off     sh_offset;     //Section file offset\n     Elf64_Xword   sh_size;       //Section size in bytes\n     Elf64_Word    sh_link;       //Link to another section\n     Elf64_Word    sh_info;       //Additional section information\n     Elf64_Xword   sh_addralign;  //Section alignment\n     Elf64_Xword   sh_entsize;    //Entry size if section holds table *\n } Elf64_Shdr;\n ",
  "javadoc": "A class to represent the Elf32_Shdr data structure.\n \u003cbr\u003e\n \u003cpre\u003e\n typedef  int32_t  Elf32_Sword;\n typedef uint32_t  Elf32_Word;\n typedef uint32_t  Elf32_Addr;\n \n typedef struct {\n     Elf32_Word    sh_name;       //Section name (string tbl index)\n     Elf32_Word    sh_type;       //Section type\n     Elf32_Word    sh_flags;      //Section flags\n     Elf32_Addr    sh_addr;       //Section virtual addr at execution\n     Elf32_Off     sh_offset;     //Section file offset\n     Elf32_Word    sh_size;       //Section size in bytes\n     Elf32_Word    sh_link;       //Link to another section\n     Elf32_Word    sh_info;       //Additional section information\n     Elf32_Word    sh_addralign;  //Section alignment\n     Elf32_Word    sh_entsize;    //Entry size if section holds table *\n } Elf32_Shdr;\n \n typedef  uint32_t  Elf64_Word;\n typedef  uint64_t  Elf64_Xword;\n typedef  uint64_t  Elf64_Addr;\n typedef  uint64_t  Elf64_Off;\n \n typedef struct {\n     Elf64_Word    sh_name;       //Section name (string tbl index)\n     Elf64_Word    sh_type;       //Section type\n     Elf64_Xword   sh_flags;      //Section flags\n     Elf64_Addr    sh_addr;       //Section virtual addr at execution\n     Elf64_Off     sh_offset;     //Section file offset\n     Elf64_Xword   sh_size;       //Section size in bytes\n     Elf64_Word    sh_link;       //Link to another section\n     Elf64_Word    sh_info;       //Additional section information\n     Elf64_Xword   sh_addralign;  //Section alignment\n     Elf64_Xword   sh_entsize;    //Entry size if section holds table *\n } Elf64_Shdr;\n \u003c/pre\u003e",
  "static": false,
  "implements": [
    "ghidra.app.util.bin.StructConverter",
    "ghidra.app.util.bin.format.Writeable",
    "ghidra.app.util.bin.format.MemoryLoadable"
  ],
  "extends": "java.lang.Object",
  "fields": [
    {
      "name": "sh_name",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "sh_type",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "sh_flags",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "long",
      "type_short": "long",
      "constant_value": null
    },
    {
      "name": "sh_addr",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "long",
      "type_short": "long",
      "constant_value": null
    },
    {
      "name": "sh_offset",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "long",
      "type_short": "long",
      "constant_value": null
    },
    {
      "name": "sh_size",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "long",
      "type_short": "long",
      "constant_value": null
    },
    {
      "name": "sh_link",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "sh_info",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "sh_addralign",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "long",
      "type_short": "long",
      "constant_value": null
    },
    {
      "name": "sh_entsize",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "long",
      "type_short": "long",
      "constant_value": null
    },
    {
      "name": "reader",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.app.util.bin.format.FactoryBundledWithBinaryReader",
      "type_short": "FactoryBundledWithBinaryReader",
      "constant_value": null
    },
    {
      "name": "header",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.app.util.bin.format.elf.ElfHeader",
      "type_short": "ElfHeader",
      "constant_value": null
    },
    {
      "name": "name",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": null
    },
    {
      "name": "data",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "byte[]",
      "type_short": "byte[]",
      "constant_value": null
    },
    {
      "name": "modified",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "boolean",
      "type_short": "boolean",
      "constant_value": null
    },
    {
      "name": "bytesChanged",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "boolean",
      "type_short": "boolean",
      "constant_value": null
    }
  ],
  "methods": [
    {
      "name": "createElfSectionHeader",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "reader",
          "type_long": "ghidra.app.util.bin.format.FactoryBundledWithBinaryReader",
          "type_short": "FactoryBundledWithBinaryReader",
          "comment": ""
        },
        {
          "name": "header",
          "type_long": "ghidra.app.util.bin.format.elf.ElfHeader",
          "type_short": "ElfHeader",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
        "type_short": "ElfSectionHeader",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "\u003cinit\u003e",
      "comment": "DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.",
      "javadoc": "DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "initElfSectionHeader",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "reader",
          "type_long": "ghidra.app.util.bin.format.FactoryBundledWithBinaryReader",
          "type_short": "FactoryBundledWithBinaryReader",
          "comment": ""
        },
        {
          "name": "header",
          "type_long": "ghidra.app.util.bin.format.elf.ElfHeader",
          "type_short": "ElfHeader",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "\u003cinit\u003e",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "header",
          "type_long": "ghidra.app.util.bin.format.elf.ElfHeader",
          "type_short": "ElfHeader",
          "comment": ""
        },
        {
          "name": "block",
          "type_long": "ghidra.program.model.mem.MemoryBlock",
          "type_short": "MemoryBlock",
          "comment": ""
        },
        {
          "name": "sh_name",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        },
        {
          "name": "imageBase",
          "type_long": "long",
          "type_short": "long",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": ""
        }
      ]
    },
    {
      "name": "\u003cinit\u003e",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "header",
          "type_long": "ghidra.app.util.bin.format.elf.ElfHeader",
          "type_short": "ElfHeader",
          "comment": ""
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "sh_name",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        },
        {
          "name": "type",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getElfHeader",
      "comment": "Return ElfHeader associated with this section",
      "javadoc": "Return ElfHeader associated with this section\n@return ElfHeader",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfHeader",
        "type_short": "ElfHeader",
        "comment": "ElfHeader"
      },
      "throws": []
    },
    {
      "name": "write",
      "comment": "",
      "javadoc": "@see ghidra.app.util.bin.format.Writeable#write(java.io.RandomAccessFile, ghidra.util.DataConverter)",
      "static": false,
      "params": [
        {
          "name": "raf",
          "type_long": "java.io.RandomAccessFile",
          "type_short": "RandomAccessFile",
          "comment": ""
        },
        {
          "name": "dc",
          "type_long": "ghidra.util.DataConverter",
          "type_short": "DataConverter",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "getAddress",
      "comment": "If the section will appear in the memory image of a process, this \n member gives the address at which the section\u0027s first byte \n should reside. Otherwise, the member contains 0.",
      "javadoc": "If the section will appear in the memory image of a process, this \n member gives the address at which the section\u0027s first byte \n should reside. Otherwise, the member contains 0.\n@return the address of the section in memory",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the address of the section in memory"
      },
      "throws": []
    },
    {
      "name": "getAddressAlignment",
      "comment": "Some sections have address alignment constraints. For example, if a section holds a\n doubleword, the system must ensure doubleword alignment for the entire section.\n That is, the value of sh_addr must be congruent to 0, modulo the value of\n sh_addralign. Currently, only 0 and positive integral powers of two are allowed.\n Values 0 and 1 mean the section has no alignment constraints.",
      "javadoc": "Some sections have address alignment constraints. For example, if a section holds a\n doubleword, the system must ensure doubleword alignment for the entire section.\n That is, the value of sh_addr must be congruent to 0, modulo the value of\n sh_addralign. Currently, only 0 and positive integral powers of two are allowed.\n Values 0 and 1 mean the section has no alignment constraints.\n@return the section address alignment constraints",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the section address alignment constraints"
      },
      "throws": []
    },
    {
      "name": "getEntrySize",
      "comment": "Some sections hold a table of fixed-size entries, such as a symbol table. For such a section,\n this member gives the size in bytes of each entry. The member contains 0 if the\n section does not hold a table of fixed-size entries.",
      "javadoc": "Some sections hold a table of fixed-size entries, such as a symbol table. For such a section,\n this member gives the size in bytes of each entry. The member contains 0 if the\n section does not hold a table of fixed-size entries.\n@return the section entry size",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the section entry size"
      },
      "throws": []
    },
    {
      "name": "getFlags",
      "comment": "Sections support 1-bit flags that describe miscellaneous attributes. Flag definitions\n appear aove.",
      "javadoc": "Sections support 1-bit flags that describe miscellaneous attributes. Flag definitions\n appear aove.\n@return the section flags",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the section flags"
      },
      "throws": []
    },
    {
      "name": "isWritable",
      "comment": "Returns true if this section is writable.",
      "javadoc": "Returns true if this section is writable.\n@return true if this section is writable.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this section is writable."
      },
      "throws": []
    },
    {
      "name": "isExecutable",
      "comment": "Returns true if this section is executable.",
      "javadoc": "Returns true if this section is executable.\n@return true if this section is executable.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this section is executable."
      },
      "throws": []
    },
    {
      "name": "isAlloc",
      "comment": "Returns true if this section is allocated (e.g., SHF_ALLOC is set)",
      "javadoc": "Returns true if this section is allocated (e.g., SHF_ALLOC is set)\n@return true if this section is allocated.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this section is allocated."
      },
      "throws": []
    },
    {
      "name": "getInfo",
      "comment": "This member holds extra information, whose interpretation \n depends on the section type.\n  \n If sh_type is SHT_REL or SHT_RELA, then sh_info holds \n the section header index of the\n section to which the relocation applies.\n \n If sh_type is SHT_SYMTAB or SHT_DYNSYM, then sh_info\n holds one greater than the symbol table index of the last\n local symbol (binding STB_LOCAL).",
      "javadoc": "This member holds extra information, whose interpretation \n depends on the section type.\n  \n If sh_type is SHT_REL or SHT_RELA, then sh_info holds \n the section header index of the\n section to which the relocation applies.\n \n If sh_type is SHT_SYMTAB or SHT_DYNSYM, then sh_info\n holds one greater than the symbol table index of the last\n local symbol (binding STB_LOCAL).\n@return the section header info",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the section header info"
      },
      "throws": []
    },
    {
      "name": "getLink",
      "comment": "This member holds extra information, whose interpretation \n depends on the section type.\n \n If sh_type is SHT_SYMTAB, SHT_DYNSYM, or SHT_DYNAMIC, \n then sh_link holds the section header table index of\n its associated string table.\n \n If sh_type is SHT_REL, SHT_RELA, or SHT_HASH\n sh_link holds the section header index of the \n associated symbol table.",
      "javadoc": "This member holds extra information, whose interpretation \n depends on the section type.\n \n If sh_type is SHT_SYMTAB, SHT_DYNSYM, or SHT_DYNAMIC, \n then sh_link holds the section header table index of\n its associated string table.\n \n If sh_type is SHT_REL, SHT_RELA, or SHT_HASH\n sh_link holds the section header index of the \n associated symbol table.\n@return the section header link",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the section header link"
      },
      "throws": []
    },
    {
      "name": "getName",
      "comment": "An index into the section header string table section, \n giving the location of a null-terminated string which is the name of this section.",
      "javadoc": "An index into the section header string table section, \n giving the location of a null-terminated string which is the name of this section.\n@return the index of the section name",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the index of the section name"
      },
      "throws": []
    },
    {
      "name": "updateName",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getNameAsString",
      "comment": "Returns the actual string name for this section. The section only\n stores an byte index into the string table where\n the name string is located.",
      "javadoc": "Returns the actual string name for this section. The section only\n stores an byte index into the string table where\n the name string is located.\n@return the actual string name for this section",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the actual string name for this section"
      },
      "throws": []
    },
    {
      "name": "toString",
      "comment": "",
      "javadoc": "@see java.lang.Object#toString()",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getOffset",
      "comment": "The byte offset from the beginning of the file to the first\n byte in the section.\n One section type, SHT_NOBITS described below, occupies no\n space in the file, and its sh_offset member locates the conceptual placement in the\n file.",
      "javadoc": "The byte offset from the beginning of the file to the first\n byte in the section.\n One section type, SHT_NOBITS described below, occupies no\n space in the file, and its sh_offset member locates the conceptual placement in the\n file.\n@return byte offset from the beginning of the file to the first byte in the section",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "byte offset from the beginning of the file to the first byte in the section"
      },
      "throws": []
    },
    {
      "name": "setSize",
      "comment": "Sets the section\u0027s size.",
      "javadoc": "Sets the section\u0027s size.\n@param size the new size of the section",
      "static": false,
      "params": [
        {
          "name": "size",
          "type_long": "long",
          "type_short": "long",
          "comment": "the new size of the section"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getSize",
      "comment": "This member gives the section\u0027s size in bytes. Unless the section type is\n SHT_NOBITS, the section occupies sh_size bytes in the file. A section of type\n SHT_NOBITS may have a non-zero size, but it occupies no space in the file.",
      "javadoc": "This member gives the section\u0027s size in bytes. Unless the section type is\n SHT_NOBITS, the section occupies sh_size bytes in the file. A section of type\n SHT_NOBITS may have a non-zero size, but it occupies no space in the file.\n@return the section\u0027s size in bytes",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the section\u0027s size in bytes"
      },
      "throws": []
    },
    {
      "name": "getAdjustedSize",
      "comment": "Get the adjusted size of the section in bytes (i.e., memory block) which relates to this section header; it may be zero\n if no block should be created.  The returned value reflects any adjustment the ElfExtension may require\n based upon the specific processor/language implementation which may require filtering of file bytes\n as read into memory.",
      "javadoc": "Get the adjusted size of the section in bytes (i.e., memory block) which relates to this section header; it may be zero\n if no block should be created.  The returned value reflects any adjustment the ElfExtension may require\n based upon the specific processor/language implementation which may require filtering of file bytes\n as read into memory.\n@return the number of bytes in the resulting memory block",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the number of bytes in the resulting memory block"
      },
      "throws": []
    },
    {
      "name": "getType",
      "comment": "This member categorizes the section\u0027s contents and semantics.",
      "javadoc": "This member categorizes the section\u0027s contents and semantics.\n@return the section\u0027s contents and semantics",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the section\u0027s contents and semantics"
      },
      "throws": []
    },
    {
      "name": "getTypeAsString",
      "comment": "Get header type as string.  ElfSectionHeaderType name will be returned\n if know, otherwise a numeric name of the form \"SHT_0x12345678\" will be returned.",
      "javadoc": "Get header type as string.  ElfSectionHeaderType name will be returned\n if know, otherwise a numeric name of the form \"SHT_0x12345678\" will be returned.\n@return header type as string",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "header type as string"
      },
      "throws": []
    },
    {
      "name": "getData",
      "comment": "Returns the actual data bytes from the file for this section",
      "javadoc": "Returns the actual data bytes from the file for this section\n@return the actual data bytes from the file for this section\n@throws IOException if an I/O error occurs while reading the file",
      "static": false,
      "params": [],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": "the actual data bytes from the file for this section"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if an I/O error occurs while reading the file"
        }
      ]
    },
    {
      "name": "getDataStream",
      "comment": "Returns an input stream starting at offset into\n the byte provider.\n NOTE: Do not use this method if you have called setData().",
      "javadoc": "Returns an input stream starting at offset into\n the byte provider.\n NOTE: Do not use this method if you have called setData().\n@return the input stream\n@throws IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.io.InputStream",
        "type_short": "InputStream",
        "comment": "the input stream"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if an I/O error occurs"
        }
      ]
    },
    {
      "name": "getReader",
      "comment": "Returns the binary reader.",
      "javadoc": "Returns the binary reader.\n@return the binary reader",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.BinaryReader",
        "type_short": "BinaryReader",
        "comment": "the binary reader"
      },
      "throws": []
    },
    {
      "name": "setData",
      "comment": "Sets the actual data bytes for this section.\n If the data is larger than the previous data, then \n the offset is set to -1 and the section will\n need to be relocated.",
      "javadoc": "Sets the actual data bytes for this section.\n If the data is larger than the previous data, then \n the offset is set to -1 and the section will\n need to be relocated.\n@param data the new data byte for this section",
      "static": false,
      "params": [
        {
          "name": "data",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "the new data byte for this section"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isBytesChanged",
      "comment": "Returns true if the data bytes have changed for this section.",
      "javadoc": "Returns true if the data bytes have changed for this section.\n@return true if the data bytes have changed for this section",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the data bytes have changed for this section"
      },
      "throws": []
    },
    {
      "name": "isModified",
      "comment": "Returns true if this section has been modified.\n A modified section requires that a new program header\n get created.",
      "javadoc": "Returns true if this section has been modified.\n A modified section requires that a new program header\n get created.\n@return true if this section has been modified",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this section has been modified"
      },
      "throws": []
    },
    {
      "name": "setOffset",
      "comment": "Sets the offset of this section. The offset is the actual byte\n offset into the file.",
      "javadoc": "Sets the offset of this section. The offset is the actual byte\n offset into the file.\n@param offset the file byte offset\n@throws IOException if an I/O occurs",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "long",
          "type_short": "long",
          "comment": "the file byte offset"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if an I/O occurs"
        }
      ]
    },
    {
      "name": "setAddress",
      "comment": "Sets the start address of this section.",
      "javadoc": "Sets the start address of this section.\n@param addr the new start address of this section",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "long",
          "type_short": "long",
          "comment": "the new start address of this section"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "setName",
      "comment": "Sets the name of this section (may get changed due to conflict)",
      "javadoc": "Sets the name of this section (may get changed due to conflict)\n@param name",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "toDataType",
      "comment": "",
      "javadoc": "@see ghidra.app.util.bin.StructConverter#toDataType()",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.data.DataType",
        "type_short": "DataType",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getTypeDataType",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.data.DataType",
        "type_short": "DataType",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "checkSize",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "hashCode",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "equals",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "obj",
          "type_long": "java.lang.Object",
          "type_short": "Object",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    }
  ]
}
