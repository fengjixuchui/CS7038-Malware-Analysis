{
  "name": "ElfHeader",
  "comment": "A class to represent the Executable and Linking Format (ELF)\n header and specification.",
  "javadoc": "A class to represent the Executable and Linking Format (ELF)\n header and specification.",
  "static": false,
  "implements": [
    "ghidra.app.util.bin.StructConverter",
    "ghidra.app.util.bin.format.Writeable"
  ],
  "extends": "java.lang.Object",
  "fields": [
    {
      "name": "MAX_HEADERS_TO_CHECK_FOR_IMAGEBASE",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "20"
    },
    {
      "name": "PAD_LENGTH",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "7"
    },
    {
      "name": "programHeaderTypeMap",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.util.HashMap\u003cjava.lang.Integer,ghidra.app.util.bin.format.elf.ElfProgramHeaderType\u003e",
      "type_short": "HashMap",
      "constant_value": null
    },
    {
      "name": "sectionHeaderTypeMap",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.util.HashMap\u003cjava.lang.Integer,ghidra.app.util.bin.format.elf.ElfSectionHeaderType\u003e",
      "type_short": "HashMap",
      "constant_value": null
    },
    {
      "name": "dynamicTypeMap",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.util.HashMap\u003cjava.lang.Integer,ghidra.app.util.bin.format.elf.ElfDynamicType\u003e",
      "type_short": "HashMap",
      "constant_value": null
    },
    {
      "name": "reader",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.app.util.bin.format.FactoryBundledWithBinaryReader",
      "type_short": "FactoryBundledWithBinaryReader",
      "constant_value": null
    },
    {
      "name": "elfLoadAdapter",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.app.util.bin.format.elf.extend.ElfLoadAdapter",
      "type_short": "ElfLoadAdapter",
      "constant_value": null
    },
    {
      "name": "e_ident_magic_num",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "byte",
      "type_short": "byte",
      "constant_value": null
    },
    {
      "name": "e_ident_magic_str",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": null
    },
    {
      "name": "e_ident_class",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "byte",
      "type_short": "byte",
      "constant_value": null
    },
    {
      "name": "e_ident_data",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "byte",
      "type_short": "byte",
      "constant_value": null
    },
    {
      "name": "e_ident_version",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "byte",
      "type_short": "byte",
      "constant_value": null
    },
    {
      "name": "e_ident_osabi",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "byte",
      "type_short": "byte",
      "constant_value": null
    },
    {
      "name": "e_ident_abiversion",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "byte",
      "type_short": "byte",
      "constant_value": null
    },
    {
      "name": "e_ident_pad",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "byte[]",
      "type_short": "byte[]",
      "constant_value": null
    },
    {
      "name": "e_type",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "short",
      "type_short": "short",
      "constant_value": null
    },
    {
      "name": "e_machine",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "short",
      "type_short": "short",
      "constant_value": null
    },
    {
      "name": "e_version",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "e_entry",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "long",
      "type_short": "long",
      "constant_value": null
    },
    {
      "name": "e_phoff",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "long",
      "type_short": "long",
      "constant_value": null
    },
    {
      "name": "e_shoff",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "long",
      "type_short": "long",
      "constant_value": null
    },
    {
      "name": "e_flags",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "e_ehsize",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "short",
      "type_short": "short",
      "constant_value": null
    },
    {
      "name": "e_phentsize",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "short",
      "type_short": "short",
      "constant_value": null
    },
    {
      "name": "e_phnum",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "short",
      "type_short": "short",
      "constant_value": null
    },
    {
      "name": "e_shentsize",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "short",
      "type_short": "short",
      "constant_value": null
    },
    {
      "name": "e_shnum",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "short",
      "type_short": "short",
      "constant_value": null
    },
    {
      "name": "e_shstrndx",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "short",
      "type_short": "short",
      "constant_value": null
    },
    {
      "name": "headerStructure",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.program.model.data.Structure",
      "type_short": "Structure",
      "constant_value": null
    },
    {
      "name": "parsed",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "boolean",
      "type_short": "boolean",
      "constant_value": null
    },
    {
      "name": "parsedSectionHeaders",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "boolean",
      "type_short": "boolean",
      "constant_value": null
    },
    {
      "name": "sectionHeaders",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader[]",
      "type_short": "ghidra.app.util.bin.format.elf.ElfSectionHeader[]",
      "constant_value": null
    },
    {
      "name": "programHeaders",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.app.util.bin.format.elf.ElfProgramHeader[]",
      "type_short": "ghidra.app.util.bin.format.elf.ElfProgramHeader[]",
      "constant_value": null
    },
    {
      "name": "stringTables",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.app.util.bin.format.elf.ElfStringTable[]",
      "type_short": "ghidra.app.util.bin.format.elf.ElfStringTable[]",
      "constant_value": null
    },
    {
      "name": "symbolTables",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.app.util.bin.format.elf.ElfSymbolTable[]",
      "type_short": "ghidra.app.util.bin.format.elf.ElfSymbolTable[]",
      "constant_value": null
    },
    {
      "name": "relocationTables",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.app.util.bin.format.elf.ElfRelocationTable[]",
      "type_short": "ghidra.app.util.bin.format.elf.ElfRelocationTable[]",
      "constant_value": null
    },
    {
      "name": "dynamicTable",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.app.util.bin.format.elf.ElfDynamicTable",
      "type_short": "ElfDynamicTable",
      "constant_value": null
    },
    {
      "name": "dynamicStringTable",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.app.util.bin.format.elf.ElfStringTable",
      "type_short": "ElfStringTable",
      "constant_value": null
    },
    {
      "name": "dynamicSymbolTable",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.app.util.bin.format.elf.ElfSymbolTable",
      "type_short": "ElfSymbolTable",
      "constant_value": null
    },
    {
      "name": "dynamicLibraryNames",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.lang.String[]",
      "type_short": "java.lang.String[]",
      "constant_value": null
    },
    {
      "name": "hasLittleEndianHeaders",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "boolean",
      "type_short": "boolean",
      "constant_value": null
    },
    {
      "name": "INITIAL_READ_LEN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "elfImageBase",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.lang.Long",
      "type_short": "Long",
      "constant_value": null
    },
    {
      "name": "preLinkImageBase",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.lang.Long",
      "type_short": "Long",
      "constant_value": null
    }
  ],
  "methods": [
    {
      "name": "createElfHeader",
      "comment": "Constructs a new ELF header using the specified byte provider.",
      "javadoc": "Constructs a new ELF header using the specified byte provider.\n@param provider the byte provider to supply the bytes\n@throws ElfException if the underlying bytes in the byte provider \n do not constitute a valid ELF.",
      "static": true,
      "params": [
        {
          "name": "factory",
          "type_long": "generic.continues.GenericFactory",
          "type_short": "GenericFactory",
          "comment": ""
        },
        {
          "name": "provider",
          "type_long": "ghidra.app.util.bin.ByteProvider",
          "type_short": "ByteProvider",
          "comment": "the byte provider to supply the bytes"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfHeader",
        "type_short": "ElfHeader",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.app.util.bin.format.elf.ElfException",
          "type_short": "ElfException",
          "comment": "if the underlying bytes in the byte provider \n do not constitute a valid ELF."
        }
      ]
    },
    {
      "name": "\u003cinit\u003e",
      "comment": "DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.",
      "javadoc": "DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getReader",
      "comment": "Returns the binary reader.",
      "javadoc": "Returns the binary reader.\n@return the binary reader",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.BinaryReader",
        "type_short": "BinaryReader",
        "comment": "the binary reader"
      },
      "throws": []
    },
    {
      "name": "initElfHeader",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "factory",
          "type_long": "generic.continues.GenericFactory",
          "type_short": "GenericFactory",
          "comment": ""
        },
        {
          "name": "provider",
          "type_long": "ghidra.app.util.bin.ByteProvider",
          "type_short": "ByteProvider",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.app.util.bin.format.elf.ElfException",
          "type_short": "ElfException",
          "comment": ""
        }
      ]
    },
    {
      "name": "initElfLoadAdapter",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "parse",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "getLoadAdapter",
      "comment": "Get the installed extension provider.  If the parse method has not yet been \n invoked, the default adapter will be returned.",
      "javadoc": "Get the installed extension provider.  If the parse method has not yet been \n invoked, the default adapter will be returned.\n@return ELF load adapter",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.extend.ElfLoadAdapter",
        "type_short": "ElfLoadAdapter",
        "comment": "ELF load adapter"
      },
      "throws": []
    },
    {
      "name": "adjustAddressForPrelink",
      "comment": "Adjust address offset for certain pre-linked binaries which do not adjust certain\n header fields (e.g., dynamic table address entries).  Standard GNU/Linux pre-linked \n shared libraries have adjusted header entries and this method should have no effect.",
      "javadoc": "Adjust address offset for certain pre-linked binaries which do not adjust certain\n header fields (e.g., dynamic table address entries).  Standard GNU/Linux pre-linked \n shared libraries have adjusted header entries and this method should have no effect.\n@param address\n@return address with appropriate pre-link adjustment added",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "long",
          "type_short": "long",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "address with appropriate pre-link adjustment added"
      },
      "throws": []
    },
    {
      "name": "unadjustAddressForPrelink",
      "comment": "Unadjust address offset for certain pre-linked binaries which do not adjust certain\n header fields (e.g., dynamic table address entries).  This may be needed when updating\n a header address field which requires pre-link adjustment.",
      "javadoc": "Unadjust address offset for certain pre-linked binaries which do not adjust certain\n header fields (e.g., dynamic table address entries).  This may be needed when updating\n a header address field which requires pre-link adjustment.\n@param address\n@return address with appropriate pre-link adjustment subtracted",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "long",
          "type_short": "long",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "address with appropriate pre-link adjustment subtracted"
      },
      "throws": []
    },
    {
      "name": "getProgramHeaderTypeMap",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.HashMap\u003cjava.lang.Integer,ghidra.app.util.bin.format.elf.ElfProgramHeaderType\u003e",
        "type_short": "HashMap",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getSectionHeaderTypeMap",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.HashMap\u003cjava.lang.Integer,ghidra.app.util.bin.format.elf.ElfSectionHeaderType\u003e",
        "type_short": "HashMap",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getProgramHeaderType",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "type",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfProgramHeaderType",
        "type_short": "ElfProgramHeaderType",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getSectionHeaderType",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "type",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeaderType",
        "type_short": "ElfSectionHeaderType",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getDynamicTypeMap",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.HashMap\u003cjava.lang.Integer,ghidra.app.util.bin.format.elf.ElfDynamicType\u003e",
        "type_short": "HashMap",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getDynamicType",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "type",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfDynamicType",
        "type_short": "ElfDynamicType",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getTypeSuffix",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "parseGNU_d",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "parseGNU_r",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "parseRelocationTables",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "parseSectionBasedRelocationTable",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "section",
          "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
          "type_short": "ElfSectionHeader",
          "comment": ""
        },
        {
          "name": "relocationTableList",
          "type_long": "java.util.ArrayList\u003cghidra.app.util.bin.format.elf.ElfRelocationTable\u003e",
          "type_short": "ArrayList",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "parseJMPRelocTable",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "relocationTableList",
          "type_long": "java.util.ArrayList\u003cghidra.app.util.bin.format.elf.ElfRelocationTable\u003e",
          "type_short": "ArrayList",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "parseDynamicRelocTable",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "relocationTableList",
          "type_long": "java.util.ArrayList\u003cghidra.app.util.bin.format.elf.ElfRelocationTable\u003e",
          "type_short": "ArrayList",
          "comment": ""
        },
        {
          "name": "relocTableAddrType",
          "type_long": "ghidra.app.util.bin.format.elf.ElfDynamicType",
          "type_short": "ElfDynamicType",
          "comment": ""
        },
        {
          "name": "relocEntrySizeType",
          "type_long": "ghidra.app.util.bin.format.elf.ElfDynamicType",
          "type_short": "ElfDynamicType",
          "comment": ""
        },
        {
          "name": "relocTableSizeType",
          "type_long": "ghidra.app.util.bin.format.elf.ElfDynamicType",
          "type_short": "ElfDynamicType",
          "comment": ""
        },
        {
          "name": "addendTypeReloc",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "getLinkedSection",
      "comment": "Get linked section",
      "javadoc": "Get linked section\n@param sectionIndex\n@param expectedTypes list of expectedTypes (may be omitted to accept any type)\n@return section or null if not found",
      "static": false,
      "params": [
        {
          "name": "sectionIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        },
        {
          "name": "expectedTypes",
          "type_long": "int[]",
          "type_short": "int[]",
          "comment": "list of expectedTypes (may be omitted to accept any type)"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
        "type_short": "ElfSectionHeader",
        "comment": "section or null if not found"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.NotFoundException",
          "type_short": "NotFoundException",
          "comment": ""
        }
      ]
    },
    {
      "name": "parseDynamicLibraryNames",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "parseDynamicTable",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "parseStringTables",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "parseDynamicStringTable",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "dynamicStringTableAddr",
          "type_long": "long",
          "type_short": "long",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfStringTable",
        "type_short": "ElfStringTable",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "parseSymbolTables",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "parseDynamicSymbolTable",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSymbolTable",
        "type_short": "ElfSymbolTable",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "deriveGnuHashDynamicSymbolCount",
      "comment": "Walk DT_GNU_HASH table to determine dynamic symbol count",
      "javadoc": "Walk DT_GNU_HASH table to determine dynamic symbol count\n@param DT_GNU_HASH table file offset\n@return dynamic symbol count\n@throws IOException file read error",
      "static": false,
      "params": [
        {
          "name": "gnuHashTableOffset",
          "type_long": "long",
          "type_short": "long",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "dynamic symbol count"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "file read error"
        }
      ]
    },
    {
      "name": "parseSectionHeaders",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "parseProgramHeaders",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "isBigEndian",
      "comment": "Returns true if this ELF was created for a big endian processor.",
      "javadoc": "Returns true if this ELF was created for a big endian processor.\n@return true if this ELF was created for a big endian processor",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this ELF was created for a big endian processor"
      },
      "throws": []
    },
    {
      "name": "isLittleEndian",
      "comment": "Returns true if this ELF was created for a little endian processor.",
      "javadoc": "Returns true if this ELF was created for a little endian processor.\n@return true if this ELF was created for a little endian processor",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this ELF was created for a little endian processor"
      },
      "throws": []
    },
    {
      "name": "is32Bit",
      "comment": "Returns true if this ELF was created for a 32-bit processor.",
      "javadoc": "Returns true if this ELF was created for a 32-bit processor.\n@return true if this ELF was created for a 32-bit processor",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this ELF was created for a 32-bit processor"
      },
      "throws": []
    },
    {
      "name": "is64Bit",
      "comment": "Returns true if this ELF was created for a 64-bit processor.",
      "javadoc": "Returns true if this ELF was created for a 64-bit processor.\n@return true if this ELF was created for a 64-bit processor",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this ELF was created for a 64-bit processor"
      },
      "throws": []
    },
    {
      "name": "getMinBase",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "long",
          "type_short": "long",
          "comment": ""
        },
        {
          "name": "minBase",
          "type_long": "long",
          "type_short": "long",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "findImageBase",
      "comment": "Inspect the Elf image and determine the default image base prior \n to the #parse() method being invoked (i.e., only the main Elf\n header structure has been parsed).\n The image base is the virtual address of the PT_LOAD program header\n with the smallest address or 0 if no program headers exist.  By default,\n the image base address should be treated as a addressable unit offset.",
      "javadoc": "Inspect the Elf image and determine the default image base prior \n to the {@link #parse()} method being invoked (i.e., only the main Elf\n header structure has been parsed).\n The image base is the virtual address of the PT_LOAD program header\n with the smallest address or 0 if no program headers exist.  By default,\n the image base address should be treated as a addressable unit offset.\n@return preferred image base",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "preferred image base"
      },
      "throws": []
    },
    {
      "name": "getImageBase",
      "comment": "Returns the image base of this ELF. \n The image base is the virtual address of the first PT_LOAD\n program header or 0 if no program headers. By default,\n the image base address should be treated as a addressable unit offset.s",
      "javadoc": "Returns the image base of this ELF. \n The image base is the virtual address of the first PT_LOAD\n program header or 0 if no program headers. By default,\n the image base address should be treated as a addressable unit offset.s\n@return the image base of this ELF",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the image base of this ELF"
      },
      "throws": []
    },
    {
      "name": "isPreLinked",
      "comment": "Determine if the image has been pre-linked.\n NOTE: Currently has very limited support.  Certain pre-link\n cases can not be detected until after a full parse has been \n performed.",
      "javadoc": "Determine if the image has been pre-linked.\n NOTE: Currently has very limited support.  Certain pre-link\n cases can not be detected until after a full parse has been \n performed.\n@return true if image has been pre-linked",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if image has been pre-linked"
      },
      "throws": []
    },
    {
      "name": "getPreLinkImageBase",
      "comment": "Some elfs can get pre-linked to an OS.\n     At the very end a \"PRE \" string is appended with the image base load address\n     set.  Try there if none of the images told us where to load.",
      "javadoc": "Some elfs can get pre-linked to an OS.\n     At the very end a \"PRE \" string is appended with the image base load address\n     set.  Try there if none of the images told us where to load.\n@return -1 - if the imagebase is not a pre-link image base.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "-1 - if the imagebase is not a pre-link image base."
      },
      "throws": []
    },
    {
      "name": "isSectionLoaded",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "section",
          "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
          "type_short": "ElfSectionHeader",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "determineHeaderEndianess",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "provider",
          "type_long": "ghidra.app.util.bin.ByteProvider",
          "type_short": "ByteProvider",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.app.util.bin.format.elf.ElfException",
          "type_short": "ElfException",
          "comment": ""
        },
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "e_ehsize",
      "comment": "This member holds the ELF header\u0027s size in bytes.",
      "javadoc": "This member holds the ELF header\u0027s size in bytes.\n@return the ELF header\u0027s size in bytes",
      "static": false,
      "params": [],
      "return": {
        "type_long": "short",
        "type_short": "short",
        "comment": "the ELF header\u0027s size in bytes"
      },
      "throws": []
    },
    {
      "name": "e_entry",
      "comment": "This member gives the virtual address to which the system first transfers control, thus\n starting the process. If the file has no associated entry point, this member holds zero.",
      "javadoc": "This member gives the virtual address to which the system first transfers control, thus\n starting the process. If the file has no associated entry point, this member holds zero.\n@return the virtual address to which the system first transfers control",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the virtual address to which the system first transfers control"
      },
      "throws": []
    },
    {
      "name": "e_flags",
      "comment": "This member holds processor-specific flags associated with the file. Flag names take\n the form EF_machine_flag.",
      "javadoc": "This member holds processor-specific flags associated with the file. Flag names take\n the form EF_machine_flag.\n@return the processor-specific flags associated with the file\n@see ElfConstants for flag definitions",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the processor-specific flags associated with the file"
      },
      "throws": []
    },
    {
      "name": "e_machine",
      "comment": "This member\u0027s value specifies the required architecture for an individual file.",
      "javadoc": "This member\u0027s value specifies the required architecture for an individual file.\n@return the required architecture for an individual file\n@see ElfConstants for machine definitions",
      "static": false,
      "params": [],
      "return": {
        "type_long": "short",
        "type_short": "short",
        "comment": "the required architecture for an individual file"
      },
      "throws": []
    },
    {
      "name": "e_ident_osabi",
      "comment": "This member identifies the target operating system and ABI.",
      "javadoc": "This member identifies the target operating system and ABI.\n@return the target operating system and ABI",
      "static": false,
      "params": [],
      "return": {
        "type_long": "byte",
        "type_short": "byte",
        "comment": "the target operating system and ABI"
      },
      "throws": []
    },
    {
      "name": "e_ident_abiversion",
      "comment": "This member identifies the target ABI version.",
      "javadoc": "This member identifies the target ABI version.\n@return the target ABI version",
      "static": false,
      "params": [],
      "return": {
        "type_long": "byte",
        "type_short": "byte",
        "comment": "the target ABI version"
      },
      "throws": []
    },
    {
      "name": "e_phentsize",
      "comment": "This member holds the size in bytes of one entry in the file\u0027s program header table;\n all entries are the same size.",
      "javadoc": "This member holds the size in bytes of one entry in the file\u0027s program header table;\n all entries are the same size.\n@return the size in bytes of one program header table entry",
      "static": false,
      "params": [],
      "return": {
        "type_long": "short",
        "type_short": "short",
        "comment": "the size in bytes of one program header table entry"
      },
      "throws": []
    },
    {
      "name": "e_phnum",
      "comment": "This member holds the number of entries in the program header table. Thus the product\n of e_phentsize and e_phnum gives the table\u0027s size in bytes. If a file has no program\n header table, e_phnum holds the value zero.",
      "javadoc": "This member holds the number of entries in the program header table. Thus the product\n of e_phentsize and e_phnum gives the table\u0027s size in bytes. If a file has no program\n header table, e_phnum holds the value zero.\n@return the number of entries in the program header table",
      "static": false,
      "params": [],
      "return": {
        "type_long": "short",
        "type_short": "short",
        "comment": "the number of entries in the program header table"
      },
      "throws": []
    },
    {
      "name": "e_phoff",
      "comment": "This member holds the program header table\u0027s file offset in bytes. If the file has no\n program header table, this member holds zero.",
      "javadoc": "This member holds the program header table\u0027s file offset in bytes. If the file has no\n program header table, this member holds zero.\n@return the program header table\u0027s file offset in bytes",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the program header table\u0027s file offset in bytes"
      },
      "throws": []
    },
    {
      "name": "e_shentsize",
      "comment": "This member holds the section header\u0027s size in bytes. A section header is one entry in\n the section header table; all entries are the same size.",
      "javadoc": "This member holds the section header\u0027s size in bytes. A section header is one entry in\n the section header table; all entries are the same size.\n@return the section header\u0027s size in bytes",
      "static": false,
      "params": [],
      "return": {
        "type_long": "short",
        "type_short": "short",
        "comment": "the section header\u0027s size in bytes"
      },
      "throws": []
    },
    {
      "name": "e_shnum",
      "comment": "This member holds the number of entries in the section header table. Thus the product\n of e_shentsize and e_shnum gives the section header table\u0027s size in bytes. If a file\n has no section header table, e_shnum holds the value zero.",
      "javadoc": "This member holds the number of entries in the section header table. Thus the product\n of e_shentsize and e_shnum gives the section header table\u0027s size in bytes. If a file\n has no section header table, e_shnum holds the value zero.\n@return the number of entries in the section header table",
      "static": false,
      "params": [],
      "return": {
        "type_long": "short",
        "type_short": "short",
        "comment": "the number of entries in the section header table"
      },
      "throws": []
    },
    {
      "name": "e_shoff",
      "comment": "This member holds the section header table\u0027s file offset in bytes. If the file has no section\n header table, this member holds zero.",
      "javadoc": "This member holds the section header table\u0027s file offset in bytes. If the file has no section\n header table, this member holds zero.\n@return the section header table\u0027s file offset in bytes",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the section header table\u0027s file offset in bytes"
      },
      "throws": []
    },
    {
      "name": "e_shstrndx",
      "comment": "This member holds the section header table index of the entry associated with the section\n name string table. If the file has no section name string table, this member holds\n the value SHN_UNDEF.",
      "javadoc": "This member holds the section header table index of the entry associated with the section\n name string table. If the file has no section name string table, this member holds\n the value SHN_UNDEF.\n@return the section header table index of the entry associated with the section name string table",
      "static": false,
      "params": [],
      "return": {
        "type_long": "short",
        "type_short": "short",
        "comment": "the section header table index of the entry associated with the section name string table"
      },
      "throws": []
    },
    {
      "name": "e_type",
      "comment": "This member identifies the object file type; executable, shared object, etc.",
      "javadoc": "This member identifies the object file type; executable, shared object, etc.\n@return the object file type",
      "static": false,
      "params": [],
      "return": {
        "type_long": "short",
        "type_short": "short",
        "comment": "the object file type"
      },
      "throws": []
    },
    {
      "name": "isRelocatable",
      "comment": "Returns true if this is a relocatable file.\n \n e_type \u003d\u003d NewElfHeaderConstants.ET_REL",
      "javadoc": "Returns true if this is a relocatable file.\n \u003cbr\u003e\n e_type \u003d\u003d NewElfHeaderConstants.ET_REL\n@return true if this is a relocatable file",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this is a relocatable file"
      },
      "throws": []
    },
    {
      "name": "isSharedObject",
      "comment": "Returns true if this is a shared object file.\n \n e_type \u003d\u003d NewElfHeaderConstants.ET_DYN",
      "javadoc": "Returns true if this is a shared object file.\n \u003cbr\u003e\n e_type \u003d\u003d NewElfHeaderConstants.ET_DYN\n@return true if this is a shared object file",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this is a shared object file"
      },
      "throws": []
    },
    {
      "name": "isExecutable",
      "comment": "Returns true if this is an executable file.\n \n e_type \u003d\u003d NewElfHeaderConstants.ET_EXEC",
      "javadoc": "Returns true if this is an executable file.\n \u003cbr\u003e\n e_type \u003d\u003d NewElfHeaderConstants.ET_EXEC\n@return true if this is a executable file",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this is a executable file"
      },
      "throws": []
    },
    {
      "name": "e_version",
      "comment": "This member identifies the object file version,\n where \"EV_NONE \u003d\u003d Invalid Version\" and \"EV_CURRENT \u003d\u003d Current Version\"\n The value 1 signifies the original file format; extensions will \n create new versions with higher numbers. \n The value of EV_CURRENT, though given as 1 above, will change as\n necessary to reflect the current version number.",
      "javadoc": "This member identifies the object file version,\n where \"EV_NONE \u003d\u003d Invalid Version\" and \"EV_CURRENT \u003d\u003d Current Version\"\n The value 1 signifies the original file format; extensions will \n create new versions with higher numbers. \n The value of EV_CURRENT, though given as 1 above, will change as\n necessary to reflect the current version number.\n@return the object file version",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the object file version"
      },
      "throws": []
    },
    {
      "name": "getSections",
      "comment": "Returns the section headers as defined in this ELF file.",
      "javadoc": "Returns the section headers as defined in this ELF file.\n@return the section headers as defined in this ELF file",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader[]",
        "type_short": "ghidra.app.util.bin.format.elf.ElfSectionHeader[]",
        "comment": "the section headers as defined in this ELF file"
      },
      "throws": []
    },
    {
      "name": "getSections",
      "comment": "Returns the section headers with the specified type.\n The array could be zero-length, but will not be null.",
      "javadoc": "Returns the section headers with the specified type.\n The array could be zero-length, but will not be null.\n@param type\n@return the section headers with the specified type\n@see ElfSectionHeader",
      "static": false,
      "params": [
        {
          "name": "type",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader[]",
        "type_short": "ghidra.app.util.bin.format.elf.ElfSectionHeader[]",
        "comment": "the section headers with the specified type"
      },
      "throws": []
    },
    {
      "name": "getSection",
      "comment": "Returns the section header with the specified name, or null\n if no section exists with that name.",
      "javadoc": "Returns the section header with the specified name, or null\n if no section exists with that name.\n@param name the name of the requested section\n@return the section header with the specified name",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the requested section"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
        "type_short": "ElfSectionHeader",
        "comment": "the section header with the specified name"
      },
      "throws": []
    },
    {
      "name": "getSectionAt",
      "comment": "Returns the section header at the specified address,\n or null if no section exists at that address.",
      "javadoc": "Returns the section header at the specified address,\n or null if no section exists at that address.\n@param address the address of the requested section\n@return the section header with the specified address",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "long",
          "type_short": "long",
          "comment": "the address of the requested section"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
        "type_short": "ElfSectionHeader",
        "comment": "the section header with the specified address"
      },
      "throws": []
    },
    {
      "name": "getSectionLoadHeaderContaining",
      "comment": "Returns the section header that loads/contains the specified address,\n or null if no section contains the address.",
      "javadoc": "Returns the section header that loads/contains the specified address,\n or null if no section contains the address.\n@param address the address of the requested section\n@return the section header that contains the address",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "long",
          "type_short": "long",
          "comment": "the address of the requested section"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
        "type_short": "ElfSectionHeader",
        "comment": "the section header that contains the address"
      },
      "throws": []
    },
    {
      "name": "getSectionHeaderContainingFileRange",
      "comment": "Returns the section header which fully contains the specified file offset range.",
      "javadoc": "Returns the section header which fully contains the specified file offset range.\n@param fileOffset file offset\n@param fileRangeLength length of file range in bytes\n@return section or null if not found",
      "static": false,
      "params": [
        {
          "name": "fileOffset",
          "type_long": "long",
          "type_short": "long",
          "comment": "file offset"
        },
        {
          "name": "fileRangeLength",
          "type_long": "long",
          "type_short": "long",
          "comment": "length of file range in bytes"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
        "type_short": "ElfSectionHeader",
        "comment": "section or null if not found"
      },
      "throws": []
    },
    {
      "name": "getSectionIndex",
      "comment": "Returns the index of the specified section.\n The index is the order in which the section was\n defined in the section header table.",
      "javadoc": "Returns the index of the specified section.\n The index is the order in which the section was\n defined in the section header table.\n@param section the section header\n@return the index of the specified section header",
      "static": false,
      "params": [
        {
          "name": "section",
          "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
          "type_short": "ElfSectionHeader",
          "comment": "the section header"
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the index of the specified section header"
      },
      "throws": []
    },
    {
      "name": "getProgramHeaders",
      "comment": "Returns the program headers as defined in this ELF file.",
      "javadoc": "Returns the program headers as defined in this ELF file.\n@return the program headers as defined in this ELF file",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfProgramHeader[]",
        "type_short": "ghidra.app.util.bin.format.elf.ElfProgramHeader[]",
        "comment": "the program headers as defined in this ELF file"
      },
      "throws": []
    },
    {
      "name": "getProgramHeaders",
      "comment": "Returns the program headers with the specified type.\n The array could be zero-length, but will not be null.",
      "javadoc": "Returns the program headers with the specified type.\n The array could be zero-length, but will not be null.\n@param type\n@return the program headers with the specified type\n@see ElfProgramHeader",
      "static": false,
      "params": [
        {
          "name": "type",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfProgramHeader[]",
        "type_short": "ghidra.app.util.bin.format.elf.ElfProgramHeader[]",
        "comment": "the program headers with the specified type"
      },
      "throws": []
    },
    {
      "name": "getDynamicTable",
      "comment": "Returns the dynamic table defined by program header of type PT_DYNAMIC or the .dynamic program section.\n Or, null if one does not exist.",
      "javadoc": "Returns the dynamic table defined by program header of type PT_DYNAMIC or the .dynamic program section.\n Or, null if one does not exist.\n@return the dynamic table",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfDynamicTable",
        "type_short": "ElfDynamicTable",
        "comment": "the dynamic table"
      },
      "throws": []
    },
    {
      "name": "getProgramHeaderProgramHeader",
      "comment": "Returns the program header with type of PT_PHDR.\n Or, null if one does not exist.",
      "javadoc": "Returns the program header with type of PT_PHDR.\n Or, null if one does not exist.\n@return the program header with type of PT_PHDR",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfProgramHeader",
        "type_short": "ElfProgramHeader",
        "comment": "the program header with type of PT_PHDR"
      },
      "throws": []
    },
    {
      "name": "getProgramHeaderAt",
      "comment": "Returns the program header at the specified address,\n or null if no program header exists at that address.",
      "javadoc": "Returns the program header at the specified address,\n or null if no program header exists at that address.\n@param virtualAddr the address of the requested program header\n@return the program header with the specified address",
      "static": false,
      "params": [
        {
          "name": "virtualAddr",
          "type_long": "long",
          "type_short": "long",
          "comment": "the address of the requested program header"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfProgramHeader",
        "type_short": "ElfProgramHeader",
        "comment": "the program header with the specified address"
      },
      "throws": []
    },
    {
      "name": "getProgramLoadHeaderContaining",
      "comment": "Returns the PT_LOAD program header which loads a range containing \n the specified address, or null if not found.",
      "javadoc": "Returns the PT_LOAD program header which loads a range containing \n the specified address, or null if not found.\n@param virtualAddr the address of the requested program header\n@return the program header with the specified address",
      "static": false,
      "params": [
        {
          "name": "virtualAddr",
          "type_long": "long",
          "type_short": "long",
          "comment": "the address of the requested program header"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfProgramHeader",
        "type_short": "ElfProgramHeader",
        "comment": "the program header with the specified address"
      },
      "throws": []
    },
    {
      "name": "getProgramLoadHeaderContainingFileOffset",
      "comment": "Returns the PT_LOAD program header which loads a range containing \n the specified file offset, or null if not found.",
      "javadoc": "Returns the PT_LOAD program header which loads a range containing \n the specified file offset, or null if not found.\n@param offset the file offset to be loaded\n@return the program header with the specified file offset",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "long",
          "type_short": "long",
          "comment": "the file offset to be loaded"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfProgramHeader",
        "type_short": "ElfProgramHeader",
        "comment": "the program header with the specified file offset"
      },
      "throws": []
    },
    {
      "name": "getDynamicLibraryNames",
      "comment": "Returns array of dynamic library names defined by DT_NEEDED",
      "javadoc": "Returns array of dynamic library names defined by DT_NEEDED\n@return array of dynamic library names",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String[]",
        "type_short": "java.lang.String[]",
        "comment": "array of dynamic library names"
      },
      "throws": []
    },
    {
      "name": "getDynamicStringTable",
      "comment": "Returns the dynamic string table as defined in this ELF file.",
      "javadoc": "Returns the dynamic string table as defined in this ELF file.\n@return the dynamic string table as defined in this ELF file",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfStringTable",
        "type_short": "ElfStringTable",
        "comment": "the dynamic string table as defined in this ELF file"
      },
      "throws": []
    },
    {
      "name": "getStringTables",
      "comment": "Returns the string tables as defined in this ELF file.",
      "javadoc": "Returns the string tables as defined in this ELF file.\n@return the string tables as defined in this ELF file",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfStringTable[]",
        "type_short": "ghidra.app.util.bin.format.elf.ElfStringTable[]",
        "comment": "the string tables as defined in this ELF file"
      },
      "throws": []
    },
    {
      "name": "getStringTable",
      "comment": "Returns the string table associated to the specified section header.\n Or, null if one does not exist.",
      "javadoc": "Returns the string table associated to the specified section header.\n Or, null if one does not exist.\n@return the string table associated to the specified section header",
      "static": false,
      "params": [
        {
          "name": "section",
          "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
          "type_short": "ElfSectionHeader",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfStringTable",
        "type_short": "ElfStringTable",
        "comment": "the string table associated to the specified section header"
      },
      "throws": []
    },
    {
      "name": "getDynamicSymbolTable",
      "comment": "Returns the dynamic symbol table as defined in this ELF file.",
      "javadoc": "Returns the dynamic symbol table as defined in this ELF file.\n@return the dynamic symbol table as defined in this ELF file",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSymbolTable",
        "type_short": "ElfSymbolTable",
        "comment": "the dynamic symbol table as defined in this ELF file"
      },
      "throws": []
    },
    {
      "name": "getSymbolTables",
      "comment": "Returns the symbol tables as defined in this ELF file.",
      "javadoc": "Returns the symbol tables as defined in this ELF file.\n@return the symbol tables as defined in this ELF file",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSymbolTable[]",
        "type_short": "ghidra.app.util.bin.format.elf.ElfSymbolTable[]",
        "comment": "the symbol tables as defined in this ELF file"
      },
      "throws": []
    },
    {
      "name": "getSymbolTable",
      "comment": "Returns the symbol table associated to the specified section header.\n Or, null if one does not exist.",
      "javadoc": "Returns the symbol table associated to the specified section header.\n Or, null if one does not exist.\n@return the symbol table associated to the specified section header",
      "static": false,
      "params": [
        {
          "name": "symbolTableSection",
          "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
          "type_short": "ElfSectionHeader",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSymbolTable",
        "type_short": "ElfSymbolTable",
        "comment": "the symbol table associated to the specified section header"
      },
      "throws": []
    },
    {
      "name": "getRelocationTables",
      "comment": "Returns the relocation tables as defined in this ELF file.",
      "javadoc": "Returns the relocation tables as defined in this ELF file.\n@return the relocation tables as defined in this ELF file",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfRelocationTable[]",
        "type_short": "ghidra.app.util.bin.format.elf.ElfRelocationTable[]",
        "comment": "the relocation tables as defined in this ELF file"
      },
      "throws": []
    },
    {
      "name": "getRelocationTable",
      "comment": "Returns the relocation table associated to the specified section header,\n or null if one does not exist.",
      "javadoc": "Returns the relocation table associated to the specified section header,\n or null if one does not exist.\n@param relocSection section header corresponding to relocation table\n@return the relocation table associated to the specified section header",
      "static": false,
      "params": [
        {
          "name": "relocSection",
          "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
          "type_short": "ElfSectionHeader",
          "comment": "section header corresponding to relocation table"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfRelocationTable",
        "type_short": "ElfRelocationTable",
        "comment": "the relocation table associated to the specified section header"
      },
      "throws": []
    },
    {
      "name": "getRelocationTableAtOffset",
      "comment": "Returns the relocation table located at the specified fileOffset,\n or null if one does not exist.",
      "javadoc": "Returns the relocation table located at the specified fileOffset,\n or null if one does not exist.\n@param fileOffset file offset corresponding to start of relocation table\n@return the relocation table located at the specified fileOffset or null",
      "static": false,
      "params": [
        {
          "name": "fileOffset",
          "type_long": "long",
          "type_short": "long",
          "comment": "file offset corresponding to start of relocation table"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfRelocationTable",
        "type_short": "ElfRelocationTable",
        "comment": "the relocation table located at the specified fileOffset or null"
      },
      "throws": []
    },
    {
      "name": "getMachineName",
      "comment": "Returns a string name of the processor specified in this ELF header.\n For example, if \"e_machine\u003d\u003dEM_386\", then it returns \"80386\".",
      "javadoc": "Returns a string name of the processor specified in this ELF header.\n For example, if \"e_machine\u003d\u003dEM_386\", then it returns \"80386\".\n@return a string name of the processor specified in this ELF header",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "a string name of the processor specified in this ELF header"
      },
      "throws": []
    },
    {
      "name": "getFlags",
      "comment": "Returns a string representation of the numeric flags field.",
      "javadoc": "Returns a string representation of the numeric flags field.\n@return elf flags field value",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "elf flags field value"
      },
      "throws": []
    },
    {
      "name": "toDataType",
      "comment": "",
      "javadoc": "@see ghidra.app.util.bin.StructConverter#toDataType()",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.data.DataType",
        "type_short": "DataType",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getEntryComponentOrdinal",
      "comment": "Get the Elf header structure component ordinal \n corresponding to the e_entry element",
      "javadoc": "Get the Elf header structure component ordinal \n corresponding to the e_entry element\n@return e_entry component ordinal",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "e_entry component ordinal"
      },
      "throws": []
    },
    {
      "name": "getPhoffComponentOrdinal",
      "comment": "Get the Elf header structure component ordinal \n corresponding to the e_phoff element",
      "javadoc": "Get the Elf header structure component ordinal \n corresponding to the e_phoff element\n@return e_phoff component ordinal",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "e_phoff component ordinal"
      },
      "throws": []
    },
    {
      "name": "getShoffComponentOrdinal",
      "comment": "Get the Elf header structure component ordinal \n corresponding to the e_shoff element",
      "javadoc": "Get the Elf header structure component ordinal \n corresponding to the e_shoff element\n@return e_shoff component ordinal",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "e_shoff component ordinal"
      },
      "throws": []
    },
    {
      "name": "addSection",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "newSection",
          "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
          "type_short": "ElfSectionHeader",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "addSection",
      "comment": "Adds a new section using the specified memory block.\n The memory block is used to setting the address and size.\n As well as, setting the data.",
      "javadoc": "Adds a new section using the specified memory block.\n The memory block is used to setting the address and size.\n As well as, setting the data.\n@param block the memory block\n@param sh_name the byte index into the string table where the name begins\n@return the newly created section\n@throws MemoryAccessException if any of the requested memory block bytes are uninitialized.",
      "static": false,
      "params": [
        {
          "name": "block",
          "type_long": "ghidra.program.model.mem.MemoryBlock",
          "type_short": "MemoryBlock",
          "comment": "the memory block"
        },
        {
          "name": "sh_name",
          "type_long": "int",
          "type_short": "int",
          "comment": "the byte index into the string table where the name begins"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
        "type_short": "ElfSectionHeader",
        "comment": "the newly created section"
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if any of the requested memory block bytes are uninitialized."
        }
      ]
    },
    {
      "name": "addSection",
      "comment": "Adds a new section the specifed name and name index.\n The type of the section will be SHT_PROGBITS.",
      "javadoc": "Adds a new section the specifed name and name index.\n The type of the section will be SHT_PROGBITS.\n@param name the actual name of the new section\n@param sh_name the byte index into the string table where the name begins\n@return the newly created section",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the actual name of the new section"
        },
        {
          "name": "sh_name",
          "type_long": "int",
          "type_short": "int",
          "comment": "the byte index into the string table where the name begins"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
        "type_short": "ElfSectionHeader",
        "comment": "the newly created section"
      },
      "throws": []
    },
    {
      "name": "addSection",
      "comment": "Adds a new section the specifed name and name index.\n The type of the section will be SHT_PROGBITS.",
      "javadoc": "Adds a new section the specifed name and name index.\n The type of the section will be SHT_PROGBITS.\n@param name the actual name of the new section\n@param sh_name the byte index into the string table where the name begins\n@param type the type of the new section\n@return the newly created section",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the actual name of the new section"
        },
        {
          "name": "sh_name",
          "type_long": "int",
          "type_short": "int",
          "comment": "the byte index into the string table where the name begins"
        },
        {
          "name": "type",
          "type_long": "int",
          "type_short": "int",
          "comment": "the type of the new section"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.format.elf.ElfSectionHeader",
        "type_short": "ElfSectionHeader",
        "comment": "the newly created section"
      },
      "throws": []
    },
    {
      "name": "addProgramHeader",
      "comment": "Appends the new program header to the end of the existing\n program header table.",
      "javadoc": "Appends the new program header to the end of the existing\n program header table.\n@param ph the new program header",
      "static": false,
      "params": [
        {
          "name": "ph",
          "type_long": "ghidra.app.util.bin.format.elf.ElfProgramHeader",
          "type_short": "ElfProgramHeader",
          "comment": "the new program header"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "write",
      "comment": "",
      "javadoc": "@see ghidra.app.util.bin.format.Writeable#write(java.io.RandomAccessFile, ghidra.util.DataConverter)",
      "static": false,
      "params": [
        {
          "name": "raf",
          "type_long": "java.io.RandomAccessFile",
          "type_short": "RandomAccessFile",
          "comment": ""
        },
        {
          "name": "dc",
          "type_long": "ghidra.util.DataConverter",
          "type_short": "DataConverter",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "setSectionHeaderOffset",
      "comment": "Sets the section header offset.",
      "javadoc": "Sets the section header offset.\n@param offset the new section header offset",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "long",
          "type_short": "long",
          "comment": "the new section header offset"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "setProgramHeaderOffset",
      "comment": "Sets the program header offset.",
      "javadoc": "Sets the program header offset.\n@param offset the new program header offset",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "long",
          "type_short": "long",
          "comment": "the new program header offset"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    }
  ]
}
