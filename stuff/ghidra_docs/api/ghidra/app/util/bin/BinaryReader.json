{
  "name": "BinaryReader",
  "comment": "A class for reading data from a\n generic byte provider in either big-endian or little-endian.",
  "javadoc": "A class for reading data from a\n generic byte provider in either big-endian or little-endian.",
  "static": false,
  "implements": [],
  "extends": "java.lang.Object",
  "fields": [
    {
      "name": "SIZEOF_BYTE",
      "comment": "The size of a BYTE in Java.",
      "javadoc": "The size of a BYTE in Java.",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "1"
    },
    {
      "name": "SIZEOF_SHORT",
      "comment": "The size of a SHORT in Java.",
      "javadoc": "The size of a SHORT in Java.",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "2"
    },
    {
      "name": "SIZEOF_INT",
      "comment": "The size of an INTEGER in Java.",
      "javadoc": "The size of an INTEGER in Java.",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "4"
    },
    {
      "name": "SIZEOF_LONG",
      "comment": "The size of a LONG in Java.",
      "javadoc": "The size of a LONG in Java.",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "8"
    },
    {
      "name": "provider",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.app.util.bin.ByteProvider",
      "type_short": "ByteProvider",
      "constant_value": null
    },
    {
      "name": "converter",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.util.DataConverter",
      "type_short": "DataConverter",
      "constant_value": null
    },
    {
      "name": "currentIndex",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "long",
      "type_short": "long",
      "constant_value": null
    }
  ],
  "methods": [
    {
      "name": "\u003cinit\u003e",
      "comment": "Constructs a reader using the given ByteProvider and endian-order.\n\n If isLittleEndian is true, then all values read\n from the file will be done so assuming\n little-endian order.\n\n Otherwise, if isLittleEndian\n is false, then all values will be read\n assuming big-endian order.",
      "javadoc": "Constructs a reader using the given ByteProvider and endian-order.\n\n If isLittleEndian is true, then all values read\n from the file will be done so assuming\n little-endian order.\n\n Otherwise, if isLittleEndian\n is false, then all values will be read\n assuming big-endian order.\n@param provider the byte provider\n@param isLittleEndian the endian-order",
      "static": false,
      "params": [
        {
          "name": "provider",
          "type_long": "ghidra.app.util.bin.ByteProvider",
          "type_short": "ByteProvider",
          "comment": "the byte provider"
        },
        {
          "name": "isLittleEndian",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "the endian-order"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "\u003cinit\u003e",
      "comment": "Creates a BinaryReader instance.",
      "javadoc": "Creates a BinaryReader instance.\n@param provider the ByteProvider to use\n@param converter the {@link DataConverter} to use\n@param initialIndex the initial offset",
      "static": false,
      "params": [
        {
          "name": "provider",
          "type_long": "ghidra.app.util.bin.ByteProvider",
          "type_short": "ByteProvider",
          "comment": "the ByteProvider to use"
        },
        {
          "name": "converter",
          "type_long": "ghidra.util.DataConverter",
          "type_short": "DataConverter",
          "comment": "the DataConverter to use"
        },
        {
          "name": "initialIndex",
          "type_long": "long",
          "type_short": "long",
          "comment": "the initial offset"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "clone",
      "comment": "Returns a clone of this reader, with its own independent current position,\n positioned at the new index.",
      "javadoc": "Returns a clone of this reader, with its own independent current position,\n positioned at the new index.\n@param newIndex the new index\n@return an independent clone of this reader positioned at the new index",
      "static": false,
      "params": [
        {
          "name": "newIndex",
          "type_long": "long",
          "type_short": "long",
          "comment": "the new index"
        }
      ],
      "return": {
        "type_long": "ghidra.app.util.bin.BinaryReader",
        "type_short": "BinaryReader",
        "comment": "an independent clone of this reader positioned at the new index"
      },
      "throws": []
    },
    {
      "name": "clone",
      "comment": "Returns an independent clone of this reader positioned at the same index.",
      "javadoc": "Returns an independent clone of this reader positioned at the same index.\n@return a independent clone of this reader positioned at the same index",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.BinaryReader",
        "type_short": "BinaryReader",
        "comment": "a independent clone of this reader positioned at the same index"
      },
      "throws": []
    },
    {
      "name": "asBigEndian",
      "comment": "Returns a BinaryReader that is in BigEndian mode.",
      "javadoc": "Returns a BinaryReader that is in BigEndian mode.\n@return a new independent BinaryReader, at the same position, in BigEndian mode",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.BinaryReader",
        "type_short": "BinaryReader",
        "comment": "a new independent BinaryReader, at the same position, in BigEndian mode"
      },
      "throws": []
    },
    {
      "name": "asLittleEndian",
      "comment": "Returns a BinaryReader that is in LittleEndian mode.",
      "javadoc": "Returns a BinaryReader that is in LittleEndian mode.\n@return a new independent instance, at the same position, in LittleEndian mode",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.BinaryReader",
        "type_short": "BinaryReader",
        "comment": "a new independent instance, at the same position, in LittleEndian mode"
      },
      "throws": []
    },
    {
      "name": "isLittleEndian",
      "comment": "Returns true if this reader will extract values in little endian,\n otherwise in big endian.",
      "javadoc": "Returns true if this reader will extract values in little endian,\n otherwise in big endian.\n@return true is little endian, false is big endian",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true is little endian, false is big endian"
      },
      "throws": []
    },
    {
      "name": "isBigEndian",
      "comment": "Returns true if this reader will extract values in big endian.",
      "javadoc": "Returns true if this reader will extract values in big endian.\n@return true is big endian, false is little endian",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true is big endian, false is little endian"
      },
      "throws": []
    },
    {
      "name": "setLittleEndian",
      "comment": "Sets the endian of this binary reader.",
      "javadoc": "Sets the endian of this binary reader.\n@param isLittleEndian true for little-endian and false for big-endian",
      "static": false,
      "params": [
        {
          "name": "isLittleEndian",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true for little-endian and false for big-endian"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "length",
      "comment": "Returns the length of the underlying file.",
      "javadoc": "Returns the length of the underlying file.\n@return returns the length of the underlying file\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "returns the length of the underlying file"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "isValidIndex",
      "comment": "Returns true if the specified index into\n the underlying byte provider is valid.",
      "javadoc": "Returns true if the specified index into\n the underlying byte provider is valid.\n@param index the index in the byte provider\n@return returns true if the specified index is valid\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "int",
          "type_short": "int",
          "comment": "the index in the byte provider"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "returns true if the specified index is valid"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "isValidIndex",
      "comment": "Returns true if the specified index into\n the underlying byte provider is valid.",
      "javadoc": "Returns true if the specified index into\n the underlying byte provider is valid.\n@param index the index in the byte provider\n@return returns true if the specified index is valid\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index in the byte provider"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "returns true if the specified index is valid"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "align",
      "comment": "Aligns the current index on the specified alignment value.\n For example, if current index was 123 and align value was\n 16, then current index would become 128.",
      "javadoc": "Aligns the current index on the specified alignment value.\n For example, if current index was 123 and align value was\n 16, then current index would become 128.\n@param alignValue\n@return the number of bytes required to align",
      "static": false,
      "params": [
        {
          "name": "alignValue",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of bytes required to align"
      },
      "throws": []
    },
    {
      "name": "setPointerIndex",
      "comment": "A convenience method for setting the index using a 32 bit integer.",
      "javadoc": "A convenience method for setting the index using a 32 bit integer.\n@param index new index, treated as a 32 bit unsigned integer",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "int",
          "type_short": "int",
          "comment": "new index, treated as a 32 bit unsigned integer"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "setPointerIndex",
      "comment": "Sets the current index to the specified value.\n The pointer index will allow the reader\n to operate as a psuedo-iterator.",
      "javadoc": "Sets the current index to the specified value.\n The pointer index will allow the reader\n to operate as a psuedo-iterator.\n@param index the byte provider index value",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the byte provider index value"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getPointerIndex",
      "comment": "Returns the current index value.",
      "javadoc": "Returns the current index value.\n@return the current index value",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the current index value"
      },
      "throws": []
    },
    {
      "name": "peekNextByte",
      "comment": "Peeks at the next byte without incrementing\n the current index.",
      "javadoc": "Peeks at the next byte without incrementing\n the current index.\n@return the next byte\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "byte",
        "type_short": "byte",
        "comment": "the next byte"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "peekNextShort",
      "comment": "Peeks at the next short without incrementing\n the current index.",
      "javadoc": "Peeks at the next short without incrementing\n the current index.\n@return the next short\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "short",
        "type_short": "short",
        "comment": "the next short"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "peekNextInt",
      "comment": "Peeks at the next integer without incrementing\n the current index.",
      "javadoc": "Peeks at the next integer without incrementing\n the current index.\n@return the next int\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the next int"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "peekNextLong",
      "comment": "Peeks at the next long without incrementing\n the current index.",
      "javadoc": "Peeks at the next long without incrementing\n the current index.\n@return the next long\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the next long"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextByte",
      "comment": "Reads the byte at the current index and then increments the current\n index by SIZEOF_BYTE.",
      "javadoc": "Reads the byte at the current index and then increments the current\n index by \u003ccode\u003eSIZEOF_BYTE\u003c/code\u003e.\n@return the byte at the current index\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "byte",
        "type_short": "byte",
        "comment": "the byte at the current index"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextUnsignedByte",
      "comment": "Reads the unsigned byte at the current index and then increments the current\n index by SIZEOF_BYTE.",
      "javadoc": "Reads the unsigned byte at the current index and then increments the current\n index by \u003ccode\u003eSIZEOF_BYTE\u003c/code\u003e.\n@return the unsigned byte at the current index, as an int\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the unsigned byte at the current index, as an int"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextShort",
      "comment": "Reads the short at the current index and then increments the current\n index by SIZEOF_SHORT.",
      "javadoc": "Reads the short at the current index and then increments the current\n index by \u003ccode\u003eSIZEOF_SHORT\u003c/code\u003e.\n@return the short at the current index\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "short",
        "type_short": "short",
        "comment": "the short at the current index"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextUnsignedShort",
      "comment": "Reads the unsigned short at the current index and then increments the current\n index by SIZEOF_SHORT.",
      "javadoc": "Reads the unsigned short at the current index and then increments the current\n index by \u003ccode\u003eSIZEOF_SHORT\u003c/code\u003e.\n@return the unsigned short at the current index, as an int\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the unsigned short at the current index, as an int"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextInt",
      "comment": "Reads the integer at the current index and then increments the current\n index by SIZEOF_INT.",
      "javadoc": "Reads the integer at the current index and then increments the current\n index by \u003ccode\u003eSIZEOF_INT\u003c/code\u003e.\n@return the integer at the current index\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the integer at the current index"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextUnsignedInt",
      "comment": "Reads the unsigned integer at the current index and then increments the current\n index by SIZEOF_INT.",
      "javadoc": "Reads the unsigned integer at the current index and then increments the current\n index by \u003ccode\u003eSIZEOF_INT\u003c/code\u003e.\n@return the unsigned integer at the current index, as a long\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the unsigned integer at the current index, as a long"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextLong",
      "comment": "Reads the long at the current index and then increments the current\n index by SIZEOF_LONG.",
      "javadoc": "Reads the long at the current index and then increments the current\n index by \u003ccode\u003eSIZEOF_LONG\u003c/code\u003e.\n@return the long at the current index\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the long at the current index"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextAsciiString",
      "comment": "Reads the Ascii string at the current index and then increments the current\n index by the length of the Ascii string that was found. This method\n expects the string to be null-terminated.",
      "javadoc": "Reads the Ascii string at the current index and then increments the current\n index by the length of the Ascii string that was found. This method\n expects the string to be null-terminated.\n@return the null-terminated Ascii string at the current index\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the null-terminated Ascii string at the current index"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextNullTerminatedAsciiString",
      "comment": "Reads a null terminated Ascii string starting at the current index,\n ending at the first null character or when reaching the\n end of the underlying ByteProvider.\n \n The current index is advanced to the next byte after the null terminator.\n ",
      "javadoc": "Reads a null terminated Ascii string starting at the current index,\n ending at the first null character or when reaching the\n end of the underlying ByteProvider.\n \u003cp\u003e\n The current index is advanced to the next byte after the null terminator.\n \u003cp\u003e\n@return the null-terminated Ascii string at the current index\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the null-terminated Ascii string at the current index"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextAsciiString",
      "comment": "Reads an Ascii string of length\n characters starting at the current index and then increments the current\n index by length.",
      "javadoc": "Reads an Ascii string of \u003ccode\u003elength\u003c/code\u003e\n characters starting at the current index and then increments the current\n index by \u003ccode\u003elength\u003c/code\u003e.\n@return the Ascii string at the current index",
      "static": false,
      "params": [
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the Ascii string at the current index"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextUnicodeString",
      "comment": "Reads the Unicode string at the current index and then increments the current\n index by the length of the Unicode string that was found. This method\n expects the string to be double null-terminated (\u0027\\0\\0\u0027).",
      "javadoc": "Reads the Unicode string at the current index and then increments the current\n index by the length of the Unicode string that was found. This method\n expects the string to be double null-terminated (\u0027\\0\\0\u0027).\n@return the null-terminated Ascii string at the current index\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the null-terminated Ascii string at the current index"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextUnicodeString",
      "comment": "Reads fixed length UTF-16 Unicode string the current index and then increments the current\n #setPointerIndex(int) by length elements (length*2 bytes).",
      "javadoc": "Reads fixed length UTF-16 Unicode string the current index and then increments the current\n {@link #setPointerIndex(int) pointer index} by \u003ccode\u003elength\u003c/code\u003e elements (length*2 bytes).\n@return the UTF-16 Unicode string at the current index\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the UTF-16 Unicode string at the current index"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextByteArray",
      "comment": "Reads a byte array of nElements\n starting at the current index and then increments the current\n index by SIZEOF_BYTE * nElements.",
      "javadoc": "Reads a byte array of \u003ccode\u003enElements\u003c/code\u003e\n starting at the current index and then increments the current\n index by \u003ccode\u003eSIZEOF_BYTE * nElements\u003c/code\u003e.\n@return the byte array starting at the current index\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "nElements",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": "the byte array starting at the current index"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextShortArray",
      "comment": "Reads a short array of nElements\n starting at the current index and then increments the current\n index by SIZEOF_SHORT * nElements.",
      "javadoc": "Reads a short array of \u003ccode\u003enElements\u003c/code\u003e\n starting at the current index and then increments the current\n index by \u003ccode\u003eSIZEOF_SHORT * nElements\u003c/code\u003e.\n@return the short array starting at the current index\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "nElements",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "short[]",
        "type_short": "short[]",
        "comment": "the short array starting at the current index"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextIntArray",
      "comment": "Reads an integer array of nElements\n starting at the current index and then increments the current\n index by SIZEOF_INT * nElements.",
      "javadoc": "Reads an integer array of \u003ccode\u003enElements\u003c/code\u003e\n starting at the current index and then increments the current\n index by \u003ccode\u003eSIZEOF_INT * nElements\u003c/code\u003e.\n@return the integer array starting at the current index\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "nElements",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "int[]",
        "type_short": "int[]",
        "comment": "the integer array starting at the current index"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readNextLongArray",
      "comment": "Reads a long array of nElements\n starting at the current index and then increments the current\n index by SIZEOF_LONG * nElements.",
      "javadoc": "Reads a long array of \u003ccode\u003enElements\u003c/code\u003e\n starting at the current index and then increments the current\n index by \u003ccode\u003eSIZEOF_LONG * nElements\u003c/code\u003e.\n@return the long array starting at the current index\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "nElements",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "long[]",
        "type_short": "long[]",
        "comment": "the long array starting at the current index"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readAsciiString",
      "comment": "Reads an Ascii string starting at index, ending\n at the next character outside the range [32..126] or when\n reaching the end of the underlying ByteProvider.\n \n Leading and trailing spaces will be trimmed before the string is returned.",
      "javadoc": "Reads an Ascii string starting at \u003ccode\u003eindex\u003c/code\u003e, ending\n at the next character outside the range [32..126] or when\n reaching the end of the underlying ByteProvider.\n \u003cp\u003e\n Leading and trailing spaces will be trimmed before the string is returned.\n@param index the index where the Ascii string begins\n@return the trimmed Ascii string\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the Ascii string begins"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the trimmed Ascii string"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readAsciiString",
      "comment": "Returns an Ascii string of length bytes\n starting at index. This method does not\n care about null-terminators.  Leading and trailing spaces\n will be trimmed before the string is returned.",
      "javadoc": "Returns an Ascii string of \u003ccode\u003elength\u003c/code\u003e bytes\n starting at \u003ccode\u003eindex\u003c/code\u003e. This method does not\n care about null-terminators.  Leading and trailing spaces\n will be trimmed before the string is returned.\n@param index the index where the Ascii string begins\n@param length the length of the Ascii string\n@return the trimmed Ascii string\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the Ascii string begins"
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "the length of the Ascii string"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the trimmed Ascii string"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readTerminatedString",
      "comment": "Reads an Ascii string starting at index, ending\n at the next  character byte or when  reaching the end of\n the underlying ByteProvider.\n \n Does NOT trim the string.\n ",
      "javadoc": "Reads an Ascii string starting at \u003ccode\u003eindex\u003c/code\u003e, ending\n at the next {@code termChar} character byte or when  reaching the end of\n the underlying ByteProvider.\n \u003cp\u003e\n Does NOT trim the string.\n \u003cp\u003e\n@param index the index where the Ascii string begins\n@return the Ascii string (excluding the terminating character)\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the Ascii string begins"
        },
        {
          "name": "termChar",
          "type_long": "char",
          "type_short": "char",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the Ascii string (excluding the terminating character)"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readTerminatedString",
      "comment": "Reads an Ascii string starting at index, ending\n at the next character that is one of the specified  or when\n reaching the end of the underlying ByteProvider.\n \n Does NOT trim the string.\n ",
      "javadoc": "Reads an Ascii string starting at \u003ccode\u003eindex\u003c/code\u003e, ending\n at the next character that is one of the specified {@code termChars} or when\n reaching the end of the underlying ByteProvider.\n \u003cp\u003e\n Does NOT trim the string.\n \u003cp\u003e\n@param index the index where the Ascii string begins\n@return the Ascii string (excluding the terminating character)\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the Ascii string begins"
        },
        {
          "name": "termChars",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the Ascii string (excluding the terminating character)"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readFixedLenAsciiString",
      "comment": "Reads an fixed length Ascii string starting at index.\n \n Does NOT trim the string.\n ",
      "javadoc": "Reads an fixed length Ascii string starting at \u003ccode\u003eindex\u003c/code\u003e.\n \u003cp\u003e\n Does NOT trim the string.\n \u003cp\u003e\n@param index the index where the Ascii string begins\n@param len number of bytes to read\n@return the Ascii string\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the Ascii string begins"
        },
        {
          "name": "len",
          "type_long": "int",
          "type_short": "int",
          "comment": "number of bytes to read"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the Ascii string"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readUnicodeString",
      "comment": "Reads a null-terminated UTF-16 Unicode string starting\n at index using the pre-specified\n #setLittleEndian(boolean).\n \n The end of the string is denoted by a two-byte (ie. short) null character.\n \n Leading and trailing spaces will be trimmed before the string is returned.\n ",
      "javadoc": "Reads a null-terminated UTF-16 Unicode string starting\n at \u003ccode\u003eindex\u003c/code\u003e using the pre-specified\n {@link #setLittleEndian(boolean) endianness}.\n \u003cp\u003e\n The end of the string is denoted by a two-byte (ie. short) \u003ccode\u003enull\u003c/code\u003e character.\n \u003cp\u003e\n Leading and trailing spaces will be trimmed before the string is returned.\n \u003cp\u003e\n@param index the index where the UTF-16 Unicode string begins\n@return the trimmed UTF-16 Unicode string\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the UTF-16 Unicode string begins"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the trimmed UTF-16 Unicode string"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readUnicodeString",
      "comment": "Reads a fixed length UTF-16 Unicode string of length characters\n starting at index, using the pre-specified\n #setLittleEndian(boolean).\n \n This method does not care about null-terminators.\n \n Leading and trailing spaces will be trimmed before the string is returned.\n ",
      "javadoc": "Reads a fixed length UTF-16 Unicode string of \u003ccode\u003elength\u003c/code\u003e characters\n starting at \u003ccode\u003eindex\u003c/code\u003e, using the pre-specified\n {@link #setLittleEndian(boolean) endianness}.\n \u003cp\u003e\n This method does not care about null-terminators.\n \u003cp\u003e\n Leading and trailing spaces will be trimmed before the string is returned.\n \u003cp\u003e\n@param index the index where the UTF-16 Unicode string begins\n@param length the number of UTF-16 character elements to read.\n@return the trimmed UTF-16 Unicode string\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the UTF-16 Unicode string begins"
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of UTF-16 character elements to read."
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the trimmed UTF-16 Unicode string"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readByte",
      "comment": "Returns the signed BYTE at index.",
      "javadoc": "Returns the signed BYTE at \u003ccode\u003eindex\u003c/code\u003e.\n@param index the index where the BYTE begins\n@return the signed BYTE\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the BYTE begins"
        }
      ],
      "return": {
        "type_long": "byte",
        "type_short": "byte",
        "comment": "the signed BYTE"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readUnsignedByte",
      "comment": "Returns the unsigned BYTE at index.",
      "javadoc": "Returns the unsigned BYTE at \u003ccode\u003eindex\u003c/code\u003e.\n@param index the index where the BYTE begins\n@return the unsigned BYTE as an int\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the BYTE begins"
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the unsigned BYTE as an int"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readShort",
      "comment": "Returns the signed SHORT at index.",
      "javadoc": "Returns the signed SHORT at \u003ccode\u003eindex\u003c/code\u003e.\n@param index the index where the SHORT begins\n@return the signed SHORT\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the SHORT begins"
        }
      ],
      "return": {
        "type_long": "short",
        "type_short": "short",
        "comment": "the signed SHORT"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readUnsignedShort",
      "comment": "Returns the unsigned SHORT at index.",
      "javadoc": "Returns the unsigned SHORT at \u003ccode\u003eindex\u003c/code\u003e.\n@param index the index where the SHORT begins\n@return the unsigned SHORT as an int\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the SHORT begins"
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the unsigned SHORT as an int"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readInt",
      "comment": "Returns the signed INTEGER at index.",
      "javadoc": "Returns the signed INTEGER at \u003ccode\u003eindex\u003c/code\u003e.\n@param index the index where the INTEGER begins\n@return the signed INTEGER\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the INTEGER begins"
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the signed INTEGER"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readUnsignedInt",
      "comment": "Returns the unsigned INTEGER at index.",
      "javadoc": "Returns the unsigned INTEGER at \u003ccode\u003eindex\u003c/code\u003e.\n@param index the index where the INTEGER begins\n@return the unsigned INTEGER as a long\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the INTEGER begins"
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the unsigned INTEGER as a long"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readLong",
      "comment": "Returns the signed LONG at index.",
      "javadoc": "Returns the signed LONG at \u003ccode\u003eindex\u003c/code\u003e.\n@param index the index where the LONG begins\n@return the LONG\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the LONG begins"
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the LONG"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readValue",
      "comment": "Returns the signed value of the integer (of the specified length) at the specified offset.",
      "javadoc": "Returns the signed value of the integer (of the specified length) at the specified offset.\n@param index offset the offset from the membuffers origin (the address that it is set at)\n@param len the number of bytes that the integer occupies.  Valid values are 1 (byte), 2 (short),\n 4 (int), 8 (long)\n@return value of requested length, with sign bit extended, in a long\n@throws IOException",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "offset the offset from the membuffers origin (the address that it is set at)"
        },
        {
          "name": "len",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of bytes that the integer occupies.  Valid values are 1 (byte), 2 (short),\n 4 (int), 8 (long)"
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "value of requested length, with sign bit extended, in a long"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readUnsignedValue",
      "comment": "Returns the unsigned value of the integer (of the specified length) at the specified offset.",
      "javadoc": "Returns the unsigned value of the integer (of the specified length) at the specified offset.\n@param index offset the offset from the membuffers origin (the address that it is set at)\n@param len the number of bytes that the integer occupies.  Valid values are 1 (byte), 2 (short),\n 4 (int), 8 (long)\n@return unsigned value of requested length, in a long\n@throws IOException",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "offset the offset from the membuffers origin (the address that it is set at)"
        },
        {
          "name": "len",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of bytes that the integer occupies.  Valid values are 1 (byte), 2 (short),\n 4 (int), 8 (long)"
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "unsigned value of requested length, in a long"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readByteArray",
      "comment": "Returns the BYTE array of nElements\n starting at index.",
      "javadoc": "Returns the BYTE array of \u003ccode\u003enElements\u003c/code\u003e\n starting at \u003ccode\u003eindex\u003c/code\u003e.\n@param index the index where the BYTE begins\n@param nElements the number of array elements\n@return the BYTE array\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the BYTE begins"
        },
        {
          "name": "nElements",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of array elements"
        }
      ],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": "the BYTE array"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readShortArray",
      "comment": "Returns the SHORT array of nElements\n starting at index.",
      "javadoc": "Returns the SHORT array of \u003ccode\u003enElements\u003c/code\u003e\n starting at \u003ccode\u003eindex\u003c/code\u003e.\n@param index the index where the SHORT begins\n@param nElements the number of array elements\n@return the SHORT array\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the SHORT begins"
        },
        {
          "name": "nElements",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of array elements"
        }
      ],
      "return": {
        "type_long": "short[]",
        "type_short": "short[]",
        "comment": "the SHORT array"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readIntArray",
      "comment": "Returns the INTEGER array of nElements\n starting at index.",
      "javadoc": "Returns the INTEGER array of \u003ccode\u003enElements\u003c/code\u003e\n starting at \u003ccode\u003eindex\u003c/code\u003e.\n@param index the index where the INTEGER begins\n@param nElements the number of array elements\n@return the INTEGER array\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the INTEGER begins"
        },
        {
          "name": "nElements",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of array elements"
        }
      ],
      "return": {
        "type_long": "int[]",
        "type_short": "int[]",
        "comment": "the INTEGER array"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readLongArray",
      "comment": "Returns the LONG array of nElements\n starting at index.",
      "javadoc": "Returns the LONG array of \u003ccode\u003enElements\u003c/code\u003e\n starting at \u003ccode\u003eindex\u003c/code\u003e.\n@param index the index where the LONG begins\n@param nElements the number of array elements\n@return the LONG array\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the LONG begins"
        },
        {
          "name": "nElements",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of array elements"
        }
      ],
      "return": {
        "type_long": "long[]",
        "type_short": "long[]",
        "comment": "the LONG array"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "readAsciiStringArray",
      "comment": "Returns the Ascii string array of nElements\n starting at index",
      "javadoc": "Returns the Ascii string array of \u003ccode\u003enElements\u003c/code\u003e\n starting at \u003ccode\u003eindex\u003c/code\u003e\n@param index the index where the Ascii Strings begin\n@param nElements the number of array elements\n@return the Ascii String array\n@exception IOException if an I/O error occurs",
      "static": false,
      "params": [
        {
          "name": "index",
          "type_long": "long",
          "type_short": "long",
          "comment": "the index where the Ascii Strings begin"
        },
        {
          "name": "nElements",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of array elements"
        }
      ],
      "return": {
        "type_long": "java.lang.String[]",
        "type_short": "java.lang.String[]",
        "comment": "the Ascii String array"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "getByteProvider",
      "comment": "Returns the underlying byte provider.",
      "javadoc": "Returns the underlying byte provider.\n@return the underlying byte provider",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.util.bin.ByteProvider",
        "type_short": "ByteProvider",
        "comment": "the underlying byte provider"
      },
      "throws": []
    }
  ]
}
