{
  "name": "MaskedLong",
  "comment": "A -bit value where each bit is , , or  (undefined)",
  "javadoc": "A {@code 64}-bit value where each bit is {@code 0}, {@code 1}, or {@code x} (undefined)",
  "static": false,
  "implements": [
    "java.lang.Comparable"
  ],
  "extends": "java.lang.Object",
  "fields": [
    {
      "name": "ZERO",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
      "type_short": "MaskedLong",
      "constant_value": null
    },
    {
      "name": "UNKS",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
      "type_short": "MaskedLong",
      "constant_value": null
    },
    {
      "name": "ONES",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
      "type_short": "MaskedLong",
      "constant_value": null
    },
    {
      "name": "msk",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "long",
      "type_short": "long",
      "constant_value": null
    },
    {
      "name": "val",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "long",
      "type_short": "long",
      "constant_value": null
    }
  ],
  "methods": [
    {
      "name": "\u003cinit\u003e",
      "comment": "Create a masked long given a mask and value",
      "javadoc": "Create a masked long given a mask and value",
      "static": false,
      "params": [
        {
          "name": "msk",
          "type_long": "long",
          "type_short": "long",
          "comment": ""
        },
        {
          "name": "val",
          "type_long": "long",
          "type_short": "long",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "fromMaskAndValue",
      "comment": "Create a masked value from a mask and a long\n \n Any positions in  set to 0 create an  in the corresponding position of\n the result. Otherwise, the position takes the corresponding bit from .",
      "javadoc": "Create a masked value from a mask and a long\n \n Any positions in {@code msk} set to 0 create an {@code x} in the corresponding position of\n the result. Otherwise, the position takes the corresponding bit from {@code val}.\n@param msk the mask\n@param val the value\n@return the constructed masked long",
      "static": true,
      "params": [
        {
          "name": "msk",
          "type_long": "long",
          "type_short": "long",
          "comment": "the mask"
        },
        {
          "name": "val",
          "type_long": "long",
          "type_short": "long",
          "comment": "the value"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the constructed masked long"
      },
      "throws": []
    },
    {
      "name": "fromLong",
      "comment": "Create a fully-defined value from the bits of a long",
      "javadoc": "Create a fully-defined value from the bits of a long\n@param val the value to take\n@return the constructed masked long",
      "static": true,
      "params": [
        {
          "name": "val",
          "type_long": "long",
          "type_short": "long",
          "comment": "the value to take"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the constructed masked long"
      },
      "throws": []
    },
    {
      "name": "longValue",
      "comment": "Obtain the value as a long, where all undefined bits are treated as ",
      "javadoc": "Obtain the value as a long, where all undefined bits are treated as {@code 0}\n@return the value as a long",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the value as a long"
      },
      "throws": []
    },
    {
      "name": "getMask",
      "comment": "Get the mask as a long\n \n Positions with a defined bit are ; positions with an undefined bit are .",
      "javadoc": "Get the mask as a long\n \n Positions with a defined bit are {@code 1}; positions with an undefined bit are {@code 0}.\n@return the mask as a long",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the mask as a long"
      },
      "throws": []
    },
    {
      "name": "isFullyDefined",
      "comment": "True iff there are no undefined bits",
      "javadoc": "True iff there are no undefined bits\n@return true if fully-defined, false otherwise",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if fully-defined, false otherwise"
      },
      "throws": []
    },
    {
      "name": "isFullyUndefined",
      "comment": "True iff there are no defined bits",
      "javadoc": "True iff there are no defined bits\n@return true if full-undefined, false otherwise",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if full-undefined, false otherwise"
      },
      "throws": []
    },
    {
      "name": "mask",
      "comment": "Apply an additional mask to this masked long\n \n Any  bit in  will result in an undefined bit in the result. \n bits result in a copy of the corresponding bit in the result.",
      "javadoc": "Apply an additional mask to this masked long\n \n Any {@code 0} bit in {@code msk} will result in an undefined bit in the result. {@code 1}\n bits result in a copy of the corresponding bit in the result.\n@param mask the mask to apply\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "mask",
          "type_long": "long",
          "type_short": "long",
          "comment": "the mask to apply"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "signExtend",
      "comment": "Sign extend the masked value, according to its mask, to a full long\n \n The leftmost defined bit is taken as the sign bit, and extended to the left.",
      "javadoc": "Sign extend the masked value, according to its mask, to a full long\n \n The leftmost defined bit is taken as the sign bit, and extended to the left.\n@return the sign-extended masked long",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the sign-extended masked long"
      },
      "throws": []
    },
    {
      "name": "zeroExtend",
      "comment": "Zero extend the masked value, according to its mask, to a full long\n \n All bits to the left of the leftmost defined bit are set to 0.",
      "javadoc": "Zero extend the masked value, according to its mask, to a full long\n \n All bits to the left of the leftmost defined bit are set to 0.\n@return the zero-extended masked long",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the zero-extended masked long"
      },
      "throws": []
    },
    {
      "name": "unknownExtend",
      "comment": "Mask out all but the lowest  bits of the value",
      "javadoc": "Mask out all but the lowest {@code n} bits of the value\n@param n the number of bits to take (right-to-left)\n@return the unknown-extended masked long",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of bits to take (right-to-left)"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the unknown-extended masked long"
      },
      "throws": []
    },
    {
      "name": "signExtend",
      "comment": "Sign extend the masked value as if of the given size in bits, to a full long",
      "javadoc": "Sign extend the masked value as if of the given size in bits, to a full long\n@param n the number of bits to take (right-to-left)\n@return the sign-extended masked long",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of bits to take (right-to-left)"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the sign-extended masked long"
      },
      "throws": []
    },
    {
      "name": "zeroExtend",
      "comment": "Zero extend the masked value as if of the given size in bits, to a full long",
      "javadoc": "Zero extend the masked value as if of the given size in bits, to a full long\n@param n the number of bits to take (right-to-left)\n@return the zero-extended masked long",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of bits to take (right-to-left)"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the zero-extended masked long"
      },
      "throws": []
    },
    {
      "name": "combine",
      "comment": "Combine this and another masked long into one, by taking defined bits from either\n \n If this masked long agrees with the other, then the two are combined. For each bit position\n in the result, the defined bit from either corresponding position is taken. If neither is\n defined, then the position is undefined in the result. If both are defined, they must agree.",
      "javadoc": "Combine this and another masked long into one, by taking defined bits from either\n \n If this masked long agrees with the other, then the two are combined. For each bit position\n in the result, the defined bit from either corresponding position is taken. If neither is\n defined, then the position is undefined in the result. If both are defined, they must agree.\n@param that the other masked long\n@return the combined masked long\n@throws SolverException if this and the other masked long disagree",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the other masked long"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the combined masked long"
      },
      "throws": [
        {
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.SolverException",
          "type_short": "SolverException",
          "comment": "if this and the other masked long disagree"
        }
      ]
    },
    {
      "name": "shiftCircular",
      "comment": "Shift  bits @{code n) positions circularly in a given direction\n\n The shifted bits are the least significant  bits. The remaining bits are\n unaffected.",
      "javadoc": "Shift {@code size} bits @{code n) positions circularly in a given direction\n\n The shifted bits are the least significant {@code size} bits. The remaining bits are\n unaffected.\n@param n the number of positions\n@param size the number of bits (least significant) to include in the shift\n@param dir the direction to shift (0 for left, 1 for right)\n@return the result",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "long",
          "type_short": "long",
          "comment": "the number of positions"
        },
        {
          "name": "size",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of bits (least significant) to include in the shift"
        },
        {
          "name": "dir",
          "type_long": "int",
          "type_short": "int",
          "comment": "the direction to shift (0 for left, 1 for right)"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result"
      },
      "throws": []
    },
    {
      "name": "shiftCircular",
      "comment": "Shift  bits @{code n) positions circularly in a given direction\n\n The shifted bits are the least significant  bits. The remaining bits are\n unaffected.",
      "javadoc": "Shift {@code size} bits @{code n) positions circularly in a given direction\n\n The shifted bits are the least significant {@code size} bits. The remaining bits are\n unaffected.\n@param n the number of positions\n@param size the number of bits (least significant) to include in the shift\n@param dir the direction to shift (0 for left, 1 for right)\n@return the result",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the number of positions"
        },
        {
          "name": "size",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of bits (least significant) to include in the shift"
        },
        {
          "name": "dir",
          "type_long": "int",
          "type_short": "int",
          "comment": "the direction to shift (0 for left, 1 for right)"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result"
      },
      "throws": []
    },
    {
      "name": "shiftLeft",
      "comment": "Shift the bits @{code n} positions left\n \n This implements both a signed and unsigned shift.",
      "javadoc": "Shift the bits @{code n} positions left\n \n This implements both a signed and unsigned shift.\n@param n the number of positions.\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "long",
          "type_short": "long",
          "comment": "the number of positions."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "shiftLeft",
      "comment": "Shift the bits  positions left\n \n This implements both a signed and unsigned shift.",
      "javadoc": "Shift the bits {@code n} positions left\n \n This implements both a signed and unsigned shift.\n@param n the number of positions.\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the number of positions."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "invShiftLeft",
      "comment": "Invert a left shift of  positions, that is shift right\n \n This is different from a normal shift right, in that it inserts unknowns at the left. The\n normal right shift inserts zeros or sign bits. Additionally, if any ones would fall off the\n right, the inversion is undefined.",
      "javadoc": "Invert a left shift of {@code n} positions, that is shift right\n \n This is different from a normal shift right, in that it inserts unknowns at the left. The\n normal right shift inserts zeros or sign bits. Additionally, if any ones would fall off the\n right, the inversion is undefined.\n@param n the number of positions\n@return the result\n@throws SolverException if the inversion is undefined",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "long",
          "type_short": "long",
          "comment": "the number of positions"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result"
      },
      "throws": [
        {
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.SolverException",
          "type_short": "SolverException",
          "comment": "if the inversion is undefined"
        }
      ]
    },
    {
      "name": "invShiftLeft",
      "comment": "Invert a left shift of  positions, that is shift right\n \n This is different from a normal shift right, in that it inserts unknowns at the left. The\n normal right shift inserts zeros or sign bits. Additionally, if any ones would fall off the\n right, the inversion is undefined.",
      "javadoc": "Invert a left shift of {@code n} positions, that is shift right\n \n This is different from a normal shift right, in that it inserts unknowns at the left. The\n normal right shift inserts zeros or sign bits. Additionally, if any ones would fall off the\n right, the inversion is undefined.\n@param n the number of positions\n@return the result\n@throws SolverException if the inversion is undefined",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the number of positions"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result"
      },
      "throws": [
        {
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.SolverException",
          "type_short": "SolverException",
          "comment": "if the inversion is undefined"
        }
      ]
    },
    {
      "name": "shiftRight",
      "comment": "Shift the bits arithmetically  positions right\n \n This implements a signed shift.",
      "javadoc": "Shift the bits arithmetically {@code n} positions right\n \n This implements a signed shift.\n@param n the number of positions.\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "long",
          "type_short": "long",
          "comment": "the number of positions."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "shiftRight",
      "comment": "Shift the bits arithmetically  positions right\n \n This implements a signed shift.",
      "javadoc": "Shift the bits arithmetically {@code n} positions right\n \n This implements a signed shift.\n@param n the number of positions.\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the number of positions."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "invShiftRight",
      "comment": "Invert an arithmetic right shift of  positions, that is shift left\n \n This is different from a normal shift left, in that it inserts unknowns at the right. The\n normal left shift inserts zeros. Additionally, all bits that fall off the left must match the\n resulting sign bit, or else the inversion is undefined.",
      "javadoc": "Invert an arithmetic right shift of {@code n} positions, that is shift left\n \n This is different from a normal shift left, in that it inserts unknowns at the right. The\n normal left shift inserts zeros. Additionally, all bits that fall off the left must match the\n resulting sign bit, or else the inversion is undefined.\n@param n the number of positions\n@return the result\n@throws SolverException if the inversion is undefined",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "long",
          "type_short": "long",
          "comment": "the number of positions"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result"
      },
      "throws": [
        {
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.SolverException",
          "type_short": "SolverException",
          "comment": "if the inversion is undefined"
        }
      ]
    },
    {
      "name": "invShiftRight",
      "comment": "Invert an arithmetic right shift of  positions, that is shift left\n \n This is different from a normal shift left, in that it inserts unknowns at the right. The\n normal left shift inserts zeros. Additionally, all bits that fall off the left must match the\n resulting sign bit, or else the inversion is undefined.",
      "javadoc": "Invert an arithmetic right shift of {@code n} positions, that is shift left\n \n This is different from a normal shift left, in that it inserts unknowns at the right. The\n normal left shift inserts zeros. Additionally, all bits that fall off the left must match the\n resulting sign bit, or else the inversion is undefined.\n@param n the number of positions\n@return the result\n@throws SolverException if the inversion is undefined",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the number of positions"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result"
      },
      "throws": [
        {
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.SolverException",
          "type_short": "SolverException",
          "comment": "if the inversion is undefined"
        }
      ]
    },
    {
      "name": "shiftRightLogical",
      "comment": "Shift the bits logically  positions right\n \n This implements an unsigned shift.",
      "javadoc": "Shift the bits logically {@code n} positions right\n \n This implements an unsigned shift.\n@param n the number of positions.\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "long",
          "type_short": "long",
          "comment": "the number of positions."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "shiftRightLogical",
      "comment": "Shift the bits logically  positions right\n \n This implements an unsigned shift.",
      "javadoc": "Shift the bits logically {@code n} positions right\n \n This implements an unsigned shift.\n@param n the number of positions.\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the number of positions."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "shiftRightPositional",
      "comment": "Shift the bits positionally  positions right\n \n This fills the left with unknown bits",
      "javadoc": "Shift the bits positionally {@code n} positions right\n \n This fills the left with unknown bits\n@param n\n@return ",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "long",
          "type_short": "long",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "invShiftRightLogical",
      "comment": "Invert a logical right shift of  positions, that is shift left\n \n This is different from a normal shift left, in that it inserts unknowns at the right. The\n normal left shift inserts zeros. Additionally, if any ones would fall off the left, the\n inversion is undefined.",
      "javadoc": "Invert a logical right shift of {@code n} positions, that is shift left\n \n This is different from a normal shift left, in that it inserts unknowns at the right. The\n normal left shift inserts zeros. Additionally, if any ones would fall off the left, the\n inversion is undefined.\n@param n the number of positions\n@return the result\n@throws SolverException if the inversion is undefined",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "long",
          "type_short": "long",
          "comment": "the number of positions"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result"
      },
      "throws": [
        {
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.SolverException",
          "type_short": "SolverException",
          "comment": "if the inversion is undefined"
        }
      ]
    },
    {
      "name": "invShiftRightLogical",
      "comment": "Invert a logical right shift of  positions, that is shift left\n \n This is different from a normal shift left, in that it inserts unknowns at the right. The\n normal left shift inserts zeros. Additionally, if any ones would fall off the left, the\n inversion is undefined.",
      "javadoc": "Invert a logical right shift of {@code n} positions, that is shift left\n \n This is different from a normal shift left, in that it inserts unknowns at the right. The\n normal left shift inserts zeros. Additionally, if any ones would fall off the left, the\n inversion is undefined.\n@param n the number of positions\n@return the result\n@throws SolverException if the inversion is undefined",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the number of positions"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result"
      },
      "throws": [
        {
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.SolverException",
          "type_short": "SolverException",
          "comment": "if the inversion is undefined"
        }
      ]
    },
    {
      "name": "byteSwap",
      "comment": "Reverse the least significant  bytes\n \n This interprets the bits as an -byte value and changes the endianness. Any bits\n outside of the interpretation are truncated, i.e., become unknown.",
      "javadoc": "Reverse the least significant {@code n} bytes\n \n This interprets the bits as an {@code n}-byte value and changes the endianness. Any bits\n outside of the interpretation are truncated, i.e., become unknown.\n@param n the size, in bytes, of the interpreted value.\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "n",
          "type_long": "int",
          "type_short": "int",
          "comment": "the size, in bytes, of the interpreted value."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "and",
      "comment": "Compute the bitwise AND of this and another masked long\n \n To handle unknown bits, the result is derived from the following truth table:\n \n ",
      "javadoc": "Compute the bitwise AND of this and another masked long\n \n To handle unknown bits, the result is derived from the following truth table:\n \n \u003cpre\u003e{@literal\n   0 x 1 \u003c\u003d A (this)\n 0 0 0 0\n x 0 x x\n 1 0 x 1\n ^\n B (that)\n }\u003c/pre\u003e\n@param that the other masked long ({@code B}).\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the other masked long ()."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "invAnd",
      "comment": "Solves the expression \n \n To handle unknown bits, the solution is derived from the following truth table, where\n  indicates no solution:\n \n ",
      "javadoc": "Solves the expression {@code A \u0026 B \u003d C, for B, given C and A}\n \u003cp\u003e\n To handle unknown bits, the solution is derived from the following truth table, where\n {@code *} indicates no solution:\n \n \u003cpre\u003e{@literal\n   0 x 1 \u003c\u003d A (that)\n 0 x x 0\n x x x x\n 1 * 1 1\n ^\n B (this)\n }\u003c/pre\u003e\n@param that the other masked long ({@code B}).\n@return the result.\n@throws SolverException if no solution exists.",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the other masked long ()."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": [
        {
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.SolverException",
          "type_short": "SolverException",
          "comment": "if no solution exists."
        }
      ]
    },
    {
      "name": "or",
      "comment": "Compute the bitwise OR of this and another masked long\n \n To handle unknown bits, the result is derived from the following truth table:\n \n ",
      "javadoc": "Compute the bitwise OR of this and another masked long\n \n To handle unknown bits, the result is derived from the following truth table:\n \n \u003cpre\u003e{@literal\n   0 x 1 \u003c\u003d A (this)\n 0 0 x 1\n x x x 1\n 1 1 1 1\n ^\n B (that)\n }\u003c/pre\u003e\n@param that the other masked long ({@code B}).\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the other masked long ()."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "invOr",
      "comment": "Solves the expression A | B \u003d C, for B, given C and A\n \n To handle unknown bits, the solution is derived from the following truth table, where\n  indicates no solution:\n \n ",
      "javadoc": "Solves the expression A | B \u003d C, for B, given C and A\n \n To handle unknown bits, the solution is derived from the following truth table, where\n {@code *} indicates no solution:\n \n \u003cpre\u003e{@literal\n   0 x 1 \u003c\u003d A (that)\n 0 0 0 *\n x x x x\n 1 1 x x\n ^\n B (this)\n }\u003c/pre\u003e\n@param that the other masked long ({@code B}).\n@return the result.\n@throws SolverException if not solution exists.",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the other masked long ()."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": [
        {
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.SolverException",
          "type_short": "SolverException",
          "comment": "if not solution exists."
        }
      ]
    },
    {
      "name": "xor",
      "comment": "Compute the bitwise XOR of this and another masked long\n \n To handle unknown bits, the result is derived from the following truth table:\n \n ",
      "javadoc": "Compute the bitwise XOR of this and another masked long\n \n To handle unknown bits, the result is derived from the following truth table:\n \n \u003cpre\u003e{@literal\n   0 x 1 \u003c\u003d A (this)\n 0 0 x 1\n x x x x\n 1 1 x 0\n ^\n B (that)\n }\u003c/pre\u003e\n@param that the other masked long ({@code B}).\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the other masked long ()."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "negate",
      "comment": "Negate the value",
      "javadoc": "Negate the value\n@return the result.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "not",
      "comment": "Compute the bitwise NOT\n \n To handle unknown bits, the result is derived from the following truth table:\n \n ",
      "javadoc": "Compute the bitwise NOT\n \n To handle unknown bits, the result is derived from the following truth table:\n \n \u003cpre\u003e{@literal\n 0 x 1 \u003c\u003d A (this)\n 1 x 0\n }\u003c/pre\u003e\n@return the result.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "add",
      "comment": "Compute the arithmetic sum of this and another masked long",
      "javadoc": "Compute the arithmetic sum of this and another masked long\n@param that the other masked long.\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the other masked long."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "subtract",
      "comment": "Compute the arithmetic difference: this masked long minus another",
      "javadoc": "Compute the arithmetic difference: this masked long minus another\n@param that the other masked long.\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the other masked long."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "doRippleCarry",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "l",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": ""
        },
        {
          "name": "r",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": ""
        },
        {
          "name": "subtract",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "and",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "rmv",
          "type_long": "byte",
          "type_short": "byte",
          "comment": ""
        },
        {
          "name": "lmv",
          "type_long": "byte",
          "type_short": "byte",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "byte",
        "type_short": "byte",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "or",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "rmv",
          "type_long": "byte",
          "type_short": "byte",
          "comment": ""
        },
        {
          "name": "lmv",
          "type_long": "byte",
          "type_short": "byte",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "byte",
        "type_short": "byte",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "or",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "t1",
          "type_long": "byte",
          "type_short": "byte",
          "comment": ""
        },
        {
          "name": "t2",
          "type_long": "byte",
          "type_short": "byte",
          "comment": ""
        },
        {
          "name": "t3",
          "type_long": "byte",
          "type_short": "byte",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "byte",
        "type_short": "byte",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "xor",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "rmv",
          "type_long": "byte",
          "type_short": "byte",
          "comment": ""
        },
        {
          "name": "lmv",
          "type_long": "byte",
          "type_short": "byte",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "byte",
        "type_short": "byte",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "xor",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "t1",
          "type_long": "byte",
          "type_short": "byte",
          "comment": ""
        },
        {
          "name": "t2",
          "type_long": "byte",
          "type_short": "byte",
          "comment": ""
        },
        {
          "name": "t3",
          "type_long": "byte",
          "type_short": "byte",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "byte",
        "type_short": "byte",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "multiply",
      "comment": "Compute the arithmetic product of this and another masked long",
      "javadoc": "Compute the arithmetic product of this and another masked long\n@param that the other masked long.\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the other masked long."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "divideSigned",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "divideUnsigned",
      "comment": "Compute the unsigned arithmetic quotient: this masked long divided by another",
      "javadoc": "Compute the unsigned arithmetic quotient: this masked long divided by another\n@param that the other masked long.\n@return the result.",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the other masked long."
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result."
      },
      "throws": []
    },
    {
      "name": "invMultiplyUnsigned",
      "comment": "Compute the arithmetic quotient as a solution to unsigned multiplication\n \n This is slightly different than #divideUnsigned(MaskedLong) in its treatment of\n unknowns.",
      "javadoc": "Compute the arithmetic quotient as a solution to unsigned multiplication\n \n This is slightly different than {@link #divideUnsigned(MaskedLong)} in its treatment of\n unknowns.\n@param that the known factor\n@return a solution to that*x \u003d\u003d this, if possible\n@throws SolverException",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the known factor"
        }
      ],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "a solution to that*x \u003d\u003d this, if possible"
      },
      "throws": [
        {
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.SolverException",
          "type_short": "SolverException",
          "comment": ""
        }
      ]
    },
    {
      "name": "agrees",
      "comment": "Checks if this and another masked long agree\n \n Two masked longs agree iff their corresponding defined bit positions are equal. Where either\n or both positions are undefined, no check is applied. In the case that both masked longs are\n fully-defined, this is the same as an equality check on the values.",
      "javadoc": "Checks if this and another masked long agree\n \n Two masked longs agree iff their corresponding defined bit positions are equal. Where either\n or both positions are undefined, no check is applied. In the case that both masked longs are\n fully-defined, this is the same as an equality check on the values.\n@param that the other masked long.\n@return true if this and that agree.",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": "the other masked long."
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this and that agree."
      },
      "throws": []
    },
    {
      "name": "agrees",
      "comment": "Checks if this and a long agree\n \n The masked long agrees with the given long iff the masked long\u0027s defined bit positions agree\n with the corresponding bit positions in the given long. Where there are undefined bits, no\n check is applied. In the case that the masked long is fully-defined, this is the same as an\n equality check on the value.",
      "javadoc": "Checks if this and a long agree\n \n The masked long agrees with the given long iff the masked long\u0027s defined bit positions agree\n with the corresponding bit positions in the given long. Where there are undefined bits, no\n check is applied. In the case that the masked long is fully-defined, this is the same as an\n equality check on the value.\n@param that the long\n@return true if this and that agree.",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "long",
          "type_short": "long",
          "comment": "the long"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this and that agree."
      },
      "throws": []
    },
    {
      "name": "agrees",
      "comment": "Check if this and another object agree",
      "javadoc": "Check if this and another object agree\n@param that a {@link MaskedLong} or {@link Long} to check.\n@see #agrees(MaskedLong)\n@see #agrees(long)\n@return true if this and that agree.",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "java.lang.Object",
          "type_short": "Object",
          "comment": "a MaskedLong or Long to check."
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this and that agree."
      },
      "throws": []
    },
    {
      "name": "isInRange",
      "comment": "Check if the masked value falls within a given range\n \n The range is defined by a maximum and a signedness. The maximum must be one less than a\n positive power of 2. In other words, it defines a maximum number of bits, including the sign\n bit if applicable.\n \n The defined bits of this masked long are then checked to fall in the given range. The\n effective value is derived by sign/zero extending the value according to its mask. In\n general, if any  bits exist outside of the given max, the value is rejected, unless\n that  is purely a result of signedness.",
      "javadoc": "Check if the masked value falls within a given range\n \n The range is defined by a maximum and a signedness. The maximum must be one less than a\n positive power of 2. In other words, it defines a maximum number of bits, including the sign\n bit if applicable.\n \n The defined bits of this masked long are then checked to fall in the given range. The\n effective value is derived by sign/zero extending the value according to its mask. In\n general, if any {@code 1} bits exist outside of the given max, the value is rejected, unless\n that {@code 1} is purely a result of signedness.\n@param max the maximum value, taken as an unsigned long.\n@param signed true to interpret the masked value as signed.\n@return true if the masked value \"fits\" into the given range.",
      "static": false,
      "params": [
        {
          "name": "max",
          "type_long": "long",
          "type_short": "long",
          "comment": "the maximum value, taken as an unsigned long."
        },
        {
          "name": "signed",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true to interpret the masked value as signed."
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the masked value \"fits\" into the given range."
      },
      "throws": []
    },
    {
      "name": "compareTo",
      "comment": "\"Compare\" two masked longs\n \n This is not meant to reflect a numerical comparison. Rather, this is just to impose an\n ordering for the sake of storing these in sorted collections.",
      "javadoc": "\"Compare\" two masked longs\n \n This is not meant to reflect a numerical comparison. Rather, this is just to impose an\n ordering for the sake of storing these in sorted collections.",
      "static": false,
      "params": [
        {
          "name": "that",
          "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
          "type_short": "MaskedLong",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "equals",
      "comment": "Check for equality\n \n This will only return true if the other object is a masked long, even if this one is\n fully-defined, and the value is equal to a given long (or Long). The other masked\n long must have the same mask and value to be considered equal. For other sorts of \"equality\"\n checks, see #agrees(Object) and friends.",
      "javadoc": "Check for equality\n \n This will only return true if the other object is a masked long, even if this one is\n fully-defined, and the value is equal to a given long (or {@link Long}). The other masked\n long must have the same mask and value to be considered equal. For other sorts of \"equality\"\n checks, see {@link #agrees(Object)} and friends.",
      "static": false,
      "params": [
        {
          "name": "other",
          "type_long": "java.lang.Object",
          "type_short": "Object",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "hashCode",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "toString",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "signExtend",
      "comment": "Sign extend a number of the given size in bits, to a full long",
      "javadoc": "Sign extend a number of the given size in bits, to a full long\n@param val the value to extend\n@param bits the number of bits to take (right-to-left)\n@return the sign-extended value as a long",
      "static": true,
      "params": [
        {
          "name": "val",
          "type_long": "long",
          "type_short": "long",
          "comment": "the value to extend"
        },
        {
          "name": "bits",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of bits to take (right-to-left)"
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the sign-extended value as a long"
      },
      "throws": []
    },
    {
      "name": "zeroExtend",
      "comment": "Zero extend a number of the given size in bits, to a full long",
      "javadoc": "Zero extend a number of the given size in bits, to a full long\n@param val the value to extend\n@param bits the number of bits to take (right-to-left)\n@return the zero-extended value as a long",
      "static": true,
      "params": [
        {
          "name": "val",
          "type_long": "long",
          "type_short": "long",
          "comment": "the value to extend"
        },
        {
          "name": "bits",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of bits to take (right-to-left)"
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the zero-extended value as a long"
      },
      "throws": []
    },
    {
      "name": "fillMask",
      "comment": "Set all undefined bits to 0",
      "javadoc": "Set all undefined bits to 0\n@return the result",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.app.plugin.assembler.sleigh.expr.MaskedLong",
        "type_short": "MaskedLong",
        "comment": "the result"
      },
      "throws": []
    }
  ]
}
