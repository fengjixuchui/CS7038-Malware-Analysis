{
  "name": "NumericUtilities",
  "comment": "",
  "javadoc": "",
  "static": false,
  "implements": [],
  "extends": "java.lang.Object",
  "fields": [
    {
      "name": "MAX_UNSIGNED_LONG",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.math.BigInteger",
      "type_short": "BigInteger",
      "constant_value": null
    },
    {
      "name": "MAX_SIGNED_LONG",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.math.BigInteger",
      "type_short": "BigInteger",
      "constant_value": null
    },
    {
      "name": "MAX_UNSIGNED_INT32_AS_LONG",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "long",
      "type_short": "long",
      "constant_value": "4294967295"
    },
    {
      "name": "HEX_PREFIX_X",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"0X\""
    },
    {
      "name": "HEX_PREFIX_x",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"0x\""
    },
    {
      "name": "INTEGER_TYPES",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.util.Set\u003cjava.lang.Class\u003c? extends java.lang.Number\u003e\u003e",
      "type_short": "Set",
      "constant_value": null
    },
    {
      "name": "FLOATINGPOINT_TYPES",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.util.Set\u003cjava.lang.Class\u003c? extends java.lang.Number\u003e\u003e",
      "type_short": "Set",
      "constant_value": null
    },
    {
      "name": "SIGNED_INTEGER_RENDERER",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "ghidra.util.NumericUtilities.IntegerRadixRenderer",
      "type_short": "IntegerRadixRenderer",
      "constant_value": null
    },
    {
      "name": "UNSIGNED_INTEGER_RENDERER",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "ghidra.util.NumericUtilities.IntegerRadixRenderer",
      "type_short": "IntegerRadixRenderer",
      "constant_value": null
    },
    {
      "name": "DEFAULT_INTEGER_RENDERER",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "ghidra.util.NumericUtilities.IntegerRadixRenderer",
      "type_short": "IntegerRadixRenderer",
      "constant_value": null
    }
  ],
  "methods": [
    {
      "name": "\u003cinit\u003e",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "parseNumber",
      "comment": "parses the given string as a numeric value, detecting whether or not it begins with a Hex\n prefix, and if not, parses as a long int value.",
      "javadoc": "parses the given string as a numeric value, detecting whether or not it begins with a Hex\n prefix, and if not, parses as a long int value.",
      "static": true,
      "params": [
        {
          "name": "numStr",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "parseLong",
      "comment": "parses the given string as a numeric value, detecting whether or not it begins with a Hex\n prefix, and if not, parses as a long int value.",
      "javadoc": "parses the given string as a numeric value, detecting whether or not it begins with a Hex\n prefix, and if not, parses as a long int value.",
      "static": true,
      "params": [
        {
          "name": "numStr",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "parseOctLong",
      "comment": "parses the given string as a numeric value, detecting whether or not it begins with a Hex\n prefix, and if not, parses as a long int value.",
      "javadoc": "parses the given string as a numeric value, detecting whether or not it begins with a Hex\n prefix, and if not, parses as a long int value.",
      "static": true,
      "params": [
        {
          "name": "numStr",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "parseHexLong",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "numStr",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "parseHexBigInteger",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "numStr",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.math.BigInteger",
        "type_short": "BigInteger",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "toHexString",
      "comment": "returns the value of the specified long as hexadecimal, prefixing with the HEX_PREFIX_x\n string.",
      "javadoc": "returns the value of the specified long as hexadecimal, prefixing with the HEX_PREFIX_x\n string.\n@param value the long value to convert",
      "static": true,
      "params": [
        {
          "name": "value",
          "type_long": "long",
          "type_short": "long",
          "comment": "the long value to convert"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "toHexString",
      "comment": "returns the value of the specified long as hexadecimal, prefixing with the HEX_PREFIX_x\n string.",
      "javadoc": "returns the value of the specified long as hexadecimal, prefixing with the HEX_PREFIX_x\n string.\n@param value the long value to convert\n@param size number of bytes to be represented",
      "static": true,
      "params": [
        {
          "name": "value",
          "type_long": "long",
          "type_short": "long",
          "comment": "the long value to convert"
        },
        {
          "name": "size",
          "type_long": "int",
          "type_short": "int",
          "comment": "number of bytes to be represented"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "toSignedHexString",
      "comment": "returns the value of the specified long as signed hexadecimal, prefixing with the\n HEX_PREFIX_x string.",
      "javadoc": "returns the value of the specified long as signed hexadecimal, prefixing with the\n HEX_PREFIX_x string.\n@param value the long value to convert",
      "static": true,
      "params": [
        {
          "name": "value",
          "type_long": "long",
          "type_short": "long",
          "comment": "the long value to convert"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "unsignedLongToBigInteger",
      "comment": "Converts a unsigned long value, which is currently stored in a \n java signed long, into a BigInteger.\n \n In other words, the full 64 bits of the primitive java signed \n long is being used to store an unsigned value.  This \n method converts this into a positive BigInteger value.",
      "javadoc": "Converts a \u003cstrong\u003eunsigned\u003c/strong\u003e long value, which is currently stored in a \n java \u003cstrong\u003esigned\u003c/strong\u003e long, into a {@link BigInteger}.\n \u003cp\u003e\n In other words, the full 64 bits of the primitive java \u003cstrong\u003esigned\u003c/strong\u003e \n long is being used to store an \u003cstrong\u003eunsigned\u003c/strong\u003e value.  This \n method converts this into a positive BigInteger value.\n@param value java \u003cstrong\u003eunsigned\u003c/strong\u003e long value stuffed into a \n java \u003cstrong\u003esigned\u003c/strong\u003e long\n@return new {@link BigInteger} with the positive value of the unsigned long value",
      "static": true,
      "params": [
        {
          "name": "value",
          "type_long": "long",
          "type_short": "long",
          "comment": "java unsigned long value stuffed into a \n java signed long"
        }
      ],
      "return": {
        "type_long": "java.math.BigInteger",
        "type_short": "BigInteger",
        "comment": "new BigInteger with the positive value of the unsigned long value"
      },
      "throws": []
    },
    {
      "name": "bigIntegerToUnsignedLong",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "value",
          "type_long": "java.math.BigInteger",
          "type_short": "BigInteger",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getUnsignedAlignedValue",
      "comment": "Get an unsigned aligned value corresponding to the specified unsigned value which will be\n greater than or equal the specified value.",
      "javadoc": "Get an unsigned aligned value corresponding to the specified unsigned value which will be\n greater than or equal the specified value.\n@param unsignedValue value to be aligned\n@param alignment alignment\n@return aligned value",
      "static": true,
      "params": [
        {
          "name": "unsignedValue",
          "type_long": "long",
          "type_short": "long",
          "comment": "value to be aligned"
        },
        {
          "name": "alignment",
          "type_long": "long",
          "type_short": "long",
          "comment": "alignment"
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "aligned value"
      },
      "throws": []
    },
    {
      "name": "convertMaskedValueToHexString",
      "comment": "Convert a masked value into a hexadecimal-ish string.\n\n Converts the data to hexadecimal, placing an X where a nibble is unknown. Where a nibble is\n partially defined, it is displayed as four bits in brackets []. Bits are displayed as x, or\n the defined value.\n\n For example, consider the mask 00001111:01011100, and the value 00001001:00011000. This will\n display as . To see the correlation, consider the table:\n \n \n \n Display\n \n \n \n \n \n \n \n Mask\n \n \n \n \n \n \n \n Value\n \n \n \n \n \n \n ",
      "javadoc": "Convert a masked value into a hexadecimal-ish string.\n\n Converts the data to hexadecimal, placing an X where a nibble is unknown. Where a nibble is\n partially defined, it is displayed as four bits in brackets []. Bits are displayed as x, or\n the defined value.\n\n For example, consider the mask 00001111:01011100, and the value 00001001:00011000. This will\n display as {@code X8:[x0x1][10xx]}. To see the correlation, consider the table:\n \u003ctable\u003e\n \u003ccaption\u003e\u003c/caption\u003e\n \u003ctr\u003e\n \u003cth\u003eDisplay\u003c/th\u003e\n \u003cth\u003e{@code X}\u003c/th\u003e\n \u003cth\u003e{@code 8}\u003c/th\u003e\n \u003cth\u003e{@code :}\u003c/th\u003e\n \u003cth\u003e{@code [x0x1]}\u003c/th\u003e\n \u003cth\u003e{@code [10xx]}\u003c/th\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n \u003cth\u003eMask\u003c/th\u003e\n \u003ctd\u003e{@code 0000}\u003c/td\u003e\n \u003ctd\u003e{@code 1111}\u003c/td\u003e\n \u003ctd\u003e{@code :}\u003c/td\u003e\n \u003ctd\u003e{@code 0101}\u003c/td\u003e\n \u003ctd\u003e{@code 1100}\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n \u003cth\u003eValue\u003c/th\u003e\n \u003ctd\u003e{@code 0000}\u003c/td\u003e\n \u003ctd\u003e{@code 1000}\u003c/td\u003e\n \u003ctd\u003e{@code :}\u003c/td\u003e\n \u003ctd\u003e{@code 0001}\u003c/td\u003e\n \u003ctd\u003e{@code 1000}\u003c/td\u003e\n \u003c/tr\u003e\n \u003c/table\u003e\n@param msk the mask\n@param val the value\n@param n the number of nibbles, starting at the right. The example uses 4.\n@param truncate true if leading Xs may be truncated. The example uses {@code false}.\n@param spaceevery how many nibbles in spaced groups, 0 for no spaces. The example uses 2.\n@param spacer the group separator, if applicable. The example uses {@code \u0027:\u0027}.\n@return the string representation\n@see #convertMaskToHexString(long, int, boolean, int, String)\n@see #convertHexStringToMaskedValue(AtomicLong, AtomicLong, String, int, int, String)",
      "static": true,
      "params": [
        {
          "name": "msk",
          "type_long": "long",
          "type_short": "long",
          "comment": "the mask"
        },
        {
          "name": "val",
          "type_long": "long",
          "type_short": "long",
          "comment": "the value"
        },
        {
          "name": "n",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of nibbles, starting at the right. The example uses 4."
        },
        {
          "name": "truncate",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if leading Xs may be truncated. The example uses ."
        },
        {
          "name": "spaceevery",
          "type_long": "int",
          "type_short": "int",
          "comment": "how many nibbles in spaced groups, 0 for no spaces. The example uses 2."
        },
        {
          "name": "spacer",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the group separator, if applicable. The example uses ."
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the string representation"
      },
      "throws": []
    },
    {
      "name": "convertMaskToHexString",
      "comment": "Convert a mask to a hexadecimal-ish string.\n\n Converts the mask in a similar way to\n #convertMaskedValueToHexString(long, long, int, boolean, int, String).\n Philosophically, it is hexadecimal, but the only valid digits are 0 and F. Any\n partially-included nibble will be broken down into bracketed bits. Displaying masks in this\n way is convenient when shown proximal to related masked values.",
      "javadoc": "Convert a mask to a hexadecimal-ish string.\n\n Converts the mask in a similar way to\n {@link #convertMaskedValueToHexString(long, long, int, boolean, int, String)}.\n Philosophically, it is hexadecimal, but the only valid digits are 0 and F. Any\n partially-included nibble will be broken down into bracketed bits. Displaying masks in this\n way is convenient when shown proximal to related masked values.\n@param msk the mask\n@param n the number of nibbles, starting at the right\n@param truncate true if leading Xs may be truncated\n@param spaceevery how many nibbles in spaced groups, 0 for no spaces\n@param spacer the group separator, if applicable\n@return the string representation\n@see #convertMaskedValueToHexString(long, long, int, boolean, int, String)\n@see #convertHexStringToMaskedValue(AtomicLong, AtomicLong, String, int, int, String)",
      "static": true,
      "params": [
        {
          "name": "msk",
          "type_long": "long",
          "type_short": "long",
          "comment": "the mask"
        },
        {
          "name": "n",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of nibbles, starting at the right"
        },
        {
          "name": "truncate",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if leading Xs may be truncated"
        },
        {
          "name": "spaceevery",
          "type_long": "int",
          "type_short": "int",
          "comment": "how many nibbles in spaced groups, 0 for no spaces"
        },
        {
          "name": "spacer",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the group separator, if applicable"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the string representation"
      },
      "throws": []
    },
    {
      "name": "convertHexStringToMaskedValue",
      "comment": "The reverse of #convertMaskedValueToHexString(long, long, int, boolean, int, String)",
      "javadoc": "The reverse of {@link #convertMaskedValueToHexString(long, long, int, boolean, int, String)}\n@param msk an object to receive the resulting mask\n@param val an object to receive the resulting value\n@param hex the input string to parse\n@param n the number of nibbles to parse (they are stored right aligned in the result)\n@param spaceevery how many nibbles are expected between spacers\n@param spacer the spacer\n@see #convertMaskedValueToHexString(long, long, int, boolean, int, String)\n@see #convertMaskToHexString(long, int, boolean, int, String)",
      "static": true,
      "params": [
        {
          "name": "msk",
          "type_long": "java.util.concurrent.atomic.AtomicLong",
          "type_short": "AtomicLong",
          "comment": "an object to receive the resulting mask"
        },
        {
          "name": "val",
          "type_long": "java.util.concurrent.atomic.AtomicLong",
          "type_short": "AtomicLong",
          "comment": "an object to receive the resulting value"
        },
        {
          "name": "hex",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the input string to parse"
        },
        {
          "name": "n",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of nibbles to parse (they are stored right aligned in the result)"
        },
        {
          "name": "spaceevery",
          "type_long": "int",
          "type_short": "int",
          "comment": "how many nibbles are expected between spacers"
        },
        {
          "name": "spacer",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the spacer"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "formatNumber",
      "comment": "Render number in different bases using the default signedness mode.\n \n This invokes  with a\n mode parameter of .",
      "javadoc": "Render \u003ccode\u003enumber\u003c/code\u003e in different bases using the default signedness mode.\n \u003cp\u003e\n This invokes {@linkplain #formatNumber(long, int, SignednessFormatMode)} with a\n \u003ccode\u003emode\u003c/code\u003e parameter of \u003ccode\u003e{@linkplain SignednessFormatMode#DEFAULT}\u003c/code\u003e.\n@param number The number to represent\n@param radix the base in which \u003ccode\u003enumber\u003c/code\u003e is represented\n@return formatted string of the number parameter in provided radix base\n@see #formatNumber(long, int, SignednessFormatMode)",
      "static": true,
      "params": [
        {
          "name": "number",
          "type_long": "long",
          "type_short": "long",
          "comment": "The number to represent"
        },
        {
          "name": "radix",
          "type_long": "int",
          "type_short": "int",
          "comment": "the base in which number is represented"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "formatted string of the number parameter in provided radix base"
      },
      "throws": []
    },
    {
      "name": "formatNumber",
      "comment": "Provide renderings of number in different bases:\n \n 0 - renders number as an escaped character sequence\n 2 - renders number as a base-2 integer\n 8 - renders number as a base-8 integer\n 10 - renders number as a base-10 integer\n 16 (default) - renders number as a base-16\n integer\n \n \n \n \n Number\n Radix\n DEFAULT Mode Alias\n UNSIGNED Mode Value\n SIGNED Mode Value\n \n \n \n \n \n \n \n \n \n 100\n 2\n UNSIGNED\n 1100100b\n 1100100b\n \n \n 100\n 8\n UNSIGNED\n 144o\n 144o\n \n \n 100\n 10\n SIGNED\n 100\n 100\n \n \n 100\n 16\n UNSIGNED\n 64h\n 64h\n \n \n \n \n \n \n \n \n \n -1\n 2\n UNSIGNED\n 1111111111111111111111111111111111111111111111111111111111111111b\n -1b\n \n \n -1\n 8\n UNSIGNED\n 1777777777777777777777o\n -1o\n \n \n -1\n 10\n SIGNED\n 18446744073709551615\n -1\n \n \n -1\n 16\n UNSIGNED\n ffffffffffffffffh\n -1h\n \n \n \n \n \n \n \n \n \n -100\n 2\n UNSIGNED\n 1111111111111111111111111111111111111111111111111111111110011100b\n -1100100b\n \n \n -100\n 8\n UNSIGNED\n 1777777777777777777634o\n -144o\n \n \n -100\n 10\n SIGNED\n 18446744073709551516\n -100\n \n \n -100\n 16\n UNSIGNED\n ffffffffffffff9ch\n -64h\n \n ",
      "javadoc": "Provide renderings of \u003ccode\u003enumber\u003c/code\u003e in different bases:\n \u003cul\u003e\n \u003cli\u003e\u003ccode\u003e0\u003c/code\u003e - renders \u003ccode\u003enumber\u003c/code\u003e as an escaped character sequence\u003c/li\u003e\n \u003cli\u003e\u003ccode\u003e2\u003c/code\u003e - renders \u003ccode\u003enumber\u003c/code\u003e as a \u003ccode\u003ebase-2\u003c/code\u003e integer\u003c/li\u003e\n \u003cli\u003e\u003ccode\u003e8\u003c/code\u003e - renders \u003ccode\u003enumber\u003c/code\u003e as a \u003ccode\u003ebase-8\u003c/code\u003e integer\u003c/li\u003e\n \u003cli\u003e\u003ccode\u003e10\u003c/code\u003e - renders \u003ccode\u003enumber\u003c/code\u003e as a \u003ccode\u003ebase-10\u003c/code\u003e integer\u003c/li\u003e\n \u003cli\u003e\u003ccode\u003e16\u003c/code\u003e (default) - renders \u003ccode\u003enumber\u003c/code\u003e as a \u003ccode\u003ebase-16\u003c/code\u003e\n integer\u003c/li\u003e\n \u003c/ul\u003e\n \u003ctable\u003e\n \u003ccaption\u003e\u003c/caption\u003e\n \u003ctr\u003e\n \u003cth\u003eNumber\u003c/th\u003e\n \u003cth\u003eRadix\u003c/th\u003e\n \u003cth\u003eDEFAULT Mode Alias\u003c/th\u003e\n \u003cth style\u003d\"text-align:center\"\u003e\u003ci\u003eUNSIGNED\u003c/i\u003e Mode Value\u003c/th\u003e\n \u003cth\u003e\u003ci\u003eSIGNED\u003c/i\u003e Mode Value\u003c/th\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n \u003ctd\u003e\u0026nbsp;\u003c/td\u003e\n \u003ctd\u003e\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003e\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003e\u003c/td\u003e\n \u003ctd\u003e\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr style\u003d\"text-align:right;font-family: monospace\"\u003e\n \u003ctd\u003e100\u003c/td\u003e\n \u003ctd\u003e2\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003eUNSIGNED\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003e1100100b\u003c/td\u003e\n \u003ctd\u003e1100100b\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr style\u003d\"text-align:right;font-family: monospace\"\u003e\n \u003ctd\u003e100\u003c/td\u003e\n \u003ctd\u003e8\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003eUNSIGNED\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003e144o\u003c/td\u003e\n \u003ctd\u003e144o\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr style\u003d\"text-align:right;font-family: monospace\"\u003e\n \u003ctd\u003e100\u003c/td\u003e\n \u003ctd\u003e10\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003eSIGNED\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003e100\u003c/td\u003e\n \u003ctd\u003e100\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr style\u003d\"text-align:right;font-family: monospace\"\u003e\n \u003ctd\u003e100\u003c/td\u003e\n \u003ctd\u003e16\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003eUNSIGNED\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003e64h\u003c/td\u003e\n \u003ctd\u003e64h\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n \u003ctd\u003e\u0026nbsp;\u003c/td\u003e\n \u003ctd\u003e\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003e\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003e\u003c/td\u003e\n \u003ctd\u003e\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr style\u003d\"text-align:right;font-family: monospace\"\u003e\n \u003ctd\u003e-1\u003c/td\u003e\n \u003ctd\u003e2\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003eUNSIGNED\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003e1111111111111111111111111111111111111111111111111111111111111111b\u003c/td\u003e\n \u003ctd\u003e-1b\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr style\u003d\"text-align:right;font-family: monospace\"\u003e\n \u003ctd\u003e-1\u003c/td\u003e\n \u003ctd\u003e8\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003eUNSIGNED\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003e1777777777777777777777o\u003c/td\u003e\n \u003ctd\u003e-1o\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr style\u003d\"text-align:right;font-family: monospace\"\u003e\n \u003ctd\u003e-1\u003c/td\u003e\n \u003ctd\u003e10\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003eSIGNED\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003e18446744073709551615\u003c/td\u003e\n \u003ctd\u003e-1\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr style\u003d\"text-align:right;font-family: monospace\"\u003e\n \u003ctd\u003e-1\u003c/td\u003e\n \u003ctd\u003e16\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003eUNSIGNED\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003effffffffffffffffh\u003c/td\u003e\n \u003ctd\u003e-1h\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n \u003ctd\u003e\u0026nbsp;\u003c/td\u003e\n \u003ctd\u003e\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003e\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003e\u003c/td\u003e\n \u003ctd\u003e\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr style\u003d\"text-align:right;font-family: monospace\"\u003e\n \u003ctd\u003e-100\u003c/td\u003e\n \u003ctd\u003e2\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003eUNSIGNED\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003e1111111111111111111111111111111111111111111111111111111110011100b\u003c/td\u003e\n \u003ctd\u003e-1100100b\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr style\u003d\"text-align:right;font-family: monospace\"\u003e\n \u003ctd\u003e-100\u003c/td\u003e\n \u003ctd\u003e8\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003eUNSIGNED\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003e1777777777777777777634o\u003c/td\u003e\n \u003ctd\u003e-144o\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr style\u003d\"text-align:right;font-family: monospace\"\u003e\n \u003ctd\u003e-100\u003c/td\u003e\n \u003ctd\u003e10\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003eSIGNED\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003e18446744073709551516\u003c/td\u003e\n \u003ctd\u003e-100\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr style\u003d\"text-align:right;font-family: monospace\"\u003e\n \u003ctd\u003e-100\u003c/td\u003e\n \u003ctd\u003e16\u003c/td\u003e\n \u003ctd\u003e\u003ci\u003eUNSIGNED\u003c/i\u003e\u003c/td\u003e\n \u003ctd\u003effffffffffffff9ch\u003c/td\u003e\n \u003ctd\u003e-64h\u003c/td\u003e\n \u003c/tr\u003e\n \u003c/table\u003e\n@param number The number to represent\n@param radix The base in which \u003ccode\u003enumber\u003c/code\u003e is represented\n@param mode Specifies how the number is formatted with respect to its signed-ness\n@return number string in the given base",
      "static": true,
      "params": [
        {
          "name": "number",
          "type_long": "long",
          "type_short": "long",
          "comment": "The number to represent"
        },
        {
          "name": "radix",
          "type_long": "int",
          "type_short": "int",
          "comment": "The base in which number is represented"
        },
        {
          "name": "mode",
          "type_long": "ghidra.util.SignednessFormatMode",
          "type_short": "SignednessFormatMode",
          "comment": "Specifies how the number is formatted with respect to its signed-ness"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "number string in the given base"
      },
      "throws": []
    },
    {
      "name": "convertStringToBytes",
      "comment": "Parse hexadecimal digits into a byte array.",
      "javadoc": "Parse hexadecimal digits into a byte array.\n@param hexString hexadecimal digits\n@return numeric value as a byte array, or null if string contains invalid hex characters.",
      "static": true,
      "params": [
        {
          "name": "hexString",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "hexadecimal digits"
        }
      ],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": "numeric value as a byte array, or null if string contains invalid hex characters."
      },
      "throws": []
    },
    {
      "name": "condenseByteString",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "hexString",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.CharSequence",
        "type_short": "CharSequence",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "convertCharSequenceToBytes",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "characters",
          "type_long": "java.lang.CharSequence",
          "type_short": "CharSequence",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "toString",
      "comment": "Convert the given byte into a two character String, padding with a leading 0 if needed.",
      "javadoc": "Convert the given byte into a two character String, padding with a leading 0 if needed.\n@param b the byte\n@return the byte string",
      "static": true,
      "params": [
        {
          "name": "b",
          "type_long": "byte",
          "type_short": "byte",
          "comment": "the byte"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the byte string"
      },
      "throws": []
    },
    {
      "name": "convertBytesToString",
      "comment": "Convert a byte array into a hexadecimal string.",
      "javadoc": "Convert a byte array into a hexadecimal string.\n@param bytes byte array\n@return hex string representation",
      "static": true,
      "params": [
        {
          "name": "bytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "byte array"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "hex string representation"
      },
      "throws": []
    },
    {
      "name": "convertBytesToString",
      "comment": "Convert a byte array into a hexadecimal string.",
      "javadoc": "Convert a byte array into a hexadecimal string.\n@param bytes byte array\n@param delimeter the text between byte strings\n@return hex string representation",
      "static": true,
      "params": [
        {
          "name": "bytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "byte array"
        },
        {
          "name": "delimeter",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the text between byte strings"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "hex string representation"
      },
      "throws": []
    },
    {
      "name": "convertBytesToString",
      "comment": "Convert a byte array into a hexadecimal string.",
      "javadoc": "Convert a byte array into a hexadecimal string.\n@param bytes byte array\n@param start start index\n@param len number of bytes to convert\n@param delimeter the text between byte strings\n@return hex string representation",
      "static": true,
      "params": [
        {
          "name": "bytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "byte array"
        },
        {
          "name": "start",
          "type_long": "int",
          "type_short": "int",
          "comment": "start index"
        },
        {
          "name": "len",
          "type_long": "int",
          "type_short": "int",
          "comment": "number of bytes to convert"
        },
        {
          "name": "delimeter",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the text between byte strings"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "hex string representation"
      },
      "throws": []
    },
    {
      "name": "convertBytesToString",
      "comment": "Convert a bytes into a hexadecimal string.",
      "javadoc": "Convert a bytes into a hexadecimal string.\n@param bytes an iterator of bytes\n@param delimiter the text between byte strings; null is allowed\n@return hex string representation",
      "static": true,
      "params": [
        {
          "name": "bytes",
          "type_long": "java.util.Iterator\u003cjava.lang.Byte\u003e",
          "type_short": "Iterator",
          "comment": "an iterator of bytes"
        },
        {
          "name": "delimiter",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the text between byte strings; null is allowed"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "hex string representation"
      },
      "throws": []
    },
    {
      "name": "convertBytesToString",
      "comment": "Convert a bytes into a hexadecimal string.",
      "javadoc": "Convert a bytes into a hexadecimal string.\n@param bytes an iterable of bytes\n@param delimiter the text between byte strings; null is allowed\n@return hex string representation",
      "static": true,
      "params": [
        {
          "name": "bytes",
          "type_long": "java.lang.Iterable\u003cjava.lang.Byte\u003e",
          "type_short": "Iterable",
          "comment": "an iterable of bytes"
        },
        {
          "name": "delimiter",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the text between byte strings; null is allowed"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "hex string representation"
      },
      "throws": []
    },
    {
      "name": "convertBytesToString",
      "comment": "Convert a bytes into a hexadecimal string.",
      "javadoc": "Convert a bytes into a hexadecimal string.\n@param bytes an stream of bytes\n@param delimiter the text between byte strings; null is allowed\n@return hex string representation",
      "static": true,
      "params": [
        {
          "name": "bytes",
          "type_long": "java.util.stream.Stream\u003cjava.lang.Byte\u003e",
          "type_short": "Stream",
          "comment": "an stream of bytes"
        },
        {
          "name": "delimiter",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the text between byte strings; null is allowed"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "hex string representation"
      },
      "throws": []
    },
    {
      "name": "isIntegerType",
      "comment": "Determine if the provided Number is an integer type -- Byte, Short, Integer, or Long.",
      "javadoc": "Determine if the provided Number is an integer type -- Byte, Short, Integer, or Long.\n@param number the object to check for for integer-type\n@return true if the provided number is an integer-type, false otherwise",
      "static": true,
      "params": [
        {
          "name": "number",
          "type_long": "java.lang.Number",
          "type_short": "Number",
          "comment": "the object to check for for integer-type"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the provided number is an integer-type, false otherwise"
      },
      "throws": []
    },
    {
      "name": "isIntegerType",
      "comment": "Determine if the provided Number class is an integer type.",
      "javadoc": "Determine if the provided Number class is an integer type.\n@param numClass Class of an object\n@return true if the class parameter is a integer type, false otherwise",
      "static": true,
      "params": [
        {
          "name": "numClass",
          "type_long": "java.lang.Class\u003c?\u003e",
          "type_short": "Class",
          "comment": "Class of an object"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the class parameter is a integer type, false otherwise"
      },
      "throws": []
    },
    {
      "name": "isFloatingPointType",
      "comment": "Determine if the provided Number is a floating-point type -- Float or Double.",
      "javadoc": "Determine if the provided Number is a floating-point type -- Float or Double.\n@param number the object to check for for floating-point-type\n@return true if the provided number is a floating-point-type, false otherwise",
      "static": true,
      "params": [
        {
          "name": "number",
          "type_long": "java.lang.Number",
          "type_short": "Number",
          "comment": "the object to check for for floating-point-type"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the provided number is a floating-point-type, false otherwise"
      },
      "throws": []
    },
    {
      "name": "isFloatingPointType",
      "comment": "Determine if the provided Number class is a floating-point type.",
      "javadoc": "Determine if the provided Number class is a floating-point type.\n@param numClass Class of an object\n@return true if the class parameter is a floating-point type, false otherwise",
      "static": true,
      "params": [
        {
          "name": "numClass",
          "type_long": "java.lang.Class\u003c?\u003e",
          "type_short": "Class",
          "comment": "Class of an object"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the class parameter is a floating-point type, false otherwise"
      },
      "throws": []
    }
  ]
}
