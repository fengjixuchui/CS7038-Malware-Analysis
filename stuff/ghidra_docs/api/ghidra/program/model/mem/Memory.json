{
  "name": "Memory",
  "comment": "Interface for Memory.",
  "javadoc": "Interface for Memory.",
  "static": false,
  "implements": [
    "ghidra.program.model.address.AddressSetView"
  ],
  "fields": [
    {
      "name": "GBYTE_SHIFT_FACTOR",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "30"
    },
    {
      "name": "GBYTE",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "long",
      "type_short": "long",
      "constant_value": "1073741824"
    },
    {
      "name": "MAX_BINARY_SIZE_GB",
      "comment": "Maximum size of all memory blocks, 16-GByte (see #getAllInitializedAddressSet()).\n This restriction is somewhat arbitrary but is established to prevent an excessive\n number of memory map segments which can have a negative impact on performance.",
      "javadoc": "Maximum size of all memory blocks, 16-GByte (see {@link #getAllInitializedAddressSet()}).\n This restriction is somewhat arbitrary but is established to prevent an excessive\n number of memory map segments which can have a negative impact on performance.",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "16"
    },
    {
      "name": "MAX_BINARY_SIZE",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "long",
      "type_short": "long",
      "constant_value": "17179869184"
    },
    {
      "name": "MAX_BLOCK_SIZE_GB",
      "comment": "The current max size of a memory block.",
      "javadoc": "The current max size of a memory block.",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "16"
    },
    {
      "name": "MAX_BLOCK_SIZE",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "long",
      "type_short": "long",
      "constant_value": "17179869184"
    }
  ],
  "methods": [
    {
      "name": "getProgram",
      "comment": "Returns the program that this memory belongs to.",
      "javadoc": "Returns the program that this memory belongs to.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Program",
        "type_short": "Program",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getLoadedAndInitializedAddressSet",
      "comment": "Returns the set of addresses which correspond to all the \"loaded\" memory blocks that have\n initialized data.  This does not include initialized memory blocks that contain data from\n the program\u0027s file header such as debug sections.",
      "javadoc": "Returns the set of addresses which correspond to all the \"loaded\" memory blocks that have\n initialized data.  This does not include initialized memory blocks that contain data from\n the program\u0027s file header such as debug sections.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.AddressSetView",
        "type_short": "AddressSetView",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getAllInitializedAddressSet",
      "comment": "Returns the set of addresses which correspond to all memory blocks that have\n initialized data.  This includes initialized memory blocks that contain data from\n the program\u0027s file header that are not actually in the running in memory image,\n such as debug sections.  Use #getLoadedAndInitializedAddressSet if you only want\n the addressed of the loaded in memory blocks.",
      "javadoc": "Returns the set of addresses which correspond to all memory blocks that have\n initialized data.  This includes initialized memory blocks that contain data from\n the program\u0027s file header that are not actually in the running in memory image,\n such as debug sections.  Use {@link #getLoadedAndInitializedAddressSet} if you only want\n the addressed of the loaded in memory blocks.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.AddressSetView",
        "type_short": "AddressSetView",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getInitializedAddressSet",
      "comment": "Use #getLoadedAndInitializedAddressSet instead.",
      "javadoc": "Use {@link #getLoadedAndInitializedAddressSet} instead.\n@deprecated",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.AddressSetView",
        "type_short": "AddressSetView",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getExecuteSet",
      "comment": "Returns the set of addresses which correspond to the executable memory.",
      "javadoc": "Returns the set of addresses which correspond to the executable memory.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.AddressSetView",
        "type_short": "AddressSetView",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isBigEndian",
      "comment": "Returns true if the memory is bigEndian, false otherwise.",
      "javadoc": "Returns true if the memory is bigEndian, false otherwise.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "setLiveMemoryHandler",
      "comment": "Sets the live memory handler",
      "javadoc": "Sets the live memory handler\n@param handler the live memory handler",
      "static": false,
      "params": [
        {
          "name": "handler",
          "type_long": "ghidra.program.model.mem.LiveMemoryHandler",
          "type_short": "LiveMemoryHandler",
          "comment": "the live memory handler"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getLiveMemoryHandler",
      "comment": "Returns the live memory handler instance used by this memory.",
      "javadoc": "Returns the live memory handler instance used by this memory.\n@return the live memory handler",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.mem.LiveMemoryHandler",
        "type_short": "LiveMemoryHandler",
        "comment": "the live memory handler"
      },
      "throws": []
    },
    {
      "name": "createInitializedBlock",
      "comment": "Create an initialized memory block and add it to this Memory.",
      "javadoc": "Create an initialized memory block and add it to this Memory.\n@param name block name (See {@link Memory#isValidMemoryBlockName(String)} for\n naming rules)\n@param start start address of the block\n@param is source of the data used to fill the block or null for zero initialization.\n@param length the size of the block\n@param monitor task monitor\n@param overlay if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space.\n@return new Initialized Memory Block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if the new block overlaps with a\n previous block\n@throws AddressOverflowException if the start is beyond the\n address space\n@throws CancelledException user cancelled operation\n@throws IllegalArgumentException if invalid block name specified",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "block name (See Memory#isValidMemoryBlockName(String) for\n naming rules)"
        },
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "start address of the block"
        },
        {
          "name": "is",
          "type_long": "java.io.InputStream",
          "type_short": "InputStream",
          "comment": "source of the data used to fill the block or null for zero initialization."
        },
        {
          "name": "length",
          "type_long": "long",
          "type_short": "long",
          "comment": "the size of the block"
        },
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": "task monitor"
        },
        {
          "name": "overlay",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "new Initialized Memory Block"
      },
      "throws": [
        {
          "type_long": "ghidra.framework.store.LockException",
          "type_short": "LockException",
          "comment": "if exclusive lock not in place (see haveLock())"
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryConflictException",
          "type_short": "MemoryConflictException",
          "comment": "if the new block overlaps with a\n previous block"
        },
        {
          "type_long": "ghidra.program.model.address.AddressOverflowException",
          "type_short": "AddressOverflowException",
          "comment": "if the start is beyond the\n address space"
        },
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": "user cancelled operation"
        },
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if invalid block name specified"
        }
      ]
    },
    {
      "name": "createInitializedBlock",
      "comment": "Create an initialized memory block and add it to this Memory.",
      "javadoc": "Create an initialized memory block and add it to this Memory.\n@param name block name (See {@link Memory#isValidMemoryBlockName(String)} for\n naming rules)\n@param start start of the block\n@param size block length (positive non-zero value required)\n@param initialValue initialization value for every byte in the block.\n@param monitor progress monitor, may be null.\n@param overlay if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space.\n@return new Initialized Memory Block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if the new block overlaps with a\n previous block\n@throws AddressOverflowException if the start is beyond the\n address space\n@throws IllegalArgumentException if invalid block name specified\n@throws CancelledException user cancelled operation",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "block name (See Memory#isValidMemoryBlockName(String) for\n naming rules)"
        },
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "start of the block"
        },
        {
          "name": "size",
          "type_long": "long",
          "type_short": "long",
          "comment": "block length (positive non-zero value required)"
        },
        {
          "name": "initialValue",
          "type_long": "byte",
          "type_short": "byte",
          "comment": "initialization value for every byte in the block."
        },
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": "progress monitor, may be null."
        },
        {
          "name": "overlay",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "new Initialized Memory Block"
      },
      "throws": [
        {
          "type_long": "ghidra.framework.store.LockException",
          "type_short": "LockException",
          "comment": "if exclusive lock not in place (see haveLock())"
        },
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if invalid block name specified"
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryConflictException",
          "type_short": "MemoryConflictException",
          "comment": "if the new block overlaps with a\n previous block"
        },
        {
          "type_long": "ghidra.program.model.address.AddressOverflowException",
          "type_short": "AddressOverflowException",
          "comment": "if the start is beyond the\n address space"
        },
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": "user cancelled operation"
        }
      ]
    },
    {
      "name": "createInitializedBlock",
      "comment": "Create an initialized memory block using bytes from a FileBytes object.",
      "javadoc": "Create an initialized memory block using bytes from a {@link FileBytes} object.\n@param name block name (See {@link Memory#isValidMemoryBlockName(String)} for\n naming rules)\n@param start starting address of the block\n@param fileBytes the {@link FileBytes} object to use as the underlying source of bytes.\n@param offset the offset into the FileBytes for the first byte of this memory block.\n@param size block length (positive non-zero value required)\n@param overlay if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space.\n@return new Initialized Memory Block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if the new block overlaps with a\n previous block\n@throws AddressOverflowException if the start is beyond the address space\n@throws IndexOutOfBoundsException if file bytes range specified by offset and size \n is out of bounds for the specified fileBytes.\n@throws IllegalArgumentException if invalid block name specified",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "block name (See Memory#isValidMemoryBlockName(String) for\n naming rules)"
        },
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "starting address of the block"
        },
        {
          "name": "fileBytes",
          "type_long": "ghidra.program.database.mem.FileBytes",
          "type_short": "FileBytes",
          "comment": "the FileBytes object to use as the underlying source of bytes."
        },
        {
          "name": "offset",
          "type_long": "long",
          "type_short": "long",
          "comment": "the offset into the FileBytes for the first byte of this memory block."
        },
        {
          "name": "size",
          "type_long": "long",
          "type_short": "long",
          "comment": "block length (positive non-zero value required)"
        },
        {
          "name": "overlay",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "new Initialized Memory Block"
      },
      "throws": [
        {
          "type_long": "ghidra.framework.store.LockException",
          "type_short": "LockException",
          "comment": "if exclusive lock not in place (see haveLock())"
        },
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if invalid block name specified"
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryConflictException",
          "type_short": "MemoryConflictException",
          "comment": "if the new block overlaps with a\n previous block"
        },
        {
          "type_long": "ghidra.program.model.address.AddressOverflowException",
          "type_short": "AddressOverflowException",
          "comment": "if the start is beyond the address space"
        }
      ]
    },
    {
      "name": "createUninitializedBlock",
      "comment": "Create an uninitialized memory block and add it to this Memory.",
      "javadoc": "Create an uninitialized memory block and add it to this Memory.\n@param name block name (See {@link Memory#isValidMemoryBlockName(String)} for\n naming rules)\n@param start start of the block\n@param size block length\n@param overlay if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space.\n@return new Uninitialized Memory Block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if the new block overlaps with a\n previous block\n@throws AddressOverflowException if the start is beyond the\n address space\n@throws IllegalArgumentException if invalid block name specified",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "block name (See Memory#isValidMemoryBlockName(String) for\n naming rules)"
        },
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "start of the block"
        },
        {
          "name": "size",
          "type_long": "long",
          "type_short": "long",
          "comment": "block length"
        },
        {
          "name": "overlay",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "new Uninitialized Memory Block"
      },
      "throws": [
        {
          "type_long": "ghidra.framework.store.LockException",
          "type_short": "LockException",
          "comment": "if exclusive lock not in place (see haveLock())"
        },
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if invalid block name specified"
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryConflictException",
          "type_short": "MemoryConflictException",
          "comment": "if the new block overlaps with a\n previous block"
        },
        {
          "type_long": "ghidra.program.model.address.AddressOverflowException",
          "type_short": "AddressOverflowException",
          "comment": "if the start is beyond the\n address space"
        }
      ]
    },
    {
      "name": "createBitMappedBlock",
      "comment": "Create a bit overlay memory block and add it to this Memory.",
      "javadoc": "Create a bit overlay memory block and add it to this Memory.\n@param name block name (See {@link Memory#isValidMemoryBlockName(String)} for\n naming rules)\n@param start start of the block\n@param mappedAddress start address in the source block for the\n beginning of this block\n@param length block length\n@param overlay if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space.\n@return new Bit Memory Block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if the new block overlaps with a\n previous block\n@throws MemoryConflictException if the new block overlaps with a\n previous block\n@throws AddressOverflowException if block specification exceeds bounds of address space\n@throws IllegalArgumentException if invalid block name specified",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "block name (See Memory#isValidMemoryBlockName(String) for\n naming rules)"
        },
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "start of the block"
        },
        {
          "name": "mappedAddress",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "start address in the source block for the\n beginning of this block"
        },
        {
          "name": "length",
          "type_long": "long",
          "type_short": "long",
          "comment": "block length"
        },
        {
          "name": "overlay",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "new Bit Memory Block"
      },
      "throws": [
        {
          "type_long": "ghidra.framework.store.LockException",
          "type_short": "LockException",
          "comment": "if exclusive lock not in place (see haveLock())"
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryConflictException",
          "type_short": "MemoryConflictException",
          "comment": "if the new block overlaps with a\n previous block"
        },
        {
          "type_long": "ghidra.program.model.address.AddressOverflowException",
          "type_short": "AddressOverflowException",
          "comment": "if block specification exceeds bounds of address space"
        },
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if invalid block name specified"
        }
      ]
    },
    {
      "name": "createByteMappedBlock",
      "comment": "Create a memory block that uses the bytes located at a different location with a 1:1\n byte mapping scheme.",
      "javadoc": "Create a memory block that uses the bytes located at a different location with a 1:1\n byte mapping scheme.\n@param name block name (See {@link Memory#isValidMemoryBlockName(String)} for\n naming rules)\n@param start start of the block\n@param mappedAddress start address in the source block for the\n beginning of this block\n@param length block length\n@param byteMappingScheme byte mapping scheme (may be null for 1:1 mapping)\n@param overlay if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space.\n@return new Bit Memory Block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if the new block overlaps with a previous block\n@throws AddressOverflowException if block specification exceeds bounds of address space\n@throws IllegalArgumentException if invalid block name",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "block name (See Memory#isValidMemoryBlockName(String) for\n naming rules)"
        },
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "start of the block"
        },
        {
          "name": "mappedAddress",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "start address in the source block for the\n beginning of this block"
        },
        {
          "name": "length",
          "type_long": "long",
          "type_short": "long",
          "comment": "block length"
        },
        {
          "name": "byteMappingScheme",
          "type_long": "ghidra.program.database.mem.ByteMappingScheme",
          "type_short": "ByteMappingScheme",
          "comment": "byte mapping scheme (may be null for 1:1 mapping)"
        },
        {
          "name": "overlay",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "new Bit Memory Block"
      },
      "throws": [
        {
          "type_long": "ghidra.framework.store.LockException",
          "type_short": "LockException",
          "comment": "if exclusive lock not in place (see haveLock())"
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryConflictException",
          "type_short": "MemoryConflictException",
          "comment": "if the new block overlaps with a previous block"
        },
        {
          "type_long": "ghidra.program.model.address.AddressOverflowException",
          "type_short": "AddressOverflowException",
          "comment": "if block specification exceeds bounds of address space"
        },
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if invalid block name"
        }
      ]
    },
    {
      "name": "createByteMappedBlock",
      "comment": "Create a memory block that uses the bytes located at a different location with a 1:1\n byte mapping scheme.",
      "javadoc": "Create a memory block that uses the bytes located at a different location with a 1:1\n byte mapping scheme.\n@param name block name (See {@link Memory#isValidMemoryBlockName(String)} for\n naming rules)\n@param start start of the block\n@param mappedAddress start address in the source block for the\n beginning of this block\n@param length block length\n@param overlay if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space.\n@return new Bit Memory Block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if the new block overlaps with a previous block\n@throws AddressOverflowException if block specification exceeds bounds of address space\n@throws IllegalArgumentException if invalid block name",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "block name (See Memory#isValidMemoryBlockName(String) for\n naming rules)"
        },
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "start of the block"
        },
        {
          "name": "mappedAddress",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "start address in the source block for the\n beginning of this block"
        },
        {
          "name": "length",
          "type_long": "long",
          "type_short": "long",
          "comment": "block length"
        },
        {
          "name": "overlay",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "new Bit Memory Block"
      },
      "throws": [
        {
          "type_long": "ghidra.framework.store.LockException",
          "type_short": "LockException",
          "comment": "if exclusive lock not in place (see haveLock())"
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryConflictException",
          "type_short": "MemoryConflictException",
          "comment": "if the new block overlaps with a previous block"
        },
        {
          "type_long": "ghidra.program.model.address.AddressOverflowException",
          "type_short": "AddressOverflowException",
          "comment": "if block specification exceeds bounds of address space"
        },
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if invalid block name"
        }
      ]
    },
    {
      "name": "createBlock",
      "comment": "Creates a MemoryBlock at the given address with the same properties\n as block, and adds it to this Memory.  Initialized Default blocks will\n have block filled with 0\u0027s.  Method will only create physical space blocks\n and will not create an overlay block.",
      "javadoc": "Creates a MemoryBlock at the given address with the same properties\n as block, and adds it to this Memory.  Initialized Default blocks will\n have block filled with 0\u0027s.  Method will only create physical space blocks\n and will not create an overlay block.\n@param block source block\n@param name block name (See {@link Memory#isValidMemoryBlockName(String)} for\n naming rules).\n@param start start of the block\n@param length the size of the new block.\n@return new block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if block specification conflicts with an existing block\n@throws AddressOverflowException if the new memory block would extend\n beyond the end of the address space.\n@throws IllegalArgumentException if invalid block name specifiede",
      "static": false,
      "params": [
        {
          "name": "block",
          "type_long": "ghidra.program.model.mem.MemoryBlock",
          "type_short": "MemoryBlock",
          "comment": "source block"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "block name (See Memory#isValidMemoryBlockName(String) for\n naming rules)."
        },
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "start of the block"
        },
        {
          "name": "length",
          "type_long": "long",
          "type_short": "long",
          "comment": "the size of the new block."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "new block"
      },
      "throws": [
        {
          "type_long": "ghidra.framework.store.LockException",
          "type_short": "LockException",
          "comment": "if exclusive lock not in place (see haveLock())"
        },
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if invalid block name specifiede"
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryConflictException",
          "type_short": "MemoryConflictException",
          "comment": "if block specification conflicts with an existing block"
        },
        {
          "type_long": "ghidra.program.model.address.AddressOverflowException",
          "type_short": "AddressOverflowException",
          "comment": "if the new memory block would extend\n beyond the end of the address space."
        }
      ]
    },
    {
      "name": "removeBlock",
      "comment": "Remove the memory block.",
      "javadoc": "Remove the memory block.\n@param block the block to be removed.\n@param monitor monitor that is used to cancel the remove operation\n@throws LockException if exclusive lock not in place (see haveLock())",
      "static": false,
      "params": [
        {
          "name": "block",
          "type_long": "ghidra.program.model.mem.MemoryBlock",
          "type_short": "MemoryBlock",
          "comment": "the block to be removed."
        },
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": "monitor that is used to cancel the remove operation"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.framework.store.LockException",
          "type_short": "LockException",
          "comment": "if exclusive lock not in place (see haveLock())"
        }
      ]
    },
    {
      "name": "getSize",
      "comment": "Get the memory size in bytes.",
      "javadoc": "Get the memory size in bytes.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getBlock",
      "comment": "Returns the Block which contains addr.",
      "javadoc": "Returns the Block which contains addr.\n@param addr a valid data Address.\n@return the block containing addr; null if addr is not a valid location.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "a valid data Address."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "the block containing addr; null if addr is not a valid location."
      },
      "throws": []
    },
    {
      "name": "getBlock",
      "comment": "Returns the Block with the specified blockName",
      "javadoc": "Returns the Block with the specified blockName\n@param blockName the name of the requested block\n@return the Block with the specified blockName",
      "static": false,
      "params": [
        {
          "name": "blockName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the requested block"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "the Block with the specified blockName"
      },
      "throws": []
    },
    {
      "name": "getBlocks",
      "comment": "Returns an array containing all the memory blocks.",
      "javadoc": "Returns an array containing all the memory blocks.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock[]",
        "type_short": "ghidra.program.model.mem.MemoryBlock[]",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "moveBlock",
      "comment": "Move the memory block containing source address to the destination\n address.",
      "javadoc": "Move the memory block containing source address to the destination\n address.\n@param block block to be moved\n@param newStartAddr new start address for block\n@param monitor task monitor so the move block can be canceled\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if move would cause\n blocks to overlap.\n@throws MemoryBlockException if block movement is not permitted\n@throws AddressOverflowException if new start address +\n block.getSize() would cause the Address to wrap around.\n@throws NotFoundException if memoryBlock does not exist in\n   this memory.",
      "static": false,
      "params": [
        {
          "name": "block",
          "type_long": "ghidra.program.model.mem.MemoryBlock",
          "type_short": "MemoryBlock",
          "comment": "block to be moved"
        },
        {
          "name": "newStartAddr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "new start address for block"
        },
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": "task monitor so the move block can be canceled"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.framework.store.LockException",
          "type_short": "LockException",
          "comment": "if exclusive lock not in place (see haveLock())"
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryBlockException",
          "type_short": "MemoryBlockException",
          "comment": "if block movement is not permitted"
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryConflictException",
          "type_short": "MemoryConflictException",
          "comment": "if move would cause\n blocks to overlap."
        },
        {
          "type_long": "ghidra.program.model.address.AddressOverflowException",
          "type_short": "AddressOverflowException",
          "comment": "if new start address +\n block.getSize() would cause the Address to wrap around."
        },
        {
          "type_long": "ghidra.util.exception.NotFoundException",
          "type_short": "NotFoundException",
          "comment": "if memoryBlock does not exist in\n   this memory."
        }
      ]
    },
    {
      "name": "split",
      "comment": "Split a block at the given addr and create a new block\n starting at addr.",
      "javadoc": "Split a block at the given addr and create a new block\n starting at addr.\n@param block block to be split into two\n@param addr address (within block) that will be the\n start of new block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws NotFoundException thrown if block does not exist\n in memory\n@throws MemoryBlockException memory split not permitted\n@throws AddressOutOfBoundsException thrown if address is\n not in the block",
      "static": false,
      "params": [
        {
          "name": "block",
          "type_long": "ghidra.program.model.mem.MemoryBlock",
          "type_short": "MemoryBlock",
          "comment": "block to be split into two"
        },
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "address (within block) that will be the\n start of new block"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryBlockException",
          "type_short": "MemoryBlockException",
          "comment": "memory split not permitted"
        },
        {
          "type_long": "ghidra.framework.store.LockException",
          "type_short": "LockException",
          "comment": "if exclusive lock not in place (see haveLock())"
        },
        {
          "type_long": "ghidra.util.exception.NotFoundException",
          "type_short": "NotFoundException",
          "comment": "thrown if block does not exist\n in memory"
        }
      ]
    },
    {
      "name": "join",
      "comment": "Join the two blocks to create a single memory block.\n IMPORTANT! When done, both blockOne and blockTwo should no longer be used.",
      "javadoc": "Join the two blocks to create a single memory block.\n IMPORTANT! When done, both blockOne and blockTwo should no longer be used.\n@param blockOne block to be combined with blockTwo\n@param blockTwo block to be combined with blockOne\n@return new block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryBlockException thrown if the blocks are\n not contiguous in the address space,",
      "static": false,
      "params": [
        {
          "name": "blockOne",
          "type_long": "ghidra.program.model.mem.MemoryBlock",
          "type_short": "MemoryBlock",
          "comment": "block to be combined with blockTwo"
        },
        {
          "name": "blockTwo",
          "type_long": "ghidra.program.model.mem.MemoryBlock",
          "type_short": "MemoryBlock",
          "comment": "block to be combined with blockOne"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "new block"
      },
      "throws": [
        {
          "type_long": "ghidra.framework.store.LockException",
          "type_short": "LockException",
          "comment": "if exclusive lock not in place (see haveLock())"
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryBlockException",
          "type_short": "MemoryBlockException",
          "comment": "thrown if the blocks are\n not contiguous in the address space,"
        },
        {
          "type_long": "ghidra.util.exception.NotFoundException",
          "type_short": "NotFoundException",
          "comment": ""
        }
      ]
    },
    {
      "name": "convertToInitialized",
      "comment": "Convert an existing uninitialized block with an\n initialized block.",
      "javadoc": "Convert an existing uninitialized block with an\n initialized block.\n@param unitializedBlock unitialized block to convert\n@param initialValue initial value for the bytes\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryBlockException if there is no block in memory\n at the same address as block or if the block lengths are not\n the same.",
      "static": false,
      "params": [
        {
          "name": "unitializedBlock",
          "type_long": "ghidra.program.model.mem.MemoryBlock",
          "type_short": "MemoryBlock",
          "comment": "unitialized block to convert"
        },
        {
          "name": "initialValue",
          "type_long": "byte",
          "type_short": "byte",
          "comment": "initial value for the bytes"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.framework.store.LockException",
          "type_short": "LockException",
          "comment": "if exclusive lock not in place (see haveLock())"
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryBlockException",
          "type_short": "MemoryBlockException",
          "comment": "if there is no block in memory\n at the same address as block or if the block lengths are not\n the same."
        },
        {
          "type_long": "ghidra.util.exception.NotFoundException",
          "type_short": "NotFoundException",
          "comment": ""
        }
      ]
    },
    {
      "name": "convertToUninitialized",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "itializedBlock",
          "type_long": "ghidra.program.model.mem.MemoryBlock",
          "type_short": "MemoryBlock",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryBlockException",
          "type_short": "MemoryBlockException",
          "comment": ""
        },
        {
          "type_long": "ghidra.util.exception.NotFoundException",
          "type_short": "NotFoundException",
          "comment": ""
        },
        {
          "type_long": "ghidra.framework.store.LockException",
          "type_short": "LockException",
          "comment": ""
        }
      ]
    },
    {
      "name": "findBytes",
      "comment": "Finds a sequence of contiguous bytes that match the\n given byte array at all bit positions where the mask contains an \"on\" bit.",
      "javadoc": "Finds a sequence of contiguous bytes that match the\n given byte array at all bit positions where the mask contains an \"on\" bit.\n@param addr The beginning address in memory to search.\n@param bytes the array of bytes to search for.\n@param masks the array of masks. (One for each byte in the byte array)\n              if all bits of each byte is to be checked (ie: all mask bytes are 0xff),\n              then pass a null for masks.\n@param forward if true, search in the forward direction.\n@return The address of where the first match is found. Null is returned\n if there is no match.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "The beginning address in memory to search."
        },
        {
          "name": "bytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "the array of bytes to search for."
        },
        {
          "name": "masks",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "the array of masks. (One for each byte in the byte array)\n              if all bits of each byte is to be checked (ie: all mask bytes are 0xff),\n              then pass a null for masks."
        },
        {
          "name": "forward",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true, search in the forward direction."
        },
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "The address of where the first match is found. Null is returned\n if there is no match."
      },
      "throws": []
    },
    {
      "name": "findBytes",
      "comment": "Finds a sequence of contiguous bytes that match the\n given byte array at all bit positions where the mask contains an \"on\" bit.\n Starts at startAddr and ends at endAddr.\n If forward is true, search starts at startAddr and will end if startAddr \"\" endAddr.\n If forward is false, search starts at start addr and will end if startAddr \"\" endAddr.",
      "javadoc": "Finds a sequence of contiguous bytes that match the\n given byte array at all bit positions where the mask contains an \"on\" bit.\n Starts at startAddr and ends at endAddr.\n If forward is true, search starts at startAddr and will end if startAddr \"\u0026gt;\" endAddr.\n If forward is false, search starts at start addr and will end if startAddr \"\u0026lt;\" endAddr.\n@param startAddr The beginning address in memory to search.\n@param endAddr The ending address in memory to search (inclusive).\n@param bytes the array of bytes to search for.\n@param masks the array of masks. (One for each byte in the byte array)\n              if all bits of each byte is to be checked (ie: all mask bytes are 0xff),\n              then pass a null for masks.\n@param forward if true, search in the forward direction.\n@return The address of where the first match is found. Null is returned\n if there is no match.",
      "static": false,
      "params": [
        {
          "name": "startAddr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "The beginning address in memory to search."
        },
        {
          "name": "endAddr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "The ending address in memory to search (inclusive)."
        },
        {
          "name": "bytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "the array of bytes to search for."
        },
        {
          "name": "masks",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "the array of masks. (One for each byte in the byte array)\n              if all bits of each byte is to be checked (ie: all mask bytes are 0xff),\n              then pass a null for masks."
        },
        {
          "name": "forward",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true, search in the forward direction."
        },
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "The address of where the first match is found. Null is returned\n if there is no match."
      },
      "throws": []
    },
    {
      "name": "getByte",
      "comment": "Get byte at addr.",
      "javadoc": "Get byte at addr.\n@param addr the Address of the byte.\n@return the byte.\n@throws MemoryAccessException if the address is\n not contained in any memory block.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the Address of the byte."
        }
      ],
      "return": {
        "type_long": "byte",
        "type_short": "byte",
        "comment": "the byte."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if the address is\n not contained in any memory block."
        }
      ]
    },
    {
      "name": "getBytes",
      "comment": "Get dest.length number of bytes starting at the given address.",
      "javadoc": "Get dest.length number of bytes starting at the given address.\n@param addr the starting Address.\n@param dest the byte array to populate.\n@return the number of bytes put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n@throws MemoryAccessException if the starting address is\n not contained in any memory block.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the starting Address."
        },
        {
          "name": "dest",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "the byte array to populate."
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of bytes put into dest.  May be less than\n dest.length if the requested number extends beyond available memory."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if the starting address is\n not contained in any memory block."
        }
      ]
    },
    {
      "name": "getBytes",
      "comment": "Get size number of bytes starting at the given address and populates\n dest starting at dIndex.",
      "javadoc": "Get size number of bytes starting at the given address and populates\n dest starting at dIndex.\n@param addr the starting Address.\n@param dest the byte array to populate.\n@param destIndex the offset into dest to place the bytes.\n@param size the number of bytes to get.\n@return the number of bytes put into dest.  May be less than\n size if the requested number extends beyond initialized / available memory.\n@throws MemoryAccessException if the starting address is\n not contained in any memory block or is an uninitialized location.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the starting Address."
        },
        {
          "name": "dest",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "the byte array to populate."
        },
        {
          "name": "destIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the offset into dest to place the bytes."
        },
        {
          "name": "size",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of bytes to get."
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of bytes put into dest.  May be less than\n size if the requested number extends beyond initialized / available memory."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if the starting address is\n not contained in any memory block or is an uninitialized location."
        }
      ]
    },
    {
      "name": "getShort",
      "comment": "Get the short at addr.",
      "javadoc": "Get the short at addr.\n@param addr the Address where the short starts.\n@return the short.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the Address where the short starts."
        }
      ],
      "return": {
        "type_long": "short",
        "type_short": "short",
        "comment": "the short."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if not all needed bytes are contained in initialized memory."
        }
      ]
    },
    {
      "name": "getShort",
      "comment": "Get the short at addr using the specified endian order.",
      "javadoc": "Get the short at addr using the specified endian order.\n@param addr the Address where the short starts.\n@param bigEndian true means to get the short in\n bigEndian order\n@return the short.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the Address where the short starts."
        },
        {
          "name": "bigEndian",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true means to get the short in\n bigEndian order"
        }
      ],
      "return": {
        "type_long": "short",
        "type_short": "short",
        "comment": "the short."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if not all needed bytes are contained in initialized memory."
        }
      ]
    },
    {
      "name": "getShorts",
      "comment": "Get dest.length number of shorts starting at the given address.",
      "javadoc": "Get dest.length number of shorts starting at the given address.\n@param addr the starting Address.\n@param dest the short array to populate.\n@return the number of shorts put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is odd, the final byte will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the starting Address."
        },
        {
          "name": "dest",
          "type_long": "short[]",
          "type_short": "short[]",
          "comment": "the short array to populate."
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of shorts put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is odd, the final byte will be discarded."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if not all needed bytes are contained in initialized memory."
        }
      ]
    },
    {
      "name": "getShorts",
      "comment": "Get dest.length number of shorts starting at the given address.",
      "javadoc": "Get dest.length number of shorts starting at the given address.\n@param addr the starting Address.\n@param dest the short array to populate.\n@param dIndex the offset into dest to place the shorts.\n@param nElem the number of shorts to get.\n@return the number of shorts put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is odd, the final byte will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the starting Address."
        },
        {
          "name": "dest",
          "type_long": "short[]",
          "type_short": "short[]",
          "comment": "the short array to populate."
        },
        {
          "name": "dIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the offset into dest to place the shorts."
        },
        {
          "name": "nElem",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of shorts to get."
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of shorts put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is odd, the final byte will be discarded."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if not all needed bytes are contained in initialized memory."
        }
      ]
    },
    {
      "name": "getShorts",
      "comment": "Get dest.length number of shorts starting at the given address.",
      "javadoc": "Get dest.length number of shorts starting at the given address.\n@param addr the starting Address.\n@param dest the short array to populate.\n@param dIndex the offset into dest to place the shorts.\n@param nElem the number of shorts to get.\n@param isBigEndian true means to get the shorts in\n bigEndian order\n@return the number of shorts put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is odd, the final byte will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the starting Address."
        },
        {
          "name": "dest",
          "type_long": "short[]",
          "type_short": "short[]",
          "comment": "the short array to populate."
        },
        {
          "name": "dIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the offset into dest to place the shorts."
        },
        {
          "name": "nElem",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of shorts to get."
        },
        {
          "name": "isBigEndian",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true means to get the shorts in\n bigEndian order"
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of shorts put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is odd, the final byte will be discarded."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if not all needed bytes are contained in initialized memory."
        }
      ]
    },
    {
      "name": "getInt",
      "comment": "Get the int at addr.",
      "javadoc": "Get the int at addr.\n@param addr the Address where the int starts.\n@return the int.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the Address where the int starts."
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the int."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if not all needed bytes are contained in initialized memory."
        }
      ]
    },
    {
      "name": "getInt",
      "comment": "Get the int at addr using the specified endian order.",
      "javadoc": "Get the int at addr using the specified endian order.\n@param addr the Address where the int starts.\n@param bigEndian true means to get the int in\n big endian order\n@return the int.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the Address where the int starts."
        },
        {
          "name": "bigEndian",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true means to get the int in\n big endian order"
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the int."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if not all needed bytes are contained in initialized memory."
        }
      ]
    },
    {
      "name": "getInts",
      "comment": "Get dest.length number of ints starting at the given address.",
      "javadoc": "Get dest.length number of ints starting at the given address.\n@param addr the starting Address.\n@param dest the int array to populate.\n@return the number of ints put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 4, the final byte(s) will be discarded.\n@throws MemoryAccessException if the starting address is\n not contained in any memory block.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the starting Address."
        },
        {
          "name": "dest",
          "type_long": "int[]",
          "type_short": "int[]",
          "comment": "the int array to populate."
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of ints put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 4, the final byte(s) will be discarded."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if the starting address is\n not contained in any memory block."
        }
      ]
    },
    {
      "name": "getInts",
      "comment": "Get dest.length number of ints starting at the given address.",
      "javadoc": "Get dest.length number of ints starting at the given address.\n@param addr the starting Address.\n@param dest the int array to populate.\n@param dIndex the offset into dest to place the ints.\n@param nElem the number of ints to get.\n@return the number of ints put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 4, the final byte(s) will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the starting Address."
        },
        {
          "name": "dest",
          "type_long": "int[]",
          "type_short": "int[]",
          "comment": "the int array to populate."
        },
        {
          "name": "dIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the offset into dest to place the ints."
        },
        {
          "name": "nElem",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of ints to get."
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of ints put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 4, the final byte(s) will be discarded."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if not all needed bytes are contained in initialized memory."
        }
      ]
    },
    {
      "name": "getInts",
      "comment": "Get dest.length number of ints starting at the given address.",
      "javadoc": "Get dest.length number of ints starting at the given address.\n@param addr the starting Address.\n@param dest the int array to populate.\n@param dIndex the offset into dest to place the ints.\n@param nElem the number of ints to get.\n@param isBigEndian true means to get the ints in\n bigEndian order\n@return the number of ints put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 4, the final byte(s) will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the starting Address."
        },
        {
          "name": "dest",
          "type_long": "int[]",
          "type_short": "int[]",
          "comment": "the int array to populate."
        },
        {
          "name": "dIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the offset into dest to place the ints."
        },
        {
          "name": "nElem",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of ints to get."
        },
        {
          "name": "isBigEndian",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true means to get the ints in\n bigEndian order"
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of ints put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 4, the final byte(s) will be discarded."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if not all needed bytes are contained in initialized memory."
        }
      ]
    },
    {
      "name": "getLong",
      "comment": "Get the long at addr.",
      "javadoc": "Get the long at addr.\n@param addr the Address where the long starts.\n@return the long.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the Address where the long starts."
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the long."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if not all needed bytes are contained in initialized memory."
        }
      ]
    },
    {
      "name": "getLong",
      "comment": "Get the long at addr in the specified endian order.",
      "javadoc": "Get the long at addr in the specified endian order.\n@param addr the Address where the long starts.\n@param bigEndian true means to get the long in\n big endian order\n@return the long.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the Address where the long starts."
        },
        {
          "name": "bigEndian",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true means to get the long in\n big endian order"
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the long."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if not all needed bytes are contained in initialized memory."
        }
      ]
    },
    {
      "name": "getLongs",
      "comment": "Get dest.length number of longs starting at the given address.",
      "javadoc": "Get dest.length number of longs starting at the given address.\n@param addr the starting Address.\n@param dest the long array to populate.\n@return the number of longs put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 8, the final byte(s) will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the starting Address."
        },
        {
          "name": "dest",
          "type_long": "long[]",
          "type_short": "long[]",
          "comment": "the long array to populate."
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of longs put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 8, the final byte(s) will be discarded."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if not all needed bytes are contained in initialized memory."
        }
      ]
    },
    {
      "name": "getLongs",
      "comment": "Get dest.length number of longs starting at the given address.",
      "javadoc": "Get dest.length number of longs starting at the given address.\n@param addr the starting Address.\n@param dest the long array to populate.\n@param dIndex the offset into dest to place the longs.\n@param nElem the number of longs to get.\n@return the number of longs put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 8, the final byte(s) will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the starting Address."
        },
        {
          "name": "dest",
          "type_long": "long[]",
          "type_short": "long[]",
          "comment": "the long array to populate."
        },
        {
          "name": "dIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the offset into dest to place the longs."
        },
        {
          "name": "nElem",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of longs to get."
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of longs put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 8, the final byte(s) will be discarded."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if not all needed bytes are contained in initialized memory."
        }
      ]
    },
    {
      "name": "getLongs",
      "comment": "Get dest.length number of longs starting at the given address.",
      "javadoc": "Get dest.length number of longs starting at the given address.\n@param addr the starting Address.\n@param dest the long array to populate.\n@param dIndex the offset into dest to place the longs.\n@param nElem the number of longs to get.\n@param isBigEndian true means to get the longs in\n bigEndian order\n@return the number of longs put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 8, the final byte(s) will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the starting Address."
        },
        {
          "name": "dest",
          "type_long": "long[]",
          "type_short": "long[]",
          "comment": "the long array to populate."
        },
        {
          "name": "dIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the offset into dest to place the longs."
        },
        {
          "name": "nElem",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of longs to get."
        },
        {
          "name": "isBigEndian",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true means to get the longs in\n bigEndian order"
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of longs put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 8, the final byte(s) will be discarded."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if not all needed bytes are contained in initialized memory."
        }
      ]
    },
    {
      "name": "setByte",
      "comment": "Write byte at addr.",
      "javadoc": "Write byte at addr.\n@param addr the Address of the byte.\n@param value the data to write.\n@throws MemoryAccessException if writing is not allowed.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the Address of the byte."
        },
        {
          "name": "value",
          "type_long": "byte",
          "type_short": "byte",
          "comment": "the data to write."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if writing is not allowed."
        }
      ]
    },
    {
      "name": "setBytes",
      "comment": "Write size bytes from values at addr.",
      "javadoc": "Write size bytes from values at addr.\n@param addr the starting Address.\n@param source the bytes to write.\n@throws MemoryAccessException if writing is not allowed.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the starting Address."
        },
        {
          "name": "source",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "the bytes to write."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if writing is not allowed."
        }
      ]
    },
    {
      "name": "setBytes",
      "comment": "Write an array of bytes.  This should copy size bytes or fail!",
      "javadoc": "Write an array of bytes.  This should copy size bytes or fail!\n@param addr the starting Address of the bytes.\n@param source an array to get bytes from.\n@param sIndex the starting source index.\n@param size the number of bytes to fill.\n@throws MemoryAccessException if writing is not allowed.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the starting Address of the bytes."
        },
        {
          "name": "source",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "an array to get bytes from."
        },
        {
          "name": "sIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the starting source index."
        },
        {
          "name": "size",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of bytes to fill."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if writing is not allowed."
        }
      ]
    },
    {
      "name": "setShort",
      "comment": "Write short at addr in big endian order.",
      "javadoc": "Write short at addr in big endian order.\n@param addr the Address of the short.\n@param value the data to write.\n@throws MemoryAccessException if writing is not allowed.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the Address of the short."
        },
        {
          "name": "value",
          "type_long": "short",
          "type_short": "short",
          "comment": "the data to write."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if writing is not allowed."
        }
      ]
    },
    {
      "name": "setShort",
      "comment": "Write short at addr in the specified endian order.",
      "javadoc": "Write short at addr in the specified endian order.\n@param addr the Address of the short.\n@param value the data to write.\n@param bigEndian true means to write short in\n big endian order\n@throws MemoryAccessException if writing is not allowed.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the Address of the short."
        },
        {
          "name": "value",
          "type_long": "short",
          "type_short": "short",
          "comment": "the data to write."
        },
        {
          "name": "bigEndian",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true means to write short in\n big endian order"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if writing is not allowed."
        }
      ]
    },
    {
      "name": "setInt",
      "comment": "Write int at addr.",
      "javadoc": "Write int at addr.\n@param addr the Address of the int.\n@param value the data to write.\n@throws MemoryAccessException if writing is not allowed.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the Address of the int."
        },
        {
          "name": "value",
          "type_long": "int",
          "type_short": "int",
          "comment": "the data to write."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if writing is not allowed."
        }
      ]
    },
    {
      "name": "setInt",
      "comment": "Write int at addr in the specified endian order.",
      "javadoc": "Write int at addr in the specified endian order.\n@param addr the Address of the int.\n@param bigEndian true means to write the short in\n bigEndian order\n@param value the data to write.\n@throws MemoryAccessException if writing is not allowed.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the Address of the int."
        },
        {
          "name": "value",
          "type_long": "int",
          "type_short": "int",
          "comment": "the data to write."
        },
        {
          "name": "bigEndian",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true means to write the short in\n bigEndian order"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if writing is not allowed."
        }
      ]
    },
    {
      "name": "setLong",
      "comment": "Write long at addr.",
      "javadoc": "Write long at addr.\n@param addr the Address of the long.\n@param value the data to write.\n@throws MemoryAccessException if writing is not allowed.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the Address of the long."
        },
        {
          "name": "value",
          "type_long": "long",
          "type_short": "long",
          "comment": "the data to write."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if writing is not allowed."
        }
      ]
    },
    {
      "name": "setLong",
      "comment": "Write long at addr in the specified endian order.",
      "javadoc": "Write long at addr in the specified endian order.\n@param addr the Address of the long.\n@param value the data to write.\n@param bigEndian true means to write the long in\n bigEndian order\n@throws MemoryAccessException if writing is not allowed.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the Address of the long."
        },
        {
          "name": "value",
          "type_long": "long",
          "type_short": "long",
          "comment": "the data to write."
        },
        {
          "name": "bigEndian",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true means to write the long in\n bigEndian order"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if writing is not allowed."
        }
      ]
    },
    {
      "name": "createFileBytes",
      "comment": "Stores a sequence of bytes into the program.  Typically, this method is used by importers\n to store the original raw program bytes.",
      "javadoc": "Stores a sequence of bytes into the program.  Typically, this method is used by importers\n to store the original raw program bytes.\n@param filename the name of the file from where the bytes originated\n@param offset the offset into the file for the first byte in the input stream.\n@param size the number of bytes to store from the input stream.\n@param is the input stream that will supply the bytes to store in the program.\n@param monitor\n@return a FileBytes that was created to access the bytes.\n@throws IOException if there was an IOException saving the bytes to the program database.\n@throws CancelledException if the user cancelled this operation. Note: the database will\n be stable, but the buffers may contain 0s instead of the actual bytes.",
      "static": false,
      "params": [
        {
          "name": "filename",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the file from where the bytes originated"
        },
        {
          "name": "offset",
          "type_long": "long",
          "type_short": "long",
          "comment": "the offset into the file for the first byte in the input stream."
        },
        {
          "name": "size",
          "type_long": "long",
          "type_short": "long",
          "comment": "the number of bytes to store from the input stream."
        },
        {
          "name": "is",
          "type_long": "java.io.InputStream",
          "type_short": "InputStream",
          "comment": "the input stream that will supply the bytes to store in the program."
        },
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.database.mem.FileBytes",
        "type_short": "FileBytes",
        "comment": "a FileBytes that was created to access the bytes."
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if there was an IOException saving the bytes to the program database."
        },
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": "if the user cancelled this operation. Note: the database will\n be stable, but the buffers may contain 0s instead of the actual bytes."
        }
      ]
    },
    {
      "name": "getAllFileBytes",
      "comment": "Returns a list of all the stored original file bytes objects",
      "javadoc": "Returns a list of all the stored original file bytes objects\n@return a list of all the stored original file bytes objects",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.List\u003cghidra.program.database.mem.FileBytes\u003e",
        "type_short": "List",
        "comment": "a list of all the stored original file bytes objects"
      },
      "throws": []
    },
    {
      "name": "deleteFileBytes",
      "comment": "Deletes a stored sequence of file bytes.  The file bytes can only be deleted if there\n are no memory block references to the file bytes.",
      "javadoc": "Deletes a stored sequence of file bytes.  The file bytes can only be deleted if there\n are no memory block references to the file bytes.\n@param fileBytes the FileBytes for the file bytes to be deleted.\n@return true if the FileBytes was deleted.  If any memory blocks are referenced by this \n FileBytes or it is invalid then it will not be deleted and false will be returned.\n@throws IOException if there was an error updating the database.",
      "static": false,
      "params": [
        {
          "name": "fileBytes",
          "type_long": "ghidra.program.database.mem.FileBytes",
          "type_short": "FileBytes",
          "comment": "the FileBytes for the file bytes to be deleted."
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the FileBytes was deleted.  If any memory blocks are referenced by this \n FileBytes or it is invalid then it will not be deleted and false will be returned."
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if there was an error updating the database."
        }
      ]
    },
    {
      "name": "getAddressSourceInfo",
      "comment": "Returns information (AddressSourceInfo) about the byte source at the given address.",
      "javadoc": "Returns information ({@link AddressSourceInfo}) about the byte source at the given address.\n@param address the address to query. Returns null if the address is not in memory.\n@return information ({@link AddressSourceInfo}) about the byte source at the given address or\n null if the address is not in memory.",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to query. Returns null if the address is not in memory."
        }
      ],
      "return": {
        "type_long": "ghidra.program.database.mem.AddressSourceInfo",
        "type_short": "AddressSourceInfo",
        "comment": "information (AddressSourceInfo) about the byte source at the given address or\n null if the address is not in memory."
      },
      "throws": []
    },
    {
      "name": "isValidMemoryBlockName",
      "comment": "Validate the given block name: cannot be null, cannot be an empty string, \n cannot contain control characters (ASCII 0..0x19).\n \n NOTE: When producing an overlay memory space which corresponds to a block, the space\n name will be modified to be consistent with address space name restrictions\n and to ensure uniqueness.",
      "javadoc": "Validate the given block name: cannot be null, cannot be an empty string, \n cannot contain control characters (ASCII 0..0x19).\n \u003cBR\u003e\n NOTE: When producing an overlay memory space which corresponds to a block, the space\n name will be modified to be consistent with address space name restrictions\n and to ensure uniqueness.\n@param name memory block name\n@return true if name is valid else false",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "memory block name"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if name is valid else false"
      },
      "throws": []
    },
    {
      "name": "locateAddressesForFileOffset",
      "comment": "Gets a List of Address that correspond to the given file offset.",
      "javadoc": "Gets a {@link List} of {@link Address addresses} that correspond to the given file offset.\n@param fileOffset the file offset that will be used to locate the corresponding memory \n   addresses\n@return a {@link List} of {@link Address}es that are associated with the provided file offset",
      "static": false,
      "params": [
        {
          "name": "fileOffset",
          "type_long": "long",
          "type_short": "long",
          "comment": "the file offset that will be used to locate the corresponding memory \n   addresses"
        }
      ],
      "return": {
        "type_long": "java.util.List\u003cghidra.program.model.address.Address\u003e",
        "type_short": "List",
        "comment": "a List of Addresses that are associated with the provided file offset"
      },
      "throws": []
    },
    {
      "name": "locateAddressesForFileBytesOffset",
      "comment": "Gets a list of addresses where the byte at the given offset\n from the given FileBytes was loaded into memory.",
      "javadoc": "Gets a list of addresses where the byte at the given offset\n from the given FileBytes was loaded into memory.\n@param offset the file offset in the given FileBytes of the byte that is to be \n located in memory\n@param fileBytes the FileBytesobject whose byte is to be located in memory\n@return a list of addresses that are associated with the given\n FileBytes and offset",
      "static": false,
      "params": [
        {
          "name": "fileBytes",
          "type_long": "ghidra.program.database.mem.FileBytes",
          "type_short": "FileBytes",
          "comment": "the FileBytesobject whose byte is to be located in memory"
        },
        {
          "name": "offset",
          "type_long": "long",
          "type_short": "long",
          "comment": "the file offset in the given FileBytes of the byte that is to be \n located in memory"
        }
      ],
      "return": {
        "type_long": "java.util.List\u003cghidra.program.model.address.Address\u003e",
        "type_short": "List",
        "comment": "a list of addresses that are associated with the given\n FileBytes and offset"
      },
      "throws": []
    }
  ]
}
