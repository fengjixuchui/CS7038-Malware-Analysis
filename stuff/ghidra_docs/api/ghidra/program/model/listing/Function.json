{
  "name": "Function",
  "comment": "Interface to define methods available on a function. Functions have a single entry point.",
  "javadoc": "Interface to define methods available on a function. Functions have a single entry point.",
  "static": false,
  "implements": [
    "ghidra.program.model.symbol.Namespace"
  ],
  "fields": [
    {
      "name": "DEFAULT_PARAM_PREFIX",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"param_\""
    },
    {
      "name": "THIS_PARAM_NAME",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": null
    },
    {
      "name": "RETURN_PTR_PARAM_NAME",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": null
    },
    {
      "name": "DEFAULT_PARAM_PREFIX_LEN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "DEFAULT_LOCAL_PREFIX",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"local_\""
    },
    {
      "name": "DEFAULT_LOCAL_RESERVED_PREFIX",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"local_res\""
    },
    {
      "name": "DEFAULT_LOCAL_TEMP_PREFIX",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"temp_\""
    },
    {
      "name": "DEFAULT_LOCAL_PREFIX_LEN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "UNKNOWN_CALLING_CONVENTION_STRING",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"unknown\""
    },
    {
      "name": "DEFAULT_CALLING_CONVENTION_STRING",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"default\""
    },
    {
      "name": "INLINE",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"inline\""
    },
    {
      "name": "NORETURN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"noreturn\""
    },
    {
      "name": "THUNK",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"thunk\""
    },
    {
      "name": "UNKNOWN_STACK_DEPTH_CHANGE",
      "comment": "Default Stack depth for a function.",
      "javadoc": "Default Stack depth for a function.",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "2147483647"
    },
    {
      "name": "INVALID_STACK_DEPTH_CHANGE",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "2147483646"
    }
  ],
  "methods": [
    {
      "name": "getName",
      "comment": "Get the name of this function.",
      "javadoc": "Get the name of this function.\n@return the functions name",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the functions name"
      },
      "throws": []
    },
    {
      "name": "setName",
      "comment": "Set the name of this function.",
      "javadoc": "Set the name of this function.\n@param name the new name of the function\n@param source the source of this function name\n@throws DuplicateNameException if the name is used by some other symbol\n@throws InvalidInputException if the name is not a valid function name.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the new name of the function"
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source of this function name"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "if the name is used by some other symbol"
        },
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if the name is not a valid function name."
        }
      ]
    },
    {
      "name": "setCallFixup",
      "comment": "Set the named call-fixup for this function.",
      "javadoc": "Set the named call-fixup for this function.\n@param name name of call-fixup specified by compiler spec.  A null\n value will clear the current setting.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "name of call-fixup specified by compiler spec.  A null\n value will clear the current setting."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getCallFixup",
      "comment": "Returns the current call-fixup name set on this instruction or null if one has not been set",
      "javadoc": "Returns the current call-fixup name set on this instruction or null if one has not been set\n@return the name",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the name"
      },
      "throws": []
    },
    {
      "name": "getProgram",
      "comment": "Get the program containing this function.",
      "javadoc": "Get the program containing this function.\n@return the program",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Program",
        "type_short": "Program",
        "comment": "the program"
      },
      "throws": []
    },
    {
      "name": "getComment",
      "comment": "Get the comment for this function.",
      "javadoc": "Get the comment for this function.\n@return the comment for this function",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the comment for this function"
      },
      "throws": []
    },
    {
      "name": "getCommentAsArray",
      "comment": "Returns the function (same as plate) comment as an array of strings where\n each item in the array is a line of text in the comment.",
      "javadoc": "Returns the function (same as plate) comment as an array of strings where\n each item in the array is a line of text in the comment.\n@return the comments",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String[]",
        "type_short": "java.lang.String[]",
        "comment": "the comments"
      },
      "throws": []
    },
    {
      "name": "setComment",
      "comment": "Set the comment for this function.",
      "javadoc": "Set the comment for this function.\n@param comment the string to set as the comment.",
      "static": false,
      "params": [
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the string to set as the comment."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getRepeatableComment",
      "comment": "Returns the repeatable comment for this function.\n A repeatable comment is a comment that will appear\n at locations that \u0027call\u0027 this function.",
      "javadoc": "Returns the repeatable comment for this function.\n A repeatable comment is a comment that will appear\n at locations that \u0027call\u0027 this function.\n@return the repeatable comment for this function",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the repeatable comment for this function"
      },
      "throws": []
    },
    {
      "name": "getRepeatableCommentAsArray",
      "comment": "Returns the repeatable comment as an array of strings.",
      "javadoc": "Returns the repeatable comment as an array of strings.\n@return the repeatable comment as an array of strings",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String[]",
        "type_short": "java.lang.String[]",
        "comment": "the repeatable comment as an array of strings"
      },
      "throws": []
    },
    {
      "name": "setRepeatableComment",
      "comment": "Set the repeatable comment for this function.",
      "javadoc": "Set the repeatable comment for this function.\n@param comment the string to set as the repeatable comment.",
      "static": false,
      "params": [
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the string to set as the repeatable comment."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getEntryPoint",
      "comment": "Get the entry point for this function.\n Functions may only have ONE entry point.",
      "javadoc": "Get the entry point for this function.\n Functions may only have ONE entry point.\n@return the entry point",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "the entry point"
      },
      "throws": []
    },
    {
      "name": "getReturnType",
      "comment": "Get the Function\u0027s return type.\n A null return value indicates the functions return type has never been set.",
      "javadoc": "Get the Function\u0027s return type.\n A null return value indicates the functions return type has never been set.\n@return the DataType that this function returns.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.data.DataType",
        "type_short": "DataType",
        "comment": "the DataType that this function returns."
      },
      "throws": []
    },
    {
      "name": "setReturnType",
      "comment": "Set the function\u0027s return type.",
      "javadoc": "Set the function\u0027s return type.\n@param type the dataType that will define this functions return type.\n@param source TODO\n@throws InvalidInputException if data type is not a fixed length.",
      "static": false,
      "params": [
        {
          "name": "type",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the dataType that will define this functions return type."
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "TODO"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if data type is not a fixed length."
        }
      ]
    },
    {
      "name": "getReturn",
      "comment": "Get the Function\u0027s return type/storage represented by a Parameter \n object.  The parameter\u0027s ordinal value will be equal to\n Parameter.RETURN_ORIDINAL.",
      "javadoc": "Get the Function\u0027s return type/storage represented by a Parameter \n object.  The parameter\u0027s ordinal value will be equal to\n Parameter.RETURN_ORIDINAL.\n@return return data-type/storage",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Parameter",
        "type_short": "Parameter",
        "comment": "return data-type/storage"
      },
      "throws": []
    },
    {
      "name": "setReturn",
      "comment": "Set the return data-type and storage.\n \n NOTE: The storage and source are ignored if the function does not have custom storage \n enabled.",
      "javadoc": "Set the return data-type and storage.\n \n \u003cp\u003eNOTE: The storage and source are ignored if the function does not have custom storage \n enabled.\n@param type the data type\n@param storage the storage\n@param source source to be combined with the overall signature source.\n@throws InvalidInputException if data type is not a fixed length or storage is improperly \n         sized",
      "static": false,
      "params": [
        {
          "name": "type",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the data type"
        },
        {
          "name": "storage",
          "type_long": "ghidra.program.model.listing.VariableStorage",
          "type_short": "VariableStorage",
          "comment": "the storage"
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "source to be combined with the overall signature source."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if data type is not a fixed length or storage is improperly \n         sized"
        }
      ]
    },
    {
      "name": "getSignature",
      "comment": "Get the function\u0027s effective signature.\n This is equivalent to invoking getSignature(false) where auto-params and \n forced-indirect types will be reflected in the signature if present.\n WARNING! It is important to note that the calling convention may not be properly retained \n by the returned signature object if a non-generic calling convention is used by this function as \n defined by the program\u0027s compiler specification.",
      "javadoc": "Get the function\u0027s effective signature.\n This is equivalent to invoking \u003ccode\u003egetSignature(false)\u003c/code\u003e where auto-params and \n forced-indirect types will be reflected in the signature if present.\n \u003cbr\u003e\u003cbr\u003eWARNING! It is important to note that the calling convention may not be properly retained \n by the returned signature object if a non-generic calling convention is used by this function as \n defined by the program\u0027s compiler specification.\n@return the function\u0027s signature",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.FunctionSignature",
        "type_short": "FunctionSignature",
        "comment": "the function\u0027s signature"
      },
      "throws": []
    },
    {
      "name": "getSignature",
      "comment": "Get the function\u0027s signature.\n WARNING! It is important to note that the calling convention may not be properly \n retained by the returned signature object if a non-generic calling convention is used by \n this function as defined by the program\u0027s compiler specification.",
      "javadoc": "Get the function\u0027s signature.\n \u003cbr\u003e\u003cbr\u003eWARNING! It is important to note that the calling convention may not be properly \n retained by the returned signature object if a non-generic calling convention is used by \n this function as defined by the program\u0027s compiler specification.\n@param formalSignature if true only original raw types will be retained and \n auto-params discarded (e.g., this, __return_storage_ptr__, etc.) within the returned \n signature.  If false, the effective signature will be returned where forced indirect \n and auto-params are reflected in the signature.  This option has no affect if the specified \n function has custom storage enabled.\n@return the function\u0027s signature",
      "static": false,
      "params": [
        {
          "name": "formalSignature",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true only original raw types will be retained and \n auto-params discarded (e.g., this, __return_storage_ptr__, etc.) within the returned \n signature.  If false, the effective signature will be returned where forced indirect \n and auto-params are reflected in the signature.  This option has no affect if the specified \n function has custom storage enabled."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.FunctionSignature",
        "type_short": "FunctionSignature",
        "comment": "the function\u0027s signature"
      },
      "throws": []
    },
    {
      "name": "getPrototypeString",
      "comment": "Return a string representation of the function signature",
      "javadoc": "Return a string representation of the function signature\n@param formalSignature if true only original raw return/parameter types will be retained and \n auto-params discarded (e.g., this, __return_storage_ptr__, etc.) within the returned \n signature.  If false, the effective signature will be returned where forced indirect \n and auto-params are reflected in the signature.  This option has no affect if the specified \n function has custom storage enabled.\n@param includeCallingConvention if true prototype will include call convention\n declaration if known.\n@return the prototype",
      "static": false,
      "params": [
        {
          "name": "formalSignature",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true only original raw return/parameter types will be retained and \n auto-params discarded (e.g., this, __return_storage_ptr__, etc.) within the returned \n signature.  If false, the effective signature will be returned where forced indirect \n and auto-params are reflected in the signature.  This option has no affect if the specified \n function has custom storage enabled."
        },
        {
          "name": "includeCallingConvention",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true prototype will include call convention\n declaration if known."
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the prototype"
      },
      "throws": []
    },
    {
      "name": "getSignatureSource",
      "comment": "Returns the source type for the overall signature excluding function name and parameter names \n whose source is carried by the corresponding symbol.",
      "javadoc": "Returns the source type for the overall signature excluding function name and parameter names \n whose source is carried by the corresponding symbol.\n@return the overall SourceType of the function signature;",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.symbol.SourceType",
        "type_short": "SourceType",
        "comment": "the overall SourceType of the function signature;"
      },
      "throws": []
    },
    {
      "name": "setSignatureSource",
      "comment": "Set the source type for the overall signature excluding function name and parameter names \n whose source is carried by the corresponding symbol.",
      "javadoc": "Set the source type for the overall signature excluding function name and parameter names \n whose source is carried by the corresponding symbol.\n@param signatureSource function signature source type",
      "static": false,
      "params": [
        {
          "name": "signatureSource",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "function signature source type"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getStackFrame",
      "comment": "Get the stack frame for this function.\n NOTE: Use of the stack frame must be avoided during upgrade activity since\n the compiler spec may not be known (i.e., due to language upgrade process).",
      "javadoc": "Get the stack frame for this function.\n NOTE: Use of the stack frame must be avoided during upgrade activity since\n the compiler spec may not be known (i.e., due to language upgrade process).\n@return this functions stack frame",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.StackFrame",
        "type_short": "StackFrame",
        "comment": "this functions stack frame"
      },
      "throws": []
    },
    {
      "name": "getStackPurgeSize",
      "comment": "Get the change in the stack pointer resulting from calling\n  this function.",
      "javadoc": "Get the change in the stack pointer resulting from calling\n  this function.\n@return int the change in bytes to the stack pointer",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "int the change in bytes to the stack pointer"
      },
      "throws": []
    },
    {
      "name": "getTags",
      "comment": "Return all FunctionTag objects associated with this function.",
      "javadoc": "Return all {@link FunctionTag} objects associated with this function.\n@return set of tag names",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.Set\u003cghidra.program.model.listing.FunctionTag\u003e",
        "type_short": "Set",
        "comment": "set of tag names"
      },
      "throws": []
    },
    {
      "name": "addTag",
      "comment": "Adds the tag with the given name to this function; if one does\n not exist, one is created.",
      "javadoc": "Adds the tag with the given name to this function; if one does\n not exist, one is created.\n@param name the tag name to add\n@return true if the tag was successfully added",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the tag name to add"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the tag was successfully added"
      },
      "throws": []
    },
    {
      "name": "removeTag",
      "comment": "Removes the given tag from this function.",
      "javadoc": "Removes the given tag from this function.\n@param name the tag name to be removed.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the tag name to be removed."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "setStackPurgeSize",
      "comment": "Set the change in the stack pointer resulting from calling\n this function.",
      "javadoc": "Set the change in the stack pointer resulting from calling\n this function.\n@param purgeSize the change in bytes to the stack pointer",
      "static": false,
      "params": [
        {
          "name": "purgeSize",
          "type_long": "int",
          "type_short": "int",
          "comment": "the change in bytes to the stack pointer"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isStackPurgeSizeValid",
      "comment": "check if stack purge size is valid.",
      "javadoc": "check if stack purge size is valid.\n@return true if the stack depth is valid",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the stack depth is valid"
      },
      "throws": []
    },
    {
      "name": "addParameter",
      "comment": "Adds the given variable to the end of the parameters list.  The variable storage specified\n for the new parameter will be ignored if custom storage mode is not enabled.\n The VariableUtilities#checkVariableConflict(Function, Variable, VariableStorage, boolean) \n method may be used to check and remove conflicting variables which already exist in the function.",
      "javadoc": "Adds the given variable to the end of the parameters list.  The variable storage specified\n for the new parameter will be ignored if custom storage mode is not enabled.\n The {@link VariableUtilities#checkVariableConflict(Function, Variable, VariableStorage, boolean)} \n method may be used to check and remove conflicting variables which already exist in the function.\n@param var the variable to add as a new parameter.\n@param source the source of this parameter which will be applied to the parameter symbol and \n overall function signature source.  If parameter has a null or default name a SourceType of DEFAULT\n will be applied to the parameter symbol.\n@return the Parameter object created.\n@throws DuplicateNameException if another variable(parameter or local) already\n exists in the function with that name.\n@throws InvalidInputException if data type is not a fixed length or variable name is invalid.\n@throws VariableSizeException if data type size is too large based upon storage constraints.\n@deprecated The use of this method is discouraged due to the potential injection of auto-parameters\n which are easily overlooked when considering parameter ordinal.  The function signature should generally be \n adjusted with a single call to {@link #updateFunction(String, Variable, List, FunctionUpdateType, boolean, SourceType)}",
      "static": false,
      "params": [
        {
          "name": "var",
          "type_long": "ghidra.program.model.listing.Variable",
          "type_short": "Variable",
          "comment": "the variable to add as a new parameter."
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source of this parameter which will be applied to the parameter symbol and \n overall function signature source.  If parameter has a null or default name a SourceType of DEFAULT\n will be applied to the parameter symbol."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Parameter",
        "type_short": "Parameter",
        "comment": "the Parameter object created."
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "if another variable(parameter or local) already\n exists in the function with that name."
        },
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if data type is not a fixed length or variable name is invalid."
        }
      ]
    },
    {
      "name": "insertParameter",
      "comment": "Inserts the given variable into the parameters list.  The variable storage specified\n for the new parameter will be ignored if custom storage mode is not enabled.\n The VariableUtilities#checkVariableConflict(Function, Variable, VariableStorage, boolean) \n method may be used to check and remove conflicting variables which already exist in the function.",
      "javadoc": "Inserts the given variable into the parameters list.  The variable storage specified\n for the new parameter will be ignored if custom storage mode is not enabled.\n The {@link VariableUtilities#checkVariableConflict(Function, Variable, VariableStorage, boolean)} \n method may be used to check and remove conflicting variables which already exist in the function.\n@param ordinal the position with the parameters to insert to.  This ordinal must factor in the\n presence of auto-parameters which may be injected dynamically based upon calling convention and\n return data type.  Parameters may not be inserted befor an auto-parameter.\n@param var the variable to add as a new parameter.\n@param source the source of this parameter which will be applied to the parameter symbol and \n overall function signature source.  If parameter has a null or default name a SourceType of DEFAULT\n will be applied to the parameter symbol.\n@return the Parameter object created.\n@throws DuplicateNameException if another variable(parameter or local) already\n exists in the function with that name.\n@throws InvalidInputException if data type is not a fixed length or variable name is invalid.\n@throws VariableSizeException if data type size is too large based upon storage constraints.\n@deprecated The use of this method is discouraged due to the potential injection of auto-parameters\n which are easily overlooked when considering parameter ordinal.  The function signature should generally be \n adjusted with a single call to {@link #updateFunction(String, Variable, List, FunctionUpdateType, boolean, SourceType)}",
      "static": false,
      "params": [
        {
          "name": "ordinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "the position with the parameters to insert to.  This ordinal must factor in the\n presence of auto-parameters which may be injected dynamically based upon calling convention and\n return data type.  Parameters may not be inserted befor an auto-parameter."
        },
        {
          "name": "var",
          "type_long": "ghidra.program.model.listing.Variable",
          "type_short": "Variable",
          "comment": "the variable to add as a new parameter."
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source of this parameter which will be applied to the parameter symbol and \n overall function signature source.  If parameter has a null or default name a SourceType of DEFAULT\n will be applied to the parameter symbol."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Parameter",
        "type_short": "Parameter",
        "comment": "the Parameter object created."
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "if another variable(parameter or local) already\n exists in the function with that name."
        },
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if data type is not a fixed length or variable name is invalid."
        }
      ]
    },
    {
      "name": "replaceParameters",
      "comment": "Replace all current parameters with the given list of parameters.\n The VariableUtilities#checkVariableConflict(Function, Variable, VariableStorage, boolean) \n method may be used to check and remove conflicting variables which already exist in the function.",
      "javadoc": "Replace all current parameters with the given list of parameters.\n The {@link VariableUtilities#checkVariableConflict(Function, Variable, VariableStorage, boolean)} \n method may be used to check and remove conflicting variables which already exist in the function.\n@param params the new set of parameters for the function.\n@param updateType function update type\n@param force if true any conflicting local parameters will be removed\n@param source the source of these parameters which will be applied to the parameter symbols and \n overall function signature source.  If parameter names are null or a default name a SourceType of DEFAULT\n will be applied to the corresponding parameter symbol.\n@throws DuplicateNameException if another variable(parameter or local) already\n exists in the function with that name.\n@throws InvalidInputException if a parameter data type is not a fixed length or variable name is invalid.\n@throws VariableSizeException if a parameter data type size is too large based upon storage constraints\n or conflicts with another variable.",
      "static": false,
      "params": [
        {
          "name": "params",
          "type_long": "java.util.List\u003c? extends ghidra.program.model.listing.Variable\u003e",
          "type_short": "List",
          "comment": "the new set of parameters for the function."
        },
        {
          "name": "updateType",
          "type_long": "ghidra.program.model.listing.Function.FunctionUpdateType",
          "type_short": "FunctionUpdateType",
          "comment": "function update type"
        },
        {
          "name": "force",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true any conflicting local parameters will be removed"
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source of these parameters which will be applied to the parameter symbols and \n overall function signature source.  If parameter names are null or a default name a SourceType of DEFAULT\n will be applied to the corresponding parameter symbol."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "if another variable(parameter or local) already\n exists in the function with that name."
        },
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if a parameter data type is not a fixed length or variable name is invalid."
        }
      ]
    },
    {
      "name": "replaceParameters",
      "comment": "Replace all current parameters with the given list of parameters.\n The VariableUtilities#checkVariableConflict(Function, Variable, VariableStorage, boolean) \n method may be used to check and remove conflicting variables which already exist in the function.",
      "javadoc": "Replace all current parameters with the given list of parameters.\n The {@link VariableUtilities#checkVariableConflict(Function, Variable, VariableStorage, boolean)} \n method may be used to check and remove conflicting variables which already exist in the function.\n@param updateType function update type\n@param force if true any conflicting local parameters will be removed\n@param source the source of these parameters which will be applied to the parameter symbols and \n overall function signature source.  If parameter names are null or a default name a SourceType of DEFAULT\n will be applied to the corresponding parameter symbol.\n@param params the new parameters for the function.\n@throws DuplicateNameException if another variable(parameter or local) already\n exists in the function with that name.\n@throws InvalidInputException if a parameter data type is not a fixed length or variable name is invalid.\n@throws VariableSizeException if a parameter data type size is too large based upon storage constraints\n or conflicts with another variable.",
      "static": false,
      "params": [
        {
          "name": "updateType",
          "type_long": "ghidra.program.model.listing.Function.FunctionUpdateType",
          "type_short": "FunctionUpdateType",
          "comment": "function update type"
        },
        {
          "name": "force",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true any conflicting local parameters will be removed"
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source of these parameters which will be applied to the parameter symbols and \n overall function signature source.  If parameter names are null or a default name a SourceType of DEFAULT\n will be applied to the corresponding parameter symbol."
        },
        {
          "name": "params",
          "type_long": "ghidra.program.model.listing.Variable[]",
          "type_short": "ghidra.program.model.listing.Variable[]",
          "comment": "the new parameters for the function."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "if another variable(parameter or local) already\n exists in the function with that name."
        },
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if a parameter data type is not a fixed length or variable name is invalid."
        }
      ]
    },
    {
      "name": "updateFunction",
      "comment": "Replace all current parameters with the given list of parameters and optionally change the calling convention\n and function return.\n The VariableUtilities#checkVariableConflict(Function, Variable, VariableStorage, boolean) \n method may be used to check and remove conflicting variables which already exist in the function.",
      "javadoc": "Replace all current parameters with the given list of parameters and optionally change the calling convention\n and function return.\n The {@link VariableUtilities#checkVariableConflict(Function, Variable, VariableStorage, boolean)} \n method may be used to check and remove conflicting variables which already exist in the function.\n@param callingConvention updated calling convention name or null if no change is required\n@param returnValue return variable or null if no change required\n@param updateType function update type\n@param force if true any conflicting local parameters will be removed\n@param source the source of these parameters which will be applied to the parameter symbols and \n overall function signature source.  If parameter names are null or a default name a SourceType of DEFAULT\n will be applied to the corresponding parameter symbol.\n@param newParams a variable number of parameters for the function.\n@throws DuplicateNameException if another variable(parameter or local) already\n exists in the function with that name.\n@throws InvalidInputException if a parameter data type is not a fixed length or variable name is invalid.\n@throws VariableSizeException if a parameter data type size is too large based upon storage constraints\n or conflicts with another variable.",
      "static": false,
      "params": [
        {
          "name": "callingConvention",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "updated calling convention name or null if no change is required"
        },
        {
          "name": "returnValue",
          "type_long": "ghidra.program.model.listing.Variable",
          "type_short": "Variable",
          "comment": "return variable or null if no change required"
        },
        {
          "name": "updateType",
          "type_long": "ghidra.program.model.listing.Function.FunctionUpdateType",
          "type_short": "FunctionUpdateType",
          "comment": "function update type"
        },
        {
          "name": "force",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true any conflicting local parameters will be removed"
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source of these parameters which will be applied to the parameter symbols and \n overall function signature source.  If parameter names are null or a default name a SourceType of DEFAULT\n will be applied to the corresponding parameter symbol."
        },
        {
          "name": "newParams",
          "type_long": "ghidra.program.model.listing.Variable[]",
          "type_short": "ghidra.program.model.listing.Variable[]",
          "comment": "a variable number of parameters for the function."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "if another variable(parameter or local) already\n exists in the function with that name."
        },
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if a parameter data type is not a fixed length or variable name is invalid."
        }
      ]
    },
    {
      "name": "updateFunction",
      "comment": "Replace all current parameters with the given list of parameters and optionally change the calling convention\n and function return.\n The VariableUtilities#checkVariableConflict(Function, Variable, VariableStorage, boolean) \n method may be used to check and remove conflicting variables which already exist in the function.",
      "javadoc": "Replace all current parameters with the given list of parameters and optionally change the calling convention\n and function return.\n The {@link VariableUtilities#checkVariableConflict(Function, Variable, VariableStorage, boolean)} \n method may be used to check and remove conflicting variables which already exist in the function.\n@param callingConvention updated calling convention name or null if no change is required\n@param returnVar return variable or null if no change required\n@param updateType function update type\n@param force if true any conflicting local parameters will be removed\n@param source the source of these parameters which will be applied to the parameter symbols and \n overall function signature source.  If parameter names are null or a default name a SourceType of DEFAULT\n will be applied to the corresponding parameter symbol.\n@param newParams the list of new parameters for the function (required).\n@throws DuplicateNameException if another variable(parameter or local) already\n exists in the function with that name.\n@throws InvalidInputException if a parameter data type is not a fixed length or variable name is invalid.\n@throws VariableSizeException if a parameter data type size is too large based upon storage constraints\n or conflicts with another variable.",
      "static": false,
      "params": [
        {
          "name": "callingConvention",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "updated calling convention name or null if no change is required"
        },
        {
          "name": "returnVar",
          "type_long": "ghidra.program.model.listing.Variable",
          "type_short": "Variable",
          "comment": "return variable or null if no change required"
        },
        {
          "name": "newParams",
          "type_long": "java.util.List\u003c? extends ghidra.program.model.listing.Variable\u003e",
          "type_short": "List",
          "comment": "the list of new parameters for the function (required)."
        },
        {
          "name": "updateType",
          "type_long": "ghidra.program.model.listing.Function.FunctionUpdateType",
          "type_short": "FunctionUpdateType",
          "comment": "function update type"
        },
        {
          "name": "force",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true any conflicting local parameters will be removed"
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source of these parameters which will be applied to the parameter symbols and \n overall function signature source.  If parameter names are null or a default name a SourceType of DEFAULT\n will be applied to the corresponding parameter symbol."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "if another variable(parameter or local) already\n exists in the function with that name."
        },
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if a parameter data type is not a fixed length or variable name is invalid."
        }
      ]
    },
    {
      "name": "getParameter",
      "comment": "Returns the specified parameter including an auto-param at the specified ordinal.",
      "javadoc": "Returns the specified parameter including an auto-param at the specified ordinal.\n@param ordinal the index of the parameter to return.\n@return parameter or null if ordinal is out of range",
      "static": false,
      "params": [
        {
          "name": "ordinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "the index of the parameter to return."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Parameter",
        "type_short": "Parameter",
        "comment": "parameter or null if ordinal is out of range"
      },
      "throws": []
    },
    {
      "name": "removeParameter",
      "comment": "Remove the specified parameter.  Auto-parameters may not be removed but must be accounted \n for in the specified ordinal.",
      "javadoc": "Remove the specified parameter.  Auto-parameters may not be removed but must be accounted \n for in the specified ordinal.\n@param ordinal the index of the parameter to be removed.\n@deprecated The use of this method is discouraged.  The function signature should generally be \n adjusted with a single call to {@link #updateFunction(String, Variable, List, FunctionUpdateType, boolean, SourceType)}",
      "static": false,
      "params": [
        {
          "name": "ordinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "the index of the parameter to be removed."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "moveParameter",
      "comment": "Move the parameter which occupies the fromOrdinal position to the toOrdinal position.\n Parameters will be renumbered to reflect the new ordering.  Auto-parameters may not be \n moved but must be accounted for in the specified ordinals.",
      "javadoc": "Move the parameter which occupies the fromOrdinal position to the toOrdinal position.\n Parameters will be renumbered to reflect the new ordering.  Auto-parameters may not be \n moved but must be accounted for in the specified ordinals.\n@param fromOrdinal from ordinal position using the current numbering\n@param toOrdinal the final position of the specified parameter\n@return parameter which was moved\n@throws InvalidInputException if either ordinal is invalid\n@deprecated The use of this method is discouraged.  The function signature should generally be \n adjusted with a single call to {@link #updateFunction(String, Variable, List, FunctionUpdateType, boolean, SourceType)}",
      "static": false,
      "params": [
        {
          "name": "fromOrdinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "from ordinal position using the current numbering"
        },
        {
          "name": "toOrdinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "the final position of the specified parameter"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Parameter",
        "type_short": "Parameter",
        "comment": "parameter which was moved"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if either ordinal is invalid"
        }
      ]
    },
    {
      "name": "getParameterCount",
      "comment": "Gets the total number of parameters for this function.  This number also includes any\n auto-parameters which may have been injected when dynamic parameter storage is used.",
      "javadoc": "Gets the total number of parameters for this function.  This number also includes any\n auto-parameters which may have been injected when dynamic parameter storage is used.\n@return the total number of parameters",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the total number of parameters"
      },
      "throws": []
    },
    {
      "name": "getAutoParameterCount",
      "comment": "Gets the number of auto-parameters for this function also included in the total\n count provided by #getParameterCount().  This number will always be 0 when\n custom parameter storage is used.",
      "javadoc": "Gets the number of auto-parameters for this function also included in the total\n count provided by {@link #getParameterCount()}.  This number will always be 0 when\n custom parameter storage is used.\n@return the number of auto-parameters",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of auto-parameters"
      },
      "throws": []
    },
    {
      "name": "getParameters",
      "comment": "Get all function parameters",
      "javadoc": "Get all function parameters\n@return all function parameters",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Parameter[]",
        "type_short": "ghidra.program.model.listing.Parameter[]",
        "comment": "all function parameters"
      },
      "throws": []
    },
    {
      "name": "getParameters",
      "comment": "Get all function parameters which satisfy the specified filter",
      "javadoc": "Get all function parameters which satisfy the specified filter\n@param filter variable filter or null for all parameters to be returned\n@return all function parameters which satisfy the specified filter",
      "static": false,
      "params": [
        {
          "name": "filter",
          "type_long": "ghidra.program.model.listing.VariableFilter",
          "type_short": "VariableFilter",
          "comment": "variable filter or null for all parameters to be returned"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Parameter[]",
        "type_short": "ghidra.program.model.listing.Parameter[]",
        "comment": "all function parameters which satisfy the specified filter"
      },
      "throws": []
    },
    {
      "name": "getLocalVariables",
      "comment": "Get all local function variables",
      "javadoc": "Get all local function variables\n@return all local function variables",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Variable[]",
        "type_short": "ghidra.program.model.listing.Variable[]",
        "comment": "all local function variables"
      },
      "throws": []
    },
    {
      "name": "getLocalVariables",
      "comment": "Get all local function variables which satisfy the specified filter",
      "javadoc": "Get all local function variables which satisfy the specified filter\n@param filter variable filter or null for all local variables to be returned\n@return all function variables which satisfy the specified filter",
      "static": false,
      "params": [
        {
          "name": "filter",
          "type_long": "ghidra.program.model.listing.VariableFilter",
          "type_short": "VariableFilter",
          "comment": "variable filter or null for all local variables to be returned"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Variable[]",
        "type_short": "ghidra.program.model.listing.Variable[]",
        "comment": "all function variables which satisfy the specified filter"
      },
      "throws": []
    },
    {
      "name": "getVariables",
      "comment": "Get all function variables which satisfy the specified filter",
      "javadoc": "Get all function variables which satisfy the specified filter\n@param filter variable filter or null for all variables to be returned\n@return all function variables which satisfy the specified filter",
      "static": false,
      "params": [
        {
          "name": "filter",
          "type_long": "ghidra.program.model.listing.VariableFilter",
          "type_short": "VariableFilter",
          "comment": "variable filter or null for all variables to be returned"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Variable[]",
        "type_short": "ghidra.program.model.listing.Variable[]",
        "comment": "all function variables which satisfy the specified filter"
      },
      "throws": []
    },
    {
      "name": "getAllVariables",
      "comment": "Returns an array of all local and parameter variables",
      "javadoc": "Returns an array of all local and parameter variables\n@return the variables",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Variable[]",
        "type_short": "ghidra.program.model.listing.Variable[]",
        "comment": "the variables"
      },
      "throws": []
    },
    {
      "name": "addLocalVariable",
      "comment": "Adds a local variable to the function.\n The VariableUtilities#checkVariableConflict(Function, Variable, VariableStorage, boolean) \n method may be used to check and remove conflicting variables which already exist in the function.",
      "javadoc": "Adds a local variable to the function.\n The {@link VariableUtilities#checkVariableConflict(Function, Variable, VariableStorage, boolean)} \n method may be used to check and remove conflicting variables which already exist in the function.\n@param var the variable to add.\n@param source the source of this local variable\n@return the Variable added to the program.\n@throws DuplicateNameException if another local variable or parameter already\n has that name.\n@throws InvalidInputException if there is an error or conflict when resolving the variable",
      "static": false,
      "params": [
        {
          "name": "var",
          "type_long": "ghidra.program.model.listing.Variable",
          "type_short": "Variable",
          "comment": "the variable to add."
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source of this local variable"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Variable",
        "type_short": "Variable",
        "comment": "the Variable added to the program."
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "if another local variable or parameter already\n has that name."
        },
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if there is an error or conflict when resolving the variable"
        }
      ]
    },
    {
      "name": "removeVariable",
      "comment": "Removes the given variable from the function.",
      "javadoc": "Removes the given variable from the function.\n@param var the variable to remove.",
      "static": false,
      "params": [
        {
          "name": "var",
          "type_long": "ghidra.program.model.listing.Variable",
          "type_short": "Variable",
          "comment": "the variable to remove."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "setBody",
      "comment": "Set the new body for this function. The entry point must be contained\n in the new body.",
      "javadoc": "Set the new body for this function. The entry point must be contained\n in the new body.\n@param newBody address set to use as the body of this function\n@throws OverlappingFunctionException if the address set overlaps that\n of another function",
      "static": false,
      "params": [
        {
          "name": "newBody",
          "type_long": "ghidra.program.model.address.AddressSetView",
          "type_short": "AddressSetView",
          "comment": "address set to use as the body of this function"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.database.function.OverlappingFunctionException",
          "type_short": "OverlappingFunctionException",
          "comment": "if the address set overlaps that\n of another function"
        }
      ]
    },
    {
      "name": "hasVarArgs",
      "comment": "Returns true if this function has a variable argument list (VarArgs)",
      "javadoc": "Returns true if this function has a variable argument list (VarArgs)\n@return true if this function has a variable argument list (VarArgs)",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this function has a variable argument list (VarArgs)"
      },
      "throws": []
    },
    {
      "name": "setVarArgs",
      "comment": "Set whether parameters can be passed as a VarArg (variable argument list)",
      "javadoc": "Set whether parameters can be passed as a VarArg (variable argument list)\n@param hasVarArgs true if this function has a variable argument list \n        (e.g.,  printf(fmt, ...)).",
      "static": false,
      "params": [
        {
          "name": "hasVarArgs",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if this function has a variable argument list \n        (e.g.,  printf(fmt, ...))."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isInline",
      "comment": "",
      "javadoc": "@return true if this is an inline function.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this is an inline function."
      },
      "throws": []
    },
    {
      "name": "setInline",
      "comment": "Sets whether or not this function is inline.",
      "javadoc": "Sets whether or not this function is inline.\n@param isInline true if this is an inline function.",
      "static": false,
      "params": [
        {
          "name": "isInline",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if this is an inline function."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "hasNoReturn",
      "comment": "",
      "javadoc": "@return true if this function does not return.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this function does not return."
      },
      "throws": []
    },
    {
      "name": "setNoReturn",
      "comment": "Set whether or not this function has a return.",
      "javadoc": "Set whether or not this function has a return.\n@param hasNoReturn true if this function does not return.",
      "static": false,
      "params": [
        {
          "name": "hasNoReturn",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if this function does not return."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "hasCustomVariableStorage",
      "comment": "",
      "javadoc": "@return true if function parameters utilize custom variable storage.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if function parameters utilize custom variable storage."
      },
      "throws": []
    },
    {
      "name": "setCustomVariableStorage",
      "comment": "Set whether or not this function uses custom variable storage",
      "javadoc": "Set whether or not this function uses custom variable storage\n@param hasCustomVariableStorage true if this function uses custom storage",
      "static": false,
      "params": [
        {
          "name": "hasCustomVariableStorage",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if this function uses custom storage"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getCallingConvention",
      "comment": "Gets the calling convention prototype model for this function.",
      "javadoc": "Gets the calling convention prototype model for this function.\n@return the prototype model of the function\u0027s current calling convention or null.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.lang.PrototypeModel",
        "type_short": "PrototypeModel",
        "comment": "the prototype model of the function\u0027s current calling convention or null."
      },
      "throws": []
    },
    {
      "name": "getCallingConventionName",
      "comment": "Gets the calling convention\u0027s name for this function.",
      "javadoc": "Gets the calling convention\u0027s name for this function.\n@return the name of the calling convention \n or Function.DEFAULT_CALLING_CONVENTION_STRING \n (i.e. \"default\", if the calling convention has been set to the default for this function)\n or Function.UNKNOWN_CALLING_CONVENTION_STRING \n (i.e. \"unknown\", if no calling convention is specified for this function).",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the name of the calling convention \n or Function.DEFAULT_CALLING_CONVENTION_STRING \n (i.e. \"default\", if the calling convention has been set to the default for this function)\n or Function.UNKNOWN_CALLING_CONVENTION_STRING \n (i.e. \"unknown\", if no calling convention is specified for this function)."
      },
      "throws": []
    },
    {
      "name": "getDefaultCallingConventionName",
      "comment": "Gets the name of the default calling convention.\n Note: The name in the PrototypeModel of the default calling convention may be null.",
      "javadoc": "Gets the name of the default calling convention.\n \u003cbr\u003eNote: The name in the PrototypeModel of the default calling convention may be null.\n@return the name of the default calling convention.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the name of the default calling convention."
      },
      "throws": []
    },
    {
      "name": "setCallingConvention",
      "comment": "Sets the calling convention for this function to the named calling convention.",
      "javadoc": "Sets the calling convention for this function to the named calling convention.\n@param name the name of the calling convention. \"unknown\" and \"default\" are reserved names\n that can also be used here. \n \u003cbr\u003eNull or Function.UNKNOWN_CALLING_CONVENTION_STRING sets this function to not have a \n calling convention (i.e. unknown).\n \u003cbr\u003eFunction.DEFAULT_CALLING_CONVENTION_STRING sets this function to use the default calling \n convention. (i.e. default)\n@throws InvalidInputException if the specified name is not a recognized calling convention name.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the calling convention. \"unknown\" and \"default\" are reserved names\n that can also be used here. \n Null or Function.UNKNOWN_CALLING_CONVENTION_STRING sets this function to not have a \n calling convention (i.e. unknown).\n Function.DEFAULT_CALLING_CONVENTION_STRING sets this function to use the default calling \n convention. (i.e. default)"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if the specified name is not a recognized calling convention name."
        }
      ]
    },
    {
      "name": "isThunk",
      "comment": "",
      "javadoc": "@return true if this function is a Thunk and has a referenced Thunked Function.\n@see #getThunkedFunction(boolean)",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this function is a Thunk and has a referenced Thunked Function."
      },
      "throws": []
    },
    {
      "name": "getThunkedFunction",
      "comment": "If this function is a Thunk, this method returns the referenced function.",
      "javadoc": "If this function is a Thunk, this method returns the referenced function.\n@param recursive if true and the thunked-function is a thunk itself, the returned \n thunked-function will be the final thunked-function which will never be a thunk.\n@return function referenced by this Thunk Function or null if this is not a Thunk\n function",
      "static": false,
      "params": [
        {
          "name": "recursive",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true and the thunked-function is a thunk itself, the returned \n thunked-function will be the final thunked-function which will never be a thunk."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Function",
        "type_short": "Function",
        "comment": "function referenced by this Thunk Function or null if this is not a Thunk\n function"
      },
      "throws": []
    },
    {
      "name": "getFunctionThunkAddresses",
      "comment": "If this function is \"Thunked\", an array of Thunk Function entry points is returned",
      "javadoc": "If this function is \"Thunked\", an array of Thunk Function entry points is returned\n@return associated thunk function entry points or null if this is not a \"Thunked\" function.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.Address[]",
        "type_short": "ghidra.program.model.address.Address[]",
        "comment": "associated thunk function entry points or null if this is not a \"Thunked\" function."
      },
      "throws": []
    },
    {
      "name": "setThunkedFunction",
      "comment": "Set the currently Thunked Function or null to convert to a normal function",
      "javadoc": "Set the currently Thunked Function or null to convert to a normal function\n@param thunkedFunction the thunked function or null to convert this thunked function to a \n normal function.\n@throws IllegalArgumentException if an attempt is made to thunk a function or another\n thunk which would result in a loop back to this function or if this function is an external\n function, or specified function is from a different program instance.",
      "static": false,
      "params": [
        {
          "name": "thunkedFunction",
          "type_long": "ghidra.program.model.listing.Function",
          "type_short": "Function",
          "comment": "the thunked function or null to convert this thunked function to a \n normal function."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if an attempt is made to thunk a function or another\n thunk which would result in a loop back to this function or if this function is an external\n function, or specified function is from a different program instance."
        }
      ]
    },
    {
      "name": "isExternal",
      "comment": "",
      "javadoc": "@return true if this function is external (i.e., entry point is in EXTERNAL address space)",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this function is external (i.e., entry point is in EXTERNAL address space)"
      },
      "throws": []
    },
    {
      "name": "getExternalLocation",
      "comment": "",
      "javadoc": "@return if this is an external function return the associated external location object.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.symbol.ExternalLocation",
        "type_short": "ExternalLocation",
        "comment": "if this is an external function return the associated external location object."
      },
      "throws": []
    },
    {
      "name": "getCallingFunctions",
      "comment": "Returns a set of functions that call this function.",
      "javadoc": "Returns a set of functions that call this function.\n@param monitor The monitor that is used to report progress and allow for canceling of \n                the search.  May be null.\n@return a set of functions that call this function.",
      "static": false,
      "params": [
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": "The monitor that is used to report progress and allow for canceling of \n                the search.  May be null."
        }
      ],
      "return": {
        "type_long": "java.util.Set\u003cghidra.program.model.listing.Function\u003e",
        "type_short": "Set",
        "comment": "a set of functions that call this function."
      },
      "throws": []
    },
    {
      "name": "getCalledFunctions",
      "comment": "Returns a set of functions that this function calls.",
      "javadoc": "Returns a set of functions that this function calls.\n@param monitor The monitor that is used to report progress and allow for canceling of \n                the search.  May be null.\n@return a set of functions that this function calls.",
      "static": false,
      "params": [
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": "The monitor that is used to report progress and allow for canceling of \n                the search.  May be null."
        }
      ],
      "return": {
        "type_long": "java.util.Set\u003cghidra.program.model.listing.Function\u003e",
        "type_short": "Set",
        "comment": "a set of functions that this function calls."
      },
      "throws": []
    },
    {
      "name": "promoteLocalUserLabelsToGlobal",
      "comment": "Changes all local user-defined labels for this function to global symbols. If a\n global code symbol already exists with the same name at the symbols address the\n symbol will be removed.",
      "javadoc": "Changes all local user-defined labels for this function to global symbols. If a\n global code symbol already exists with the same name at the symbols address the\n symbol will be removed.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isDeleted",
      "comment": "Determine if this function object has been deleted.  NOTE: the function could be\n deleted at anytime due to asynchronous activity.",
      "javadoc": "Determine if this function object has been deleted.  NOTE: the function could be\n deleted at anytime due to asynchronous activity.\n@return true if function has been deleted, false if not.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if function has been deleted, false if not."
      },
      "throws": []
    }
  ]
}
