{
  "name": "StringDataInstance",
  "comment": "Represents an instance of a string in a MemBuffer.\n \n This class handles all the details of detecting a terminated string\u0027s length, converting the\n bytes in the membuffer into a java native String, and converting the raw String into a formatted\n human-readable version, according to the various SettingsDefinitions attached to the\n string data location.\n ",
  "javadoc": "Represents an instance of a string in a {@link MemBuffer}.\n \u003cp\u003e\n This class handles all the details of detecting a terminated string\u0027s length, converting the\n bytes in the membuffer into a java native String, and converting the raw String into a formatted\n human-readable version, according to the various {@link SettingsDefinition}s attached to the\n string data location.\n \u003cp\u003e",
  "static": false,
  "implements": [],
  "extends": "java.lang.Object",
  "fields": [
    {
      "name": "ASCII_MAX",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "127"
    },
    {
      "name": "NULL_INSTANCE",
      "comment": "A StringDataInstance that represents a non-existent string.\n \n Methods on this instance generally return null.",
      "javadoc": "A {@link StringDataInstance} that represents a non-existent string.\n \u003cp\u003e\n Methods on this instance generally return null.",
      "static": true,
      "type_long": "ghidra.program.model.data.StringDataInstance",
      "type_short": "StringDataInstance",
      "constant_value": null
    },
    {
      "name": "MAX_STRING_LENGTH",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "16384"
    },
    {
      "name": "DEFAULT_CHARSET_NAME",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"US-ASCII\""
    },
    {
      "name": "UNKNOWN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"??\""
    },
    {
      "name": "UNKNOWN_DOT_DOT_DOT",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"??...\""
    },
    {
      "name": "BOM_RESULT_STR",
      "comment": "A string with a single char that is the Byte-Order-Mark character.",
      "javadoc": "A string with a single char that is the Byte-Order-Mark character.",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"ï»¿\""
    },
    {
      "name": "SIZEOF_PASCAL255_STR_LEN_FIELD",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "1"
    },
    {
      "name": "SIZEOF_PASCAL64k_STR_LEN_FIELD",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "2"
    },
    {
      "name": "charsetName",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": null
    },
    {
      "name": "charSize",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "paddedCharSize",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "stringLayout",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.program.model.data.StringLayoutEnum",
      "type_short": "StringLayoutEnum",
      "constant_value": null
    },
    {
      "name": "translatedValue",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": null
    },
    {
      "name": "endianSetting",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.program.model.lang.Endian",
      "type_short": "Endian",
      "constant_value": null
    },
    {
      "name": "showTranslation",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "boolean",
      "type_short": "boolean",
      "constant_value": null
    },
    {
      "name": "renderSetting",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.program.model.data.RenderUnicodeSettingsDefinition.RENDER_ENUM",
      "type_short": "RENDER_ENUM",
      "constant_value": null
    },
    {
      "name": "length",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    },
    {
      "name": "buf",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.program.model.mem.MemBuffer",
      "type_short": "MemBuffer",
      "constant_value": null
    },
    {
      "name": "dataTypeMap",
      "comment": "Maps a StringDataInstance\u0027s layout and charset info into the best String DataType\n that can handle this type of data instance.\n \n An entry with a null charset name is equivalent to any charset.",
      "javadoc": "Maps a {@link StringDataInstance}\u0027s layout and charset info into the best String DataType\n that can handle this type of data instance.\n \u003cp\u003e\n An entry with a null charset name is equivalent to any charset.",
      "static": true,
      "type_long": "java.util.Map\u003cgeneric.stl.Pair\u003cghidra.program.model.data.StringLayoutEnum,java.lang.String\u003e,ghidra.program.model.data.DataType\u003e",
      "type_short": "Map",
      "constant_value": null
    }
  ],
  "methods": [
    {
      "name": "isString",
      "comment": "Returns true if the Data instance is a \u0027string\u0027.",
      "javadoc": "Returns true if the {@link Data} instance is a \u0027string\u0027.\n@param data {@link Data} instance to test, null ok.\n@return boolean true if string data.",
      "static": true,
      "params": [
        {
          "name": "data",
          "type_long": "ghidra.program.model.listing.Data",
          "type_short": "Data",
          "comment": "Data instance to test, null ok."
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "boolean true if string data."
      },
      "throws": []
    },
    {
      "name": "isStringDataType",
      "comment": "Returns true if the specified DataType is (or could be) a string.\n \n Arrays of char-like elements (see ArrayStringable) are treated as string data types.\n The actual data instance needs to be inspected to determine if the array is an actual string.\n ",
      "javadoc": "Returns true if the specified {@link DataType} is (or could be) a string.\n \u003cp\u003e\n Arrays of char-like elements (see {@link ArrayStringable}) are treated as string data types.\n The actual data instance needs to be inspected to determine if the array is an actual string.\n \u003cp\u003e\n@param dt DataType to test\n@return boolean true if data type is or could be a string",
      "static": true,
      "params": [
        {
          "name": "dt",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "DataType to test"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "boolean true if data type is or could be a string"
      },
      "throws": []
    },
    {
      "name": "isChar",
      "comment": "Returns true if the Data instance is one of the many \u0027char\u0027 data types.",
      "javadoc": "Returns true if the {@link Data} instance is one of the many \u0027char\u0027 data types.\n@param data {@link Data} instance to test, null ok\n@return boolean true if char data",
      "static": true,
      "params": [
        {
          "name": "data",
          "type_long": "ghidra.program.model.listing.Data",
          "type_short": "Data",
          "comment": "Data instance to test, null ok"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "boolean true if char data"
      },
      "throws": []
    },
    {
      "name": "getCharRepresentation",
      "comment": "Returns a string representation of the character(s) contained in the byte array, suitable for\n display as a single character, or as a sequence of characters.\n ",
      "javadoc": "Returns a string representation of the character(s) contained in the byte array, suitable for\n display as a single character, or as a sequence of characters.\n \u003cp\u003e\n@param dataType the {@link DataType} of the element containing the bytes (most likely a\n            ByteDataType)\n@param bytes the big-endian ordered bytes to convert to a char representation\n@param settings the {@link Settings} object for the location where the bytes came from, or\n            null\n@return formatted string (typically with quotes around the contents): single character: \u0027a\u0027,\n         multiple characters: \"a\\x12bc\"",
      "static": true,
      "params": [
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the DataType of the element containing the bytes (most likely a\n            ByteDataType)"
        },
        {
          "name": "bytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "the big-endian ordered bytes to convert to a char representation"
        },
        {
          "name": "settings",
          "type_long": "ghidra.docking.settings.Settings",
          "type_short": "Settings",
          "comment": "the Settings object for the location where the bytes came from, or\n            null"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "formatted string (typically with quotes around the contents): single character: \u0027a\u0027,\n         multiple characters: \"a\\x12bc\""
      },
      "throws": []
    },
    {
      "name": "isSingleAsciiValue",
      "comment": "Determine if bytes contain only a single ASCII value within least-significant-byte of\n big-endian byte array",
      "javadoc": "Determine if bytes contain only a single ASCII value within least-significant-byte of\n big-endian byte array\n@param bytes value byte array in big-endian order\n@return true if bytes contain a single ASCII value within least-significant-byte",
      "static": true,
      "params": [
        {
          "name": "bytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "value byte array in big-endian order"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if bytes contain a single ASCII value within least-significant-byte"
      },
      "throws": []
    },
    {
      "name": "getStringDataInstance",
      "comment": "Returns a new StringDataInstance using the bytes in the data codeunit.\n ",
      "javadoc": "Returns a new {@link StringDataInstance} using the bytes in the data codeunit.\n \u003cp\u003e\n@param data {@link Data} item\n@return new {@link StringDataInstance}, never NULL. See {@link #NULL_INSTANCE}.",
      "static": true,
      "params": [
        {
          "name": "data",
          "type_long": "ghidra.program.model.listing.Data",
          "type_short": "Data",
          "comment": "Data item"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.StringDataInstance",
        "type_short": "StringDataInstance",
        "comment": "new StringDataInstance, never NULL. See #NULL_INSTANCE."
      },
      "throws": []
    },
    {
      "name": "getStringDataInstance",
      "comment": "Returns a new StringDataInstance using the bytes in the MemBuffer.\n ",
      "javadoc": "Returns a new {@link StringDataInstance} using the bytes in the MemBuffer.\n \u003cp\u003e\n@param dataType {@link DataType} of the bytes in the buffer.\n@param buf memory buffer containing the bytes.\n@param settings the Settings object\n@param length the length of the data.\n@return new {@link StringDataInstance}, never NULL. See {@link #NULL_INSTANCE}.",
      "static": true,
      "params": [
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "DataType of the bytes in the buffer."
        },
        {
          "name": "buf",
          "type_long": "ghidra.program.model.mem.MemBuffer",
          "type_short": "MemBuffer",
          "comment": "memory buffer containing the bytes."
        },
        {
          "name": "settings",
          "type_long": "ghidra.docking.settings.Settings",
          "type_short": "Settings",
          "comment": "the Settings object"
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "the length of the data."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.StringDataInstance",
        "type_short": "StringDataInstance",
        "comment": "new StringDataInstance, never NULL. See #NULL_INSTANCE."
      },
      "throws": []
    },
    {
      "name": "\u003cinit\u003e",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "\u003cinit\u003e",
      "comment": "Creates a string instance using the data in the MemBuffer and the settings pulled\n from the AbstractStringDataType.",
      "javadoc": "Creates a string instance using the data in the {@link MemBuffer} and the settings pulled\n from the {@link AbstractStringDataType string data type}.\n@param dataType {@link DataType} of the string, either a {@link AbstractStringDataType}\n            derived type or an {@link ArrayStringable} element-of-char-array type.\n@param settings {@link Settings} attached to the data location.\n@param buf {@link MemBuffer} containing the data.\n@param length Length passed from the caller to the datatype. -1 indicates a \u0027probe\u0027 trying to\n            detect the length of an unknown string, otherwise it will be the length of the\n            containing field of the data instance.",
      "static": false,
      "params": [
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "DataType of the string, either a AbstractStringDataType\n            derived type or an ArrayStringable element-of-char-array type."
        },
        {
          "name": "settings",
          "type_long": "ghidra.docking.settings.Settings",
          "type_short": "Settings",
          "comment": "Settings attached to the data location."
        },
        {
          "name": "buf",
          "type_long": "ghidra.program.model.mem.MemBuffer",
          "type_short": "MemBuffer",
          "comment": "MemBuffer containing the data."
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "Length passed from the caller to the datatype. -1 indicates a \u0027probe\u0027 trying to\n            detect the length of an unknown string, otherwise it will be the length of the\n            containing field of the data instance."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "\u003cinit\u003e",
      "comment": "Creates a string instance using the data in the MemBuffer and the settings pulled\n from the AbstractStringDataType.",
      "javadoc": "Creates a string instance using the data in the {@link MemBuffer} and the settings pulled\n from the {@link AbstractStringDataType string data type}.\n@param dataType {@link DataType} of the string, either a {@link AbstractStringDataType}\n            derived type or an {@link ArrayStringable} element-of-char-array type.\n@param settings {@link Settings} attached to the data location.\n@param buf {@link MemBuffer} containing the data.\n@param length Length passed from the caller to the datatype. -1 indicates a \u0027probe\u0027 trying to\n            detect the length of an unknown string, otherwise it will be the length of the\n            containing field of the data instance.\n@param isArrayElement boolean flag, true indicates that the specified dataType is an element\n            in an array (ie. char[] vs. just a plain char), causing the string layout to be\n            forced to {@link StringLayoutEnum#NULL_TERMINATED_BOUNDED}",
      "static": false,
      "params": [
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "DataType of the string, either a AbstractStringDataType\n            derived type or an ArrayStringable element-of-char-array type."
        },
        {
          "name": "settings",
          "type_long": "ghidra.docking.settings.Settings",
          "type_short": "Settings",
          "comment": "Settings attached to the data location."
        },
        {
          "name": "buf",
          "type_long": "ghidra.program.model.mem.MemBuffer",
          "type_short": "MemBuffer",
          "comment": "MemBuffer containing the data."
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "Length passed from the caller to the datatype. -1 indicates a \u0027probe\u0027 trying to\n            detect the length of an unknown string, otherwise it will be the length of the\n            containing field of the data instance."
        },
        {
          "name": "isArrayElement",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "boolean flag, true indicates that the specified dataType is an element\n            in an array (ie. char[] vs. just a plain char), causing the string layout to be\n            forced to StringLayoutEnum#NULL_TERMINATED_BOUNDED"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "\u003cinit\u003e",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "copyFrom",
          "type_long": "ghidra.program.model.data.StringDataInstance",
          "type_short": "StringDataInstance",
          "comment": ""
        },
        {
          "name": "newLayout",
          "type_long": "ghidra.program.model.data.StringLayoutEnum",
          "type_short": "StringLayoutEnum",
          "comment": ""
        },
        {
          "name": "newBuf",
          "type_long": "ghidra.program.model.mem.MemBuffer",
          "type_short": "MemBuffer",
          "comment": ""
        },
        {
          "name": "newLen",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        },
        {
          "name": "newCharsetName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getDataOrganization",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataOrganization",
        "type_short": "DataOrganization",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getLayoutFromDataType",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.StringLayoutEnum",
        "type_short": "StringLayoutEnum",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getCharsetNameFromDataTypeOrSettings",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": ""
        },
        {
          "name": "settings",
          "type_long": "ghidra.docking.settings.Settings",
          "type_short": "Settings",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getCharsetName",
      "comment": "Returns the string name of the charset.",
      "javadoc": "Returns the string name of the charset.\n@return string charset name",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "string charset name"
      },
      "throws": []
    },
    {
      "name": "getAddress",
      "comment": "Returns the address of the MemBuffer.",
      "javadoc": "Returns the address of the {@link MemBuffer}.\n@return {@link Address} of the MemBuffer.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "Address of the MemBuffer."
      },
      "throws": []
    },
    {
      "name": "isBadCharSize",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isProbe",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isAlreadyDeterminedFixedLen",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getDataLength",
      "comment": "Returns the length of this string\u0027s data, in bytes.",
      "javadoc": "Returns the length of this string\u0027s data, in bytes.\n@return number of bytes in this string.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "number of bytes in this string."
      },
      "throws": []
    },
    {
      "name": "getStringLength",
      "comment": "Returns the length, in bytes, of the string data object contained in the MemBuffer,\n or -1 if the length could not be determined.\n \n This is not the same as the number of characters in the string, or the number of bytes\n occupied by the characters. For instance, pascal strings have a 1 or 2 byte length field that\n increases the size of the string data object beyond the characters in the string, and null\n terminated strings have don\u0027t include the null character, but its presence is included in the\n size of the string object.\n \n For length-specified string data types that do not use null-terminators and with a known data\n instance length (ie. not a probe), this method just returns the value specified in the\n constructor  parameter, otherwise a null-terminator is searched for.\n \n When searching for a null-terminator, the constructor  parameter will be\n respected or ignored depending on the StringLayoutEnum.\n \n When the length parameter is ignored (ie. \"unbounded\" searching), the search is limited to\n #MAX_STRING_LENGTH bytes.\n \n The MemBuffer\u0027s endian\u0027ness is used to determine which end of the padded character field\n contains our n-bit character which will be tested for null-ness. (not the endian\u0027ness of the\n character set name - ie. \"UTF-16BE\")",
      "javadoc": "Returns the length, in bytes, of the string data object contained in the {@link MemBuffer},\n or -1 if the length could not be determined.\n \u003cp\u003e\n This is not the same as the number of characters in the string, or the number of bytes\n occupied by the characters. For instance, pascal strings have a 1 or 2 byte length field that\n increases the size of the string data object beyond the characters in the string, and null\n terminated strings have don\u0027t include the null character, but its presence is included in the\n size of the string object.\n \u003cp\u003e\n For length-specified string data types that do not use null-terminators and with a known data\n instance length (ie. not a probe), this method just returns the value specified in the\n constructor {@code length} parameter, otherwise a null-terminator is searched for.\n \u003cp\u003e\n When searching for a null-terminator, the constructor {@code length} parameter will be\n respected or ignored depending on the {@link StringLayoutEnum}.\n \u003cp\u003e\n When the length parameter is ignored (ie. \"unbounded\" searching), the search is limited to\n {@link #MAX_STRING_LENGTH} bytes.\n \u003cp\u003e\n The MemBuffer\u0027s endian\u0027ness is used to determine which end of the padded character field\n contains our n-bit character which will be tested for null-ness. (not the endian\u0027ness of the\n character set name - ie. \"UTF-16BE\")\n@return length of the string (NOT including null term if null term probe), in bytes, or -1 if\n         no terminator found.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "length of the string (NOT including null term if null term probe), in bytes, or -1 if\n         no terminator found."
      },
      "throws": []
    },
    {
      "name": "getNullTerminatedLength",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isMissingNullTerminator",
      "comment": "Returns true if the string should have a trailing NULL character and doesn\u0027t.",
      "javadoc": "Returns true if the string should have a trailing NULL character and doesn\u0027t.\n@return boolean true if the trailing NULL character is missing, false if string type doesn\u0027t\n         need a trailing NULL character or if it is present.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "boolean true if the trailing NULL character is missing, false if string type doesn\u0027t\n         need a trailing NULL character or if it is present."
      },
      "throws": []
    },
    {
      "name": "getPascalLength",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "readChar",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "charBuf",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": ""
        },
        {
          "name": "offset",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isNullChar",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "charBuf",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getStringValue",
      "comment": "Returns the string contained in the specified MemBuffer, or null if all the bytes of\n the string could not be read.\n \n This method deals in characters of size #charSize, that might be\n #paddedCharSize to a larger size. The raw n-byte characters are converted into\n a Java String using a Java Charset or by using a custom Ghidra conversion. (see\n convertBytesToStringCustomCharset)\n \n The MemBuffer\u0027s endian\u0027ness is used to determine which end of the #paddedCharSize field contains our #charSize character bytes which will be used to create\n the java String.",
      "javadoc": "Returns the string contained in the specified {@link MemBuffer}, or null if all the bytes of\n the string could not be read.\n \u003cp\u003e\n This method deals in characters of size {@link #charSize}, that might be\n {@link #paddedCharSize padded} to a larger size. The raw n-byte characters are converted into\n a Java String using a Java {@link Charset} or by using a custom Ghidra conversion. (see\n convertBytesToStringCustomCharset)\n \u003cp\u003e\n The MemBuffer\u0027s endian\u0027ness is used to determine which end of the {@link #paddedCharSize padded } field contains our {@link #charSize} character bytes which will be used to create\n the java String.\n@return String containing the characters in buf or null if unable to read all {@code length}\n         bytes from the membuffer.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "String containing the characters in buf or null if unable to read all \n         bytes from the membuffer."
      },
      "throws": []
    },
    {
      "name": "getStringValueNoTrim",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getStringBytes",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getNormalStringCharBytes",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getPascalCharBytes",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isValidOffcutOffset",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "offcutBytes",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getCharOffset",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "charCount",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getOffcutLayout",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.data.StringLayoutEnum",
        "type_short": "StringLayoutEnum",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getBytesFromMemBuff",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "memBuffer",
          "type_long": "ghidra.program.model.mem.MemBuffer",
          "type_short": "MemBuffer",
          "comment": ""
        },
        {
          "name": "copyLen",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "convertPaddedToUnpadded",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "paddedBytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "convertUnpaddedToPadded",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "unpaddedBytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getMemoryEndianness",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.lang.Endian",
        "type_short": "Endian",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "convertBytesToString",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "bytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": ""
        },
        {
          "name": "aci",
          "type_long": "ghidra.program.model.data.StringDataInstance.AdjustedCharsetInfo",
          "type_short": "AdjustedCharsetInfo",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getAdjustedCharsetInfo",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.data.StringDataInstance.AdjustedCharsetInfo",
        "type_short": "AdjustedCharsetInfo",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getAdjustedCharsetInfo",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "bytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.StringDataInstance.AdjustedCharsetInfo",
        "type_short": "AdjustedCharsetInfo",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getDataConverter",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "endian",
          "type_long": "ghidra.program.model.lang.Endian",
          "type_short": "Endian",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.util.DataConverter",
        "type_short": "DataConverter",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "convertBytesToStringCustomCharset",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "bytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": ""
        },
        {
          "name": "aci",
          "type_long": "ghidra.program.model.data.StringDataInstance.AdjustedCharsetInfo",
          "type_short": "AdjustedCharsetInfo",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getEndiannessFromBOM",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "bytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": ""
        },
        {
          "name": "charSize",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.lang.Endian",
        "type_short": "Endian",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getStringRepresentation",
      "comment": "Returns a formatted version of the string returned by #getStringValue().\n \n The resulting string will be formatted with quotes around the parts that contain plain ASCII\n alpha characters (and simple escape sequences), and out-of-range byte-ish values listed as\n comma separated hex-encoded values:\n \n Example (quotes are part of result): ",
      "javadoc": "Returns a formatted version of the string returned by {@link #getStringValue()}.\n \u003cp\u003e\n The resulting string will be formatted with quotes around the parts that contain plain ASCII\n alpha characters (and simple escape sequences), and out-of-range byte-ish values listed as\n comma separated hex-encoded values:\n \u003cp\u003e\n Example (quotes are part of result): {@code \"Test\\tstring\",01,02,\"Second\\npart\",00}\n@return formatted String",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "formatted String"
      },
      "throws": []
    },
    {
      "name": "getStringRep",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "quoteChar",
          "type_long": "char",
          "type_short": "char",
          "comment": ""
        },
        {
          "name": "quoteCharMulti",
          "type_long": "char",
          "type_short": "char",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getOriginalBytes",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "isByteToStringCharEquiv",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": ""
        },
        {
          "name": "charOffset",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        },
        {
          "name": "codePoint",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        },
        {
          "name": "stringBytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": ""
        },
        {
          "name": "aci",
          "type_long": "ghidra.program.model.data.StringDataInstance.AdjustedCharsetInfo",
          "type_short": "AdjustedCharsetInfo",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "trimNulls",
      "comment": "Trims trailing nulls off the end of the string.",
      "javadoc": "Trims trailing nulls off the end of the string.\n@param s String to trim\n@return new String without any trailing null chars.",
      "static": false,
      "params": [
        {
          "name": "s",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "String to trim"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "new String without any trailing null chars."
      },
      "throws": []
    },
    {
      "name": "getTranslatedValue",
      "comment": "Returns the value of the stored\n TranslationSettingsDefinition#getTranslatedValue(Settings)\n string.\n ",
      "javadoc": "Returns the value of the stored\n {@link TranslationSettingsDefinition#getTranslatedValue(Settings) translated settings}\n string.\n \u003cp\u003e\n@return previously translated string.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "previously translated string."
      },
      "throws": []
    },
    {
      "name": "isShowTranslation",
      "comment": "Returns true if the user should be shown the translated value of the string instead of the\n real value.",
      "javadoc": "Returns true if the user should be shown the translated value of the string instead of the\n real value.\n@return boolean true if should show previously translated value.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "boolean true if should show previously translated value."
      },
      "throws": []
    },
    {
      "name": "getCharRepresentation",
      "comment": "Convert a char value (or sequence of char values) in memory into its canonical unicode\n representation, using attached charset and encoding information.\n ",
      "javadoc": "Convert a char value (or sequence of char values) in memory into its canonical unicode\n representation, using attached charset and encoding information.\n \u003cp\u003e\n@return String containing the representation of the char.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "String containing the representation of the char."
      },
      "throws": []
    },
    {
      "name": "isReplacementCharAt",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "stringBytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": ""
        },
        {
          "name": "byteOffset",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getTranslatedStringRepresentation",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "translatedString",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getLabel",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "prefixStr",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "abbrevPrefixStr",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "defaultStr",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "options",
          "type_long": "ghidra.program.model.data.DataTypeDisplayOptions",
          "type_short": "DataTypeDisplayOptions",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getOffcutLabelString",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "prefixStr",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "abbrevPrefixStr",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "defaultStr",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "options",
          "type_long": "ghidra.program.model.data.DataTypeDisplayOptions",
          "type_short": "DataTypeDisplayOptions",
          "comment": ""
        },
        {
          "name": "byteOffset",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getByteOffcut",
      "comment": "Returns a new StringDataInstance that points to the string characters that start at\n  from the start of this instance.\n \n If the requested offset is not valid, the base string instance (itself) will be returned\n instead of a new instance.\n ",
      "javadoc": "Returns a new {@link StringDataInstance} that points to the string characters that start at\n {@code byteOffset} from the start of this instance.\n \u003cp\u003e\n If the requested offset is not valid, the base string instance (itself) will be returned\n instead of a new instance.\n \u003cp\u003e\n@param byteOffset number of bytes from start of data instance to start new instance.\n@return new StringDataInstance, or \u003ccode\u003ethis\u003c/code\u003e if offset not valid.",
      "static": false,
      "params": [
        {
          "name": "byteOffset",
          "type_long": "int",
          "type_short": "int",
          "comment": "number of bytes from start of data instance to start new instance."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.StringDataInstance",
        "type_short": "StringDataInstance",
        "comment": "new StringDataInstance, or this if offset not valid."
      },
      "throws": []
    },
    {
      "name": "getCharOffcut",
      "comment": "Create a new StringDataInstance that points to a portion of this instance, starting\n at a character offset (whereever that may be) into the data.\n ",
      "javadoc": "Create a new {@link StringDataInstance} that points to a portion of this instance, starting\n at a character offset (whereever that may be) into the data.\n \u003cp\u003e\n@param offsetChars number of characters from the beginning of the string to start the new\n            StringDataInstance.\n@return new {@link StringDataInstance} pointing to a subset of characters, or the\n         \u003ccode\u003ethis\u003c/code\u003e instance if there was an error.",
      "static": false,
      "params": [
        {
          "name": "offsetChars",
          "type_long": "int",
          "type_short": "int",
          "comment": "number of characters from the beginning of the string to start the new\n            StringDataInstance."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.StringDataInstance",
        "type_short": "StringDataInstance",
        "comment": "new StringDataInstance pointing to a subset of characters, or the\n         this instance if there was an error."
      },
      "throws": []
    },
    {
      "name": "getStringDataTypeGuess",
      "comment": "Maps a StringDataInstance (this type) to the String DataType that best can handle\n this type of data.\n \n I dare myself to type Type one more time.\n ",
      "javadoc": "Maps a {@link StringDataInstance} (this type) to the String DataType that best can handle\n this type of data.\n \u003cp\u003e\n I dare myself to type Type one more time.\n \u003cp\u003e\n@return {@link DataType}, defaulting to {@link StringDataType} if no direct match found.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.data.DataType",
        "type_short": "DataType",
        "comment": "DataType, defaulting to StringDataType if no direct match found."
      },
      "throws": []
    },
    {
      "name": "toString",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "allocBuf",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "buf",
          "type_long": "ghidra.program.model.mem.MemBuffer",
          "type_short": "MemBuffer",
          "comment": ""
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.nio.ByteBuffer",
        "type_short": "ByteBuffer",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "fitsIn",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "buf",
          "type_long": "java.nio.ByteBuffer",
          "type_short": "ByteBuffer",
          "comment": ""
        },
        {
          "name": "lenLen",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "encodeReplacementFromStringValue",
      "comment": "Encode a string to replace the current value",
      "javadoc": "Encode a string to replace the current value\n@param value the value to encode\n@return the encoded value\n@throws CharacterCodingException if a character could not be encoded",
      "static": false,
      "params": [
        {
          "name": "value",
          "type_long": "java.lang.CharSequence",
          "type_short": "CharSequence",
          "comment": "the value to encode"
        }
      ],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": "the encoded value"
      },
      "throws": [
        {
          "type_long": "java.nio.charset.CharacterCodingException",
          "type_short": "CharacterCodingException",
          "comment": "if a character could not be encoded"
        }
      ]
    },
    {
      "name": "encodeReplacementFromStringRepresentation",
      "comment": "Parse and encode a string from its representation to replace the current value",
      "javadoc": "Parse and encode a string from its representation to replace the current value\n@param repr the representation of the string\n@return the encoded value\n@throws StringParseException if the representation could not be parsed\n@throws UnmappableCharacterException if a character could not be encoded\n@throws MalformedInputException if the input contains invalid character sequences",
      "static": false,
      "params": [
        {
          "name": "repr",
          "type_long": "java.lang.CharSequence",
          "type_short": "CharSequence",
          "comment": "the representation of the string"
        }
      ],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": "the encoded value"
      },
      "throws": [
        {
          "type_long": "java.nio.charset.MalformedInputException",
          "type_short": "MalformedInputException",
          "comment": "if the input contains invalid character sequences"
        },
        {
          "type_long": "java.nio.charset.UnmappableCharacterException",
          "type_short": "UnmappableCharacterException",
          "comment": "if a character could not be encoded"
        },
        {
          "type_long": "ghidra.program.model.data.StringRenderParser.StringParseException",
          "type_short": "StringParseException",
          "comment": "if the representation could not be parsed"
        }
      ]
    },
    {
      "name": "encodeReplacementFromCharValue",
      "comment": "Encode a single character to replace the current value",
      "javadoc": "Encode a single character to replace the current value\n@param value a single code point to encode\n@return the encoded value\n@throws CharacterCodingException if the character could not be encoded",
      "static": false,
      "params": [
        {
          "name": "value",
          "type_long": "char[]",
          "type_short": "char[]",
          "comment": "a single code point to encode"
        }
      ],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": "the encoded value"
      },
      "throws": [
        {
          "type_long": "java.nio.charset.CharacterCodingException",
          "type_short": "CharacterCodingException",
          "comment": "if the character could not be encoded"
        }
      ]
    },
    {
      "name": "encodeReplacementFromCharRepresentation",
      "comment": "Parse and encode a single character from its representation to replace the current value",
      "javadoc": "Parse and encode a single character from its representation to replace the current value\n@param repr the representation of a single character\n@return the encoded value\n@throws StringParseException if the representation could not be parsed\n@throws UnmappableCharacterException if a character could not be encoded\n@throws MalformedInputException if the input contains invalid character sequences",
      "static": false,
      "params": [
        {
          "name": "repr",
          "type_long": "java.lang.CharSequence",
          "type_short": "CharSequence",
          "comment": "the representation of a single character"
        }
      ],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": "the encoded value"
      },
      "throws": [
        {
          "type_long": "java.nio.charset.MalformedInputException",
          "type_short": "MalformedInputException",
          "comment": "if the input contains invalid character sequences"
        },
        {
          "type_long": "java.nio.charset.UnmappableCharacterException",
          "type_short": "UnmappableCharacterException",
          "comment": "if a character could not be encoded"
        },
        {
          "type_long": "ghidra.program.model.data.StringRenderParser.StringParseException",
          "type_short": "StringParseException",
          "comment": "if the representation could not be parsed"
        }
      ]
    },
    {
      "name": "checkAndEncodeLayout",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "encoded",
          "type_long": "java.nio.ByteBuffer",
          "type_short": "ByteBuffer",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": ""
      },
      "throws": []
    }
  ]
}
