{
  "name": "Composite",
  "comment": "Interface for common methods in Structure and Union",
  "javadoc": "Interface for common methods in Structure and Union",
  "static": false,
  "implements": [
    "ghidra.program.model.data.DataType"
  ],
  "fields": [],
  "methods": [
    {
      "name": "setDescription",
      "comment": "Sets the string describing this data type.",
      "javadoc": "Sets the string describing this data type.\n@param desc the new description.",
      "static": false,
      "params": [
        {
          "name": "desc",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the new description."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getNumComponents",
      "comment": "Gets the number of component data types in this composite.\n If this is Structure with packing disabled, the count will include all undefined filler\n components which may be present.",
      "javadoc": "Gets the number of component data types in this composite.\n If this is Structure with packing disabled, the count will include all undefined filler\n components which may be present.\n@return the number of components that make up this composite",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of components that make up this composite"
      },
      "throws": []
    },
    {
      "name": "getNumDefinedComponents",
      "comment": "Returns the number of explicitly defined components in this composite.\n For Unions and packed Structures this is equivalent to #getNumComponents()\n since they do not contain undefined components.\n This count will always exclude all undefined filler components which may be present\n within a Structure whose packing is disabled (see #isPackingEnabled()).",
      "javadoc": "Returns the number of explicitly defined components in this composite.\n For Unions and packed Structures this is equivalent to {@link #getNumComponents()}\n since they do not contain undefined components.\n This count will always exclude all undefined filler components which may be present\n within a Structure whose packing is disabled (see {@link #isPackingEnabled()}).\n@return the number of explicitly defined components in this composite",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of explicitly defined components in this composite"
      },
      "throws": []
    },
    {
      "name": "getComponent",
      "comment": "Returns the component of this data type with the indicated ordinal.",
      "javadoc": "Returns the component of this data type with the indicated ordinal.\n@param ordinal the component\u0027s ordinal (zero based).\n@return the data type component.\n@throws IndexOutOfBoundsException if the ordinal is out of bounds",
      "static": false,
      "params": [
        {
          "name": "ordinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "the component\u0027s ordinal (zero based)."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the data type component."
      },
      "throws": [
        {
          "type_long": "java.lang.IndexOutOfBoundsException",
          "type_short": "IndexOutOfBoundsException",
          "comment": "if the ordinal is out of bounds"
        }
      ]
    },
    {
      "name": "getComponents",
      "comment": "Returns an array of Data Type Components that make up this composite including\n undefined filler components which may be present within a Structure whch has packing disabled.\n The number of components corresponds to #getNumComponents().",
      "javadoc": "Returns an array of Data Type Components that make up this composite including\n undefined filler components which may be present within a Structure whch has packing disabled.\n The number of components corresponds to {@link #getNumComponents()}.\n@return array all components",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent[]",
        "type_short": "ghidra.program.model.data.DataTypeComponent[]",
        "comment": "array all components"
      },
      "throws": []
    },
    {
      "name": "getDefinedComponents",
      "comment": "Returns an array of Data Type Components that make up this composite excluding\n undefined filler components which may be present within Structures where packing is disabled.\n The number of components corresponds to #getNumDefinedComponents().  For Unions and\n packed Structures this is equivalent to #getComponents()\n since they do not contain undefined filler components.",
      "javadoc": "Returns an array of Data Type Components that make up this composite excluding\n undefined filler components which may be present within Structures where packing is disabled.\n The number of components corresponds to {@link #getNumDefinedComponents()}.  For Unions and\n packed Structures this is equivalent to {@link #getComponents()}\n since they do not contain undefined filler components.\n@return array all explicitly defined components",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent[]",
        "type_short": "ghidra.program.model.data.DataTypeComponent[]",
        "comment": "array all explicitly defined components"
      },
      "throws": []
    },
    {
      "name": "add",
      "comment": "Adds a new datatype to the end of this composite.  This is the preferred method\n to use for adding components to an aligned structure for fixed-length dataTypes.",
      "javadoc": "Adds a new datatype to the end of this composite.  This is the preferred method\n to use for adding components to an aligned structure for fixed-length dataTypes.\n@param dataType the datatype to add.\n@return the DataTypeComponent created.\n@throws IllegalArgumentException if the specified data type is not\n allowed to be added to this composite data type.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to add dt1 to dt2 since this would cause a cyclic dependency.",
      "static": false,
      "params": [
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the datatype to add."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the DataTypeComponent created."
      },
      "throws": [
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if the specified data type is not\n allowed to be added to this composite data type.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to add dt1 to dt2 since this would cause a cyclic dependency."
        }
      ]
    },
    {
      "name": "add",
      "comment": "Adds a new datatype to the end of this composite. This is the preferred method\n to use for adding components to an aligned structure for dynamic dataTypes such as\n strings whose length must be specified.",
      "javadoc": "Adds a new datatype to the end of this composite. This is the preferred method\n to use for adding components to an aligned structure for dynamic dataTypes such as\n strings whose length must be specified.\n@param dataType the datatype to add.\n@param length the length to associate with the datatype.\n For fixed length types a length \u0026lt;\u003d 0 will use the length of the resolved dataType.\n@return the componentDataType created.\n@throws IllegalArgumentException if the specified data type is not\n allowed to be added to this composite data type or an invalid length\n is specified.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to add dt1 to dt2 since this would cause a cyclic dependency.",
      "static": false,
      "params": [
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the datatype to add."
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "the length to associate with the datatype.\n For fixed length types a length \u003d 0 will use the length of the resolved dataType."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the componentDataType created."
      },
      "throws": [
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if the specified data type is not\n allowed to be added to this composite data type or an invalid length\n is specified.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to add dt1 to dt2 since this would cause a cyclic dependency."
        }
      ]
    },
    {
      "name": "add",
      "comment": "Adds a new datatype to the end of this composite.  This is the preferred method\n to use for adding components to an aligned structure for fixed-length dataTypes.",
      "javadoc": "Adds a new datatype to the end of this composite.  This is the preferred method\n to use for adding components to an aligned structure for fixed-length dataTypes.\n@param dataType the datatype to add.\n@param name the field name to associate with this component.\n@param comment the comment to associate with this component.\n@return the componentDataType created.\n@throws IllegalArgumentException if the specified data type is not\n allowed to be added to this composite data type.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to add dt1 to dt2 since this would cause a cyclic dependency.",
      "static": false,
      "params": [
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the datatype to add."
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the field name to associate with this component."
        },
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the comment to associate with this component."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the componentDataType created."
      },
      "throws": [
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if the specified data type is not\n allowed to be added to this composite data type.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to add dt1 to dt2 since this would cause a cyclic dependency."
        }
      ]
    },
    {
      "name": "addBitField",
      "comment": "Adds a new bitfield to the end of this composite.  This method is intended\n to be used with packed structures/unions only where the bitfield will be\n appropriately packed.  The minimum storage storage byte size will be applied.\n It will not provide useful results for composites with packing disabled.",
      "javadoc": "Adds a new bitfield to the end of this composite.  This method is intended\n to be used with packed structures/unions only where the bitfield will be\n appropriately packed.  The minimum storage storage byte size will be applied.\n It will not provide useful results for composites with packing disabled.\n@param baseDataType the bitfield base datatype (certain restrictions apply).\n@param bitSize the bitfield size in bits\n@param componentName the field name to associate with this component.\n@param comment the comment to associate with this component.\n@return the componentDataType created whose associated data type will\n be BitFieldDataType.\n@throws InvalidDataTypeException if the specified data type is\n not a valid base type for bitfields.",
      "static": false,
      "params": [
        {
          "name": "baseDataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the bitfield base datatype (certain restrictions apply)."
        },
        {
          "name": "bitSize",
          "type_long": "int",
          "type_short": "int",
          "comment": "the bitfield size in bits"
        },
        {
          "name": "componentName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the field name to associate with this component."
        },
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the comment to associate with this component."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the componentDataType created whose associated data type will\n be BitFieldDataType."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.data.InvalidDataTypeException",
          "type_short": "InvalidDataTypeException",
          "comment": "if the specified data type is\n not a valid base type for bitfields."
        }
      ]
    },
    {
      "name": "add",
      "comment": "Adds a new datatype to the end of this composite.  This is the preferred method\n to use for adding components to an aligned structure for dynamic dataTypes such as\n strings whose length must be specified.",
      "javadoc": "Adds a new datatype to the end of this composite.  This is the preferred method\n to use for adding components to an aligned structure for dynamic dataTypes such as\n strings whose length must be specified.\n@param dataType the datatype to add.\n@param length the length to associate with the datatype.\n For fixed length types a length \u0026lt;\u003d 0 will use the length of the resolved dataType.\n@param name the field name to associate with this component.\n@param comment the comment to associate with this component.\n@return the componentDataType created.\n@throws IllegalArgumentException if the specified data type is not\n allowed to be added to this composite data type or an invalid length is specified.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to add dt1 to dt2 since this would cause a cyclic dependency.",
      "static": false,
      "params": [
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the datatype to add."
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "the length to associate with the datatype.\n For fixed length types a length \u003d 0 will use the length of the resolved dataType."
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the field name to associate with this component."
        },
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the comment to associate with this component."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the componentDataType created."
      },
      "throws": [
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if the specified data type is not\n allowed to be added to this composite data type or an invalid length is specified.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to add dt1 to dt2 since this would cause a cyclic dependency."
        }
      ]
    },
    {
      "name": "insert",
      "comment": "Inserts a new datatype at the specified ordinal position in this composite.\n Note: For an aligned structure the ordinal position will get adjusted\n automatically to provide the proper alignment.",
      "javadoc": "Inserts a new datatype at the specified ordinal position in this composite.\n \u003cBR\u003eNote: For an aligned structure the ordinal position will get adjusted\n automatically to provide the proper alignment.\n@param ordinal the ordinal where the new datatype is to be inserted.\n@param dataType the datatype to insert.\n@return the componentDataType created.\n@throws IllegalArgumentException if the specified data type is not\n allowed to be inserted into this composite data type.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to insert dt1 to dt2 since this would cause a cyclic dependency.\n@throws IndexOutOfBoundsException if component ordinal is out of bounds",
      "static": false,
      "params": [
        {
          "name": "ordinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "the ordinal where the new datatype is to be inserted."
        },
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the datatype to insert."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the componentDataType created."
      },
      "throws": [
        {
          "type_long": "java.lang.IndexOutOfBoundsException",
          "type_short": "IndexOutOfBoundsException",
          "comment": "if component ordinal is out of bounds"
        },
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if the specified data type is not\n allowed to be inserted into this composite data type.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to insert dt1 to dt2 since this would cause a cyclic dependency."
        }
      ]
    },
    {
      "name": "insert",
      "comment": "Inserts a new datatype at the specified ordinal position in this composite.\n Note: For an aligned structure the ordinal position will get adjusted\n automatically to provide the proper alignment.",
      "javadoc": "Inserts a new datatype at the specified ordinal position in this composite.\n \u003cBR\u003eNote: For an aligned structure the ordinal position will get adjusted\n automatically to provide the proper alignment.\n@param ordinal the ordinal where the new datatype is to be inserted.\n@param dataType the datatype to insert.\n@param length the length to associate with the datatype.\n For fixed length types a length \u0026lt;\u003d 0 will use the length of the resolved dataType.\n@return the componentDataType created.\n@throws IllegalArgumentException if the specified data type is not\n allowed to be inserted into this composite data type or an invalid\n length is specified.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to insert dt1 to dt2 since this would cause a cyclic dependency.\n@throws IndexOutOfBoundsException if component ordinal is out of bounds",
      "static": false,
      "params": [
        {
          "name": "ordinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "the ordinal where the new datatype is to be inserted."
        },
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the datatype to insert."
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "the length to associate with the datatype.\n For fixed length types a length \u003d 0 will use the length of the resolved dataType."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the componentDataType created."
      },
      "throws": [
        {
          "type_long": "java.lang.IndexOutOfBoundsException",
          "type_short": "IndexOutOfBoundsException",
          "comment": "if component ordinal is out of bounds"
        },
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if the specified data type is not\n allowed to be inserted into this composite data type or an invalid\n length is specified.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to insert dt1 to dt2 since this would cause a cyclic dependency."
        }
      ]
    },
    {
      "name": "insert",
      "comment": "Inserts a new datatype at the specified ordinal position in this composite.\n Note: For an aligned structure the ordinal position will get adjusted\n automatically to provide the proper alignment.",
      "javadoc": "Inserts a new datatype at the specified ordinal position in this composite.\n \u003cBR\u003eNote: For an aligned structure the ordinal position will get adjusted\n automatically to provide the proper alignment.\n@param ordinal the ordinal where the new datatype is to be inserted.\n@param dataType the datatype to insert.\n@param length the length to associate with the datatype.\n For fixed length types a length \u0026lt;\u003d 0 will use the length of the resolved dataType.\n@param name the field name to associate with this component.\n@param comment the comment to associate with this component.\n@return the componentDataType created.\n@throws IllegalArgumentException if the specified data type is not\n allowed to be inserted into this composite data type or an invalid length\n is specified.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to insert dt1 to dt2 since this would cause a cyclic dependency.\n@throws IndexOutOfBoundsException if component ordinal is out of bounds",
      "static": false,
      "params": [
        {
          "name": "ordinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "the ordinal where the new datatype is to be inserted."
        },
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the datatype to insert."
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "the length to associate with the datatype.\n For fixed length types a length \u003d 0 will use the length of the resolved dataType."
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the field name to associate with this component."
        },
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the comment to associate with this component."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the componentDataType created."
      },
      "throws": [
        {
          "type_long": "java.lang.IndexOutOfBoundsException",
          "type_short": "IndexOutOfBoundsException",
          "comment": "if component ordinal is out of bounds"
        },
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if the specified data type is not\n allowed to be inserted into this composite data type or an invalid length\n is specified.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to insert dt1 to dt2 since this would cause a cyclic dependency."
        }
      ]
    },
    {
      "name": "delete",
      "comment": "Deletes the component at the given ordinal position.\n Note: Removal of bitfields from a structure with packing disabled will\n not shift other components causing vacated bytes to revert to undefined filler.",
      "javadoc": "Deletes the component at the given ordinal position.\n \u003cBR\u003eNote: Removal of bitfields from a structure with packing disabled will\n not shift other components causing vacated bytes to revert to undefined filler.\n@param ordinal the ordinal of the component to be deleted.\n@throws IndexOutOfBoundsException if component ordinal is out of bounds",
      "static": false,
      "params": [
        {
          "name": "ordinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "the ordinal of the component to be deleted."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.IndexOutOfBoundsException",
          "type_short": "IndexOutOfBoundsException",
          "comment": "if component ordinal is out of bounds"
        }
      ]
    },
    {
      "name": "delete",
      "comment": "Deletes the specified set of components at the given ordinal positions.\n Note: Removal of bitfields from a structure with packing disabled will\n not shift other components causing vacated bytes to revert to undefined filler.",
      "javadoc": "Deletes the specified set of components at the given ordinal positions.\n \u003cBR\u003eNote: Removal of bitfields from a structure with packing disabled will\n not shift other components causing vacated bytes to revert to undefined filler.\n@param ordinals the ordinals of the component to be deleted.\n@throws IndexOutOfBoundsException if any specified component ordinal is out of bounds",
      "static": false,
      "params": [
        {
          "name": "ordinals",
          "type_long": "java.util.Set\u003cjava.lang.Integer\u003e",
          "type_short": "Set",
          "comment": "the ordinals of the component to be deleted."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.IndexOutOfBoundsException",
          "type_short": "IndexOutOfBoundsException",
          "comment": "if any specified component ordinal is out of bounds"
        }
      ]
    },
    {
      "name": "isPartOf",
      "comment": "Check if a data type is part of this data type.  A data type could\n be part of another by:\n Being the same data type.\n containing the data type directly\n containing another data type that has the data type as a part of it.",
      "javadoc": "Check if a data type is part of this data type.  A data type could\n be part of another by:\n \u003cbr\u003eBeing the same data type.\n \u003cbr\u003econtaining the data type directly\n \u003cbr\u003econtaining another data type that has the data type as a part of it.\n@param dataType the data type to look for.\n@return true if the indicated data type is part of a sub-component of\n this data type.",
      "static": false,
      "params": [
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the data type to look for."
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the indicated data type is part of a sub-component of\n this data type."
      },
      "throws": []
    },
    {
      "name": "dataTypeAlignmentChanged",
      "comment": "The alignment changed for the specified data type.  If packing is enabled for this\n composite, the placement of the component may be affected by a change in its alignment.\n A non-packed composite can ignore this notification.",
      "javadoc": "The alignment changed for the specified data type.  If packing is enabled for this\n composite, the placement of the component may be affected by a change in its alignment.\n A non-packed composite can ignore this notification.\n@param dt the data type whose alignment changed.",
      "static": false,
      "params": [
        {
          "name": "dt",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the data type whose alignment changed."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "repack",
      "comment": "Updates packed composite to any changes in the data organization. If the composite does\n not have packing enabled this method does nothing.\n \n NOTE: Changes to data organization is discouraged.  Attempts to use this method in such\n cases should be performed on all composites in dependency order (ignoring pointer components).",
      "javadoc": "Updates packed composite to any changes in the data organization. If the composite does\n not have packing enabled this method does nothing.\n \u003cBR\u003e\n NOTE: Changes to data organization is discouraged.  Attempts to use this method in such\n cases should be performed on all composites in dependency order (ignoring pointer components).",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getPackingType",
      "comment": "",
      "javadoc": "@return the packing type set for this composite",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.data.PackingType",
        "type_short": "PackingType",
        "comment": "the packing type set for this composite"
      },
      "throws": []
    },
    {
      "name": "isPackingEnabled",
      "comment": "Determine if this data type has its internal components currently packed\n based upon alignment and packing settings.  If disabled, component placement\n is based upon explicit placement by offset.",
      "javadoc": "Determine if this data type has its internal components currently packed\n based upon alignment and packing settings.  If disabled, component placement\n is based upon explicit placement by offset.\n@return true if this data type\u0027s components auto-packed",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this data type\u0027s components auto-packed"
      },
      "throws": []
    },
    {
      "name": "setPackingEnabled",
      "comment": "Sets whether this data type\u0027s internal components are currently packed.  The\n affect of disabled packing differs between Structure and Union.  When\n packing disabled:\n \n Structures utilize explicit component offsets and produce undefined filler\n components where defined components do not consume space.\n Unions always place components at offset 0 and do not pad for alignment.\n \n In addition, when packing is disabled the default alignment is always 1 unless a\n different minimum alignment has been set.  When packing is enabled the overall\n composite length influenced by the composite\u0027s minimum alignment setting.\n If a change in enablement occurs, the default alignment and packing behavior\n will be used.",
      "javadoc": "Sets whether this data type\u0027s internal components are currently packed.  The\n affect of disabled packing differs between {@link Structure} and {@link Union}.  When\n packing disabled:\n \u003cul\u003e\n \u003cli\u003eStructures utilize explicit component offsets and produce undefined filler\n components where defined components do not consume space.\u003c/li\u003e\n \u003cli\u003eUnions always place components at offset 0 and do not pad for alignment.\n \u003c/ul\u003e\n In addition, when packing is disabled the default alignment is always 1 unless a\n different minimum alignment has been set.  When packing is enabled the overall\n composite length influenced by the composite\u0027s minimum alignment setting.\n If a change in enablement occurs, the default alignment and packing behavior\n will be used.\n@param enabled true enables packing of components respecting component\n alignment and pack setting, whereas false disables packing.",
      "static": false,
      "params": [
        {
          "name": "enabled",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true enables packing of components respecting component\n alignment and pack setting, whereas false disables packing."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "hasExplicitPackingValue",
      "comment": "Determine if packing is enabled with an explicit packing value (see #getExplicitPackingValue()).",
      "javadoc": "Determine if packing is enabled with an explicit packing value (see {@link #getExplicitPackingValue()}).\n@return true if packing is enabled with an explicit packing value, else false.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if packing is enabled with an explicit packing value, else false."
      },
      "throws": []
    },
    {
      "name": "hasDefaultPacking",
      "comment": "Determine if default packing is enabled.",
      "javadoc": "Determine if default packing is enabled.\n@return true if default packing is enabled.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if default packing is enabled."
      },
      "throws": []
    },
    {
      "name": "getExplicitPackingValue",
      "comment": "Gets the current packing value (typically a power of 2).\n If this isn\u0027t a packed composite with an explicit packing value (see #hasExplicitPackingValue())\n then the return value is undefined.",
      "javadoc": "Gets the current packing value (typically a power of 2).\n If this isn\u0027t a packed composite with an explicit packing value (see {@link #hasExplicitPackingValue()})\n then the return value is undefined.\n@return the current packing value or an undefined non-positive value",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the current packing value or an undefined non-positive value"
      },
      "throws": []
    },
    {
      "name": "setExplicitPackingValue",
      "comment": "Sets the pack value for this composite (positive value, usually a power of 2).\n If packing was previously disabled, packing will be enabled.  This value will\n establish the maximum effective alignment for this composite and each of the\n components during the alignment computation (e.g., a value of 1 will eliminate\n any padding).  The overall composite length may be influenced by the composite\u0027s\n minimum alignment setting.",
      "javadoc": "Sets the pack value for this composite (positive value, usually a power of 2).\n If packing was previously disabled, packing will be enabled.  This value will\n establish the maximum effective alignment for this composite and each of the\n components during the alignment computation (e.g., a value of 1 will eliminate\n any padding).  The overall composite length may be influenced by the composite\u0027s\n minimum alignment setting.\n@param packingValue the new positive packing value.\n@throws IllegalArgumentException if a non-positive value is specified.",
      "static": false,
      "params": [
        {
          "name": "packingValue",
          "type_long": "int",
          "type_short": "int",
          "comment": "the new positive packing value."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "pack",
      "comment": "Same as #setExplicitPackingValue(int).",
      "javadoc": "Same as {@link #setExplicitPackingValue(int)}.\n@param packingValue the new positive packing value.\n@throws IllegalArgumentException if a non-positive value is specified.",
      "static": false,
      "params": [
        {
          "name": "packingValue",
          "type_long": "int",
          "type_short": "int",
          "comment": "the new positive packing value."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "setToDefaultPacking",
      "comment": "Enables default packing behavior.\n If packing was previously disabled, packing will be enabled.\n Composite will automatically pack based upon the alignment requirements\n of its components with overall composite length possibly influenced by the composite\u0027s\n minimum alignment setting.",
      "javadoc": "Enables default packing behavior.\n If packing was previously disabled, packing will be enabled.\n Composite will automatically pack based upon the alignment requirements\n of its components with overall composite length possibly influenced by the composite\u0027s\n minimum alignment setting.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getAlignment",
      "comment": "Get the computed alignment for this composite based upon packing and minimum\n alignment settings as well as component alignment.  If packing is disabled,\n the alignment will always be 1 unless a minimum alignment has been set.",
      "javadoc": "Get the computed alignment for this composite based upon packing and minimum\n alignment settings as well as component alignment.  If packing is disabled,\n the alignment will always be 1 unless a minimum alignment has been set.\n@return this composites alignment",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "this composites alignment"
      },
      "throws": []
    },
    {
      "name": "getAlignmentType",
      "comment": "",
      "javadoc": "@return the alignment type set for this composite",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.data.AlignmentType",
        "type_short": "AlignmentType",
        "comment": "the alignment type set for this composite"
      },
      "throws": []
    },
    {
      "name": "isDefaultAligned",
      "comment": "Whether or not this data type is using the default alignment.  When Structure packing\n is disabled the default alignment is always 1 (see Structure#setPackingEnabled(boolean).",
      "javadoc": "Whether or not this data type is using the default alignment.  When Structure packing\n is disabled the default alignment is always 1 (see {@link Structure#setPackingEnabled(boolean)}.\n@return true if this data type is using its default alignment.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this data type is using its default alignment."
      },
      "throws": []
    },
    {
      "name": "isMachineAligned",
      "comment": "Whether or not this data type is using the machine alignment value, specified by\n DataOrganization#getMachineAlignment(), for its alignment.",
      "javadoc": "Whether or not this data type is using the machine alignment value, specified by\n {@link DataOrganization#getMachineAlignment()}, for its alignment.\n@return true if this data type is using the machine alignment as its alignment.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this data type is using the machine alignment as its alignment."
      },
      "throws": []
    },
    {
      "name": "hasExplicitMinimumAlignment",
      "comment": "Determine if an explicit minimum alignment has been set (see\n #getExplicitMinimumAlignment()). An undefined value is returned if default alignment\n or machine alignment is enabled.",
      "javadoc": "Determine if an explicit minimum alignment has been set (see\n {@link #getExplicitMinimumAlignment()}). An undefined value is returned if default alignment\n or machine alignment is enabled.\n@return true if an explicit minimum alignment has been set, else false",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if an explicit minimum alignment has been set, else false"
      },
      "throws": []
    },
    {
      "name": "getExplicitMinimumAlignment",
      "comment": "Get the explicit minimum alignment setting for this Composite which contributes\n to the actual computed alignment value (see #getAlignment().",
      "javadoc": "Get the explicit minimum alignment setting for this Composite which contributes\n to the actual computed alignment value (see {@link #getAlignment()}.\n@return the minimum alignment setting for this Composite or an undefined\n non-positive value if an explicit minimum alignment has not been set.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the minimum alignment setting for this Composite or an undefined\n non-positive value if an explicit minimum alignment has not been set."
      },
      "throws": []
    },
    {
      "name": "setExplicitMinimumAlignment",
      "comment": "Sets this data type\u0027s explicit minimum alignment (positive value).\n Together with the pack setting and component alignments will\n affect the actual computed alignment of this composite.\n When packing is enabled, the alignment setting may also affect padding\n at the end of the composite and its length.  When packing is disabled,\n this setting will not affect the length of this composite.",
      "javadoc": "Sets this data type\u0027s explicit minimum alignment (positive value).\n Together with the pack setting and component alignments will\n affect the actual computed alignment of this composite.\n When packing is enabled, the alignment setting may also affect padding\n at the end of the composite and its length.  When packing is disabled,\n this setting will not affect the length of this composite.\n@param minAlignment the minimum alignment for this Composite.\n@throws IllegalArgumentException if a non-positive value is specified",
      "static": false,
      "params": [
        {
          "name": "minAlignment",
          "type_long": "int",
          "type_short": "int",
          "comment": "the minimum alignment for this Composite."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "align",
      "comment": "Same as #setExplicitMinimumAlignment(int).",
      "javadoc": "Same as {@link #setExplicitMinimumAlignment(int)}.\n@param minAlignment the explicit minimum alignment for this Composite.\n@throws IllegalArgumentException if a non-positive value is specified",
      "static": false,
      "params": [
        {
          "name": "minAlignment",
          "type_long": "int",
          "type_short": "int",
          "comment": "the explicit minimum alignment for this Composite."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "setToDefaultAligned",
      "comment": "Sets this data type\u0027s alignment to its default alignment. For packed\n composites, this data type\u0027s alignment will be based upon the components it contains and\n its current pack settings.  This is the default state and only needs to be used\n when changing from a non-default alignment type.",
      "javadoc": "Sets this data type\u0027s alignment to its default alignment. For packed\n composites, this data type\u0027s alignment will be based upon the components it contains and\n its current pack settings.  This is the default state and only needs to be used\n when changing from a non-default alignment type.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "setToMachineAligned",
      "comment": "Sets this data type\u0027s minimum alignment to the machine alignment which is\n specified by DataOrganization#getMachineAlignment(). The machine alignment is\n defined as the maximum useful alignment for the target machine.",
      "javadoc": "Sets this data type\u0027s minimum alignment to the machine alignment which is\n specified by {@link DataOrganization#getMachineAlignment()}. The machine alignment is\n defined as the maximum useful alignment for the target machine.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    }
  ]
}
