{
  "name": "Structure",
  "comment": "The structure interface.\n \n NOTE: A zero-length Structure will report a length of 1 which will result in\n improper code unit sizing since we are unable to support a defined data of length 0.\n \n NOTE: The use of zero-length bitfields within non-packed structures is discouraged since they have\n no real affect and are easily misplaced. Their use should be reserved for packed\n structures.",
  "javadoc": "The structure interface.\n \u003cp\u003e\n NOTE: A zero-length Structure will report a length of 1 which will result in\n improper code unit sizing since we are unable to support a defined data of length 0.\n \u003cp\u003e\n NOTE: The use of zero-length bitfields within non-packed structures is discouraged since they have\n no real affect and are easily misplaced. Their use should be reserved for packed\n structures.",
  "static": false,
  "implements": [
    "ghidra.program.model.data.Composite"
  ],
  "fields": [],
  "methods": [
    {
      "name": "clone",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "dtm",
          "type_long": "ghidra.program.model.data.DataTypeManager",
          "type_short": "DataTypeManager",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.Structure",
        "type_short": "Structure",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getComponent",
      "comment": "Returns the component of this structure with the indicated ordinal.",
      "javadoc": "Returns the component of this structure with the indicated ordinal.\n@param ordinal the ordinal of the component requested.\n@return the data type component.\n@throws IndexOutOfBoundsException if the ordinal is out of bounds",
      "static": false,
      "params": [
        {
          "name": "ordinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "the ordinal of the component requested."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the data type component."
      },
      "throws": [
        {
          "type_long": "java.lang.IndexOutOfBoundsException",
          "type_short": "IndexOutOfBoundsException",
          "comment": "if the ordinal is out of bounds"
        }
      ]
    },
    {
      "name": "getDefinedComponentAtOrAfterOffset",
      "comment": "Gets the first defined component located at or after the specified offset. \n Note: The returned component may be a zero-length component.",
      "javadoc": "Gets the first defined component located at or after the specified offset. \n Note: The returned component may be a zero-length component.\n@param offset the byte offset into this structure\n@return the first defined component located at or after the specified offset or null if not found.",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "int",
          "type_short": "int",
          "comment": "the byte offset into this structure"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the first defined component located at or after the specified offset or null if not found."
      },
      "throws": []
    },
    {
      "name": "getComponentContaining",
      "comment": "Gets the first non-zero-length component that contains the byte at the specified offset. \n Note that one or more components may share the same offset when a bit-field or zero-length\n component is present since these may share an offset.  A null may be returned under one of\n the following conditions:\n \n offset only corresponds to a zero-length component within a packed structure\n offset corresponds to a padding byte within a packed structure\n offset is \u003d structure length.\n \n If a bitfield is returned, and the caller supports bitfields, it is recommended that \n #getComponentsContaining(int) be invoked to gather all bitfields which contain the \n specified offset.",
      "javadoc": "Gets the first non-zero-length component that contains the byte at the specified offset. \n Note that one or more components may share the same offset when a bit-field or zero-length\n component is present since these may share an offset.  A null may be returned under one of\n the following conditions:\n \u003cul\u003e\n \u003cli\u003eoffset only corresponds to a zero-length component within a packed structure\u003c/li\u003e\n \u003cli\u003eoffset corresponds to a padding byte within a packed structure\u003c/li\u003e\n \u003cli\u003eoffset is \u0026gt;\u003d structure length.\u003c/li\u003e\n \u003c/ul\u003e\n If a bitfield is returned, and the caller supports bitfields, it is recommended that \n {@link #getComponentsContaining(int)} be invoked to gather all bitfields which contain the \n specified offset.\n@param offset the byte offset into this structure\n@return the first non-zero-length component that contains the byte at the specified offset\n or null if not found.",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "int",
          "type_short": "int",
          "comment": "the byte offset into this structure"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the first non-zero-length component that contains the byte at the specified offset\n or null if not found."
      },
      "throws": []
    },
    {
      "name": "getComponentAt",
      "comment": "Gets the first non-zero-length component that starts at the specified offset. \n Note that one or more components may share the same offset when a bit-field or zero-length\n component is present since these may share an offset.  A null may be returned under one of\n the following conditions:\n \n offset only corresponds to a zero-length component within a packed structure\n offset corresponds to a padding byte within a packed structure\n offset is contained within a component but is not the starting offset of that component\n offset is \u003d structure length\n \n If a bitfield is returned, and the caller supports bitfields, it is recommended that \n #getComponentsContaining(int) be invoked to gather all bitfields which contain the \n specified offset.",
      "javadoc": "Gets the first non-zero-length component that starts at the specified offset. \n Note that one or more components may share the same offset when a bit-field or zero-length\n component is present since these may share an offset.  A null may be returned under one of\n the following conditions:\n \u003cul\u003e\n \u003cli\u003eoffset only corresponds to a zero-length component within a packed structure\u003c/li\u003e\n \u003cli\u003eoffset corresponds to a padding byte within a packed structure\u003c/li\u003e\n \u003cli\u003eoffset is contained within a component but is not the starting offset of that component\u003c/li\u003e\n \u003cli\u003eoffset is \u0026gt;\u003d structure length\u003c/li\u003e\n \u003c/ul\u003e\n If a bitfield is returned, and the caller supports bitfields, it is recommended that \n {@link #getComponentsContaining(int)} be invoked to gather all bitfields which contain the \n specified offset.\n@param offset the byte offset into this structure\n@return the first component that starts at specified offset or null if not found.",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "int",
          "type_short": "int",
          "comment": "the byte offset into this structure"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the first component that starts at specified offset or null if not found."
      },
      "throws": []
    },
    {
      "name": "getComponentsContaining",
      "comment": "Get an ordered list of components that contain the byte at the specified offset.\n Unlike #getComponentAt(int) and #getComponentContaining(int) this method will\n include zero-length components if they exist at the specified offset.  For this reason the\n specified offset may equal the structure length to obtain and trailing zero-length components.\n Note that this method will only return more than one component when a bit-fields and/or \n zero-length components are present since these may share an offset. An empty list may be \n returned under the following conditions:\n \n offset only corresponds to a padding byte within a packed structure\n offset is equal structure length and no trailing zero-length components exist\n offset is  structure length\n ",
      "javadoc": "Get an ordered list of components that contain the byte at the specified offset.\n Unlike {@link #getComponentAt(int)} and {@link #getComponentContaining(int)} this method will\n include zero-length components if they exist at the specified offset.  For this reason the\n specified offset may equal the structure length to obtain and trailing zero-length components.\n Note that this method will only return more than one component when a bit-fields and/or \n zero-length components are present since these may share an offset. An empty list may be \n returned under the following conditions:\n \u003cul\u003e\n \u003cli\u003eoffset only corresponds to a padding byte within a packed structure\u003c/li\u003e\n \u003cli\u003eoffset is equal structure length and no trailing zero-length components exist\u003c/li\u003e\n \u003cli\u003eoffset is \u0026gt; structure length\u003c/li\u003e\n \u003c/ul\u003e\n@param offset the byte offset into this structure\n@return a list of zero or more components containing the specified offset",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "int",
          "type_short": "int",
          "comment": "the byte offset into this structure"
        }
      ],
      "return": {
        "type_long": "java.util.List\u003cghidra.program.model.data.DataTypeComponent\u003e",
        "type_short": "List",
        "comment": "a list of zero or more components containing the specified offset"
      },
      "throws": []
    },
    {
      "name": "getDataTypeAt",
      "comment": "Returns the lowest-level component that contains the specified offset. This is useful \n for structures that have sub-structures. This method is best used when working with \n known structures which do not contain bitfields or zero-length components since in \n those situations multiple components may correspond to the specified offset.  \n A similar ambiguous condition occurs if offset corresponds to a union component.",
      "javadoc": "Returns the lowest-level component that contains the specified offset. This is useful \n for structures that have sub-structures. This method is best used when working with \n known structures which do not contain bitfields or zero-length components since in \n those situations multiple components may correspond to the specified offset.  \n A similar ambiguous condition occurs if offset corresponds to a union component.\n@param offset the byte offset into this data type.\n@return a primitive component data type which contains the specified offset.",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "int",
          "type_short": "int",
          "comment": "the byte offset into this data type."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "a primitive component data type which contains the specified offset."
      },
      "throws": []
    },
    {
      "name": "insertBitField",
      "comment": "Inserts a new bitfield at the specified ordinal position in this structure. Within packed\n structures the specified byteWidth and bitOffset will be ignored since packing will occur at\n the specified ordinal position. The resulting component length and bitfield details will\n reflect the use of minimal storage sizing.\n \n For structures with packing disabled, a component shift will only occur if the bitfield placement\n conflicts with another component. If no conflict occurs, the bitfield will be placed at the\n specified location consuming any DEFAULT components as needed. When a conflict does occur a\n shift will be performed at the ordinal position based upon the specified byteWidth. When\n located onto existing bitfields they will be packed together provided they do not conflict,\n otherwise the conflict rule above applies.\n \n Supported packing starts with bit-0 (lsb) of the first byte for little-endian, and\n with bit-7 (msb) of the first byte for big-endian. This is the default behavior for most\n compilers. Insertion behavior may not work as expected if packing rules differ from this.",
      "javadoc": "Inserts a new bitfield at the specified ordinal position in this structure. Within packed\n structures the specified byteWidth and bitOffset will be ignored since packing will occur at\n the specified ordinal position. The resulting component length and bitfield details will\n reflect the use of minimal storage sizing.\n \u003cp\u003e\n For structures with packing disabled, a component shift will only occur if the bitfield placement\n conflicts with another component. If no conflict occurs, the bitfield will be placed at the\n specified location consuming any DEFAULT components as needed. When a conflict does occur a\n shift will be performed at the ordinal position based upon the specified byteWidth. When\n located onto existing bitfields they will be packed together provided they do not conflict,\n otherwise the conflict rule above applies.\n \u003cp\u003e\n Supported packing starts with bit-0 (lsb) of the first byte for little-endian, and\n with bit-7 (msb) of the first byte for big-endian. This is the default behavior for most\n compilers. Insertion behavior may not work as expected if packing rules differ from this.\n@param ordinal the ordinal of the component to be inserted.\n@param byteWidth the storage allocation unit width which contains the bitfield. Must be large\n            enough to contain the \"effective bit size\" and corresponding bitOffset. The actual\n            component size used will be recomputed during insertion.\n@param bitOffset corresponds to the bitfield left-shift amount with the storage unit when\n            viewed as big-endian. The final offset may be reduced based upon the minimal\n            storage size determined during insertion.\n@param baseDataType the bitfield base datatype (certain restrictions apply).\n@param bitSize the declared bitfield size in bits. The effective bit size may be adjusted\n            based upon the specified baseDataType.\n@param componentName the field name to associate with this component.\n@param comment the comment to associate with this component.\n@return the bitfield component created whose associated data type will be BitFieldDataType.\n@throws InvalidDataTypeException if the specified baseDataType is not a valid base type for\n             bitfields.\n@throws IndexOutOfBoundsException if ordinal is less than 0 or greater than the current\n             number of components.",
      "static": false,
      "params": [
        {
          "name": "ordinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "the ordinal of the component to be inserted."
        },
        {
          "name": "byteWidth",
          "type_long": "int",
          "type_short": "int",
          "comment": "the storage allocation unit width which contains the bitfield. Must be large\n            enough to contain the \"effective bit size\" and corresponding bitOffset. The actual\n            component size used will be recomputed during insertion."
        },
        {
          "name": "bitOffset",
          "type_long": "int",
          "type_short": "int",
          "comment": "corresponds to the bitfield left-shift amount with the storage unit when\n            viewed as big-endian. The final offset may be reduced based upon the minimal\n            storage size determined during insertion."
        },
        {
          "name": "baseDataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the bitfield base datatype (certain restrictions apply)."
        },
        {
          "name": "bitSize",
          "type_long": "int",
          "type_short": "int",
          "comment": "the declared bitfield size in bits. The effective bit size may be adjusted\n            based upon the specified baseDataType."
        },
        {
          "name": "componentName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the field name to associate with this component."
        },
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the comment to associate with this component."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the bitfield component created whose associated data type will be BitFieldDataType."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.data.InvalidDataTypeException",
          "type_short": "InvalidDataTypeException",
          "comment": "if the specified baseDataType is not a valid base type for\n             bitfields."
        },
        {
          "type_long": "java.lang.IndexOutOfBoundsException",
          "type_short": "IndexOutOfBoundsException",
          "comment": "if ordinal is less than 0 or greater than the current\n             number of components."
        }
      ]
    },
    {
      "name": "insertBitFieldAt",
      "comment": "Inserts a new bitfield at the specified location in this composite. This method is intended\n to be used with structures with packing disabled where the bitfield will be precisely placed. Within an\n packed structure the specified byteOffset, byteWidth and bitOffset will be used to identify\n the appropriate ordinal but may not be preserved. The component length will be computed based\n upon the specified parameters and will be reduced from byteWidth to its minimal size for the\n new component.\n \n When packing disabled, a component shift will only occur if the bitfield placement conflicts\n with another component. If no conflict occurs, the bitfield will be placed at the specified\n location consuming any DEFAULT components as needed. When a conflict does occur a shift will\n be performed at the point of conflict based upon the specified byteWidth. When located onto\n existing bitfields they will be packed together provided they do not conflict, otherwise the\n conflict rule above applies.\n \n Supported packing for little-endian fills lsb first, whereas big-endian fills msb first.\n Insertion behavior may not work as expected if packing rules differ from this.\n \n \n Zero length bitfields may be inserted although they have no real affect when packing disabled. \n Only the resulting byte offset within the structure is of significance in\n determining its ordinal placement.\n ",
      "javadoc": "Inserts a new bitfield at the specified location in this composite. This method is intended\n to be used with structures with packing disabled where the bitfield will be precisely placed. Within an\n packed structure the specified byteOffset, byteWidth and bitOffset will be used to identify\n the appropriate ordinal but may not be preserved. The component length will be computed based\n upon the specified parameters and will be reduced from byteWidth to its minimal size for the\n new component.\n \u003cp\u003e\n When packing disabled, a component shift will only occur if the bitfield placement conflicts\n with another component. If no conflict occurs, the bitfield will be placed at the specified\n location consuming any DEFAULT components as needed. When a conflict does occur a shift will\n be performed at the point of conflict based upon the specified byteWidth. When located onto\n existing bitfields they will be packed together provided they do not conflict, otherwise the\n conflict rule above applies.\n \u003cp\u003e\n Supported packing for little-endian fills lsb first, whereas big-endian fills msb first.\n Insertion behavior may not work as expected if packing rules differ from this.\n \u003cp\u003e\n \n Zero length bitfields may be inserted although they have no real affect when packing disabled. \n Only the resulting byte offset within the structure is of significance in\n determining its ordinal placement.\n \u003cp\u003e\n@param byteOffset the first byte offset within this structure which corresponds to the first\n            byte of the specified storage unit identified by its byteWidth.\n@param byteWidth the storage unit width which contains the bitfield. Must be large enough to\n            contain the specified bitSize and corresponding bitOffset. The actual component\n            size used will be recomputed during insertion.\n@param bitOffset corresponds to the bitfield left-shift amount with the storage unit when\n            viewed as big-endian. The final offset may be reduced based upon the minimal\n            storage size determined during insertion.\n@param baseDataType the bitfield base datatype (certain restrictions apply).\n@param componentName the field name to associate with this component.\n@param bitSize the bitfield size in bits. A bitSize of 0 may be specified although its name\n            will be ignored.\n@param comment the comment to associate with this component.\n@return the componentDataType created whose associated data type will be BitFieldDataType.\n@throws InvalidDataTypeException if the specified data type is not a valid base type for\n             bitfields.",
      "static": false,
      "params": [
        {
          "name": "byteOffset",
          "type_long": "int",
          "type_short": "int",
          "comment": "the first byte offset within this structure which corresponds to the first\n            byte of the specified storage unit identified by its byteWidth."
        },
        {
          "name": "byteWidth",
          "type_long": "int",
          "type_short": "int",
          "comment": "the storage unit width which contains the bitfield. Must be large enough to\n            contain the specified bitSize and corresponding bitOffset. The actual component\n            size used will be recomputed during insertion."
        },
        {
          "name": "bitOffset",
          "type_long": "int",
          "type_short": "int",
          "comment": "corresponds to the bitfield left-shift amount with the storage unit when\n            viewed as big-endian. The final offset may be reduced based upon the minimal\n            storage size determined during insertion."
        },
        {
          "name": "baseDataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the bitfield base datatype (certain restrictions apply)."
        },
        {
          "name": "bitSize",
          "type_long": "int",
          "type_short": "int",
          "comment": "the bitfield size in bits. A bitSize of 0 may be specified although its name\n            will be ignored."
        },
        {
          "name": "componentName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the field name to associate with this component."
        },
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the comment to associate with this component."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the componentDataType created whose associated data type will be BitFieldDataType."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.data.InvalidDataTypeException",
          "type_short": "InvalidDataTypeException",
          "comment": "if the specified data type is not a valid base type for\n             bitfields."
        }
      ]
    },
    {
      "name": "insertAtOffset",
      "comment": "Inserts a new datatype at the specified offset into this structure. Inserting a component\n will cause any conflicting components to shift down to the extent necessary to avoid a\n conflict.",
      "javadoc": "Inserts a new datatype at the specified offset into this structure. Inserting a component\n will cause any conflicting components to shift down to the extent necessary to avoid a\n conflict.\n@param offset the byte offset into the structure where the new datatype is to be inserted.\n@param dataType the datatype to insert.  If {@link DataType#DEFAULT} is specified for a packed \n \t\t\t\tstructure an {@link Undefined1DataType} will be used in its place.\n@param length the length to associate with the dataType. For fixed length types a length\n            \u0026lt;\u003d 0 will use the length of the resolved dataType.\n@return the componentDataType created.\n@throws IllegalArgumentException if the specified data type is not allowed to be inserted\n             into this composite data type or an invalid length is specified. For example,\n             suppose dt1 contains dt2. Therefore it is not valid to insert dt1 to dt2 since\n             this would cause a cyclic dependency.",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "int",
          "type_short": "int",
          "comment": "the byte offset into the structure where the new datatype is to be inserted."
        },
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the datatype to insert.  If DataType#DEFAULT is specified for a packed \n \t\t\t\tstructure an Undefined1DataType will be used in its place."
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "the length to associate with the dataType. For fixed length types a length\n            \u003d 0 will use the length of the resolved dataType."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the componentDataType created."
      },
      "throws": [
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if the specified data type is not allowed to be inserted\n             into this composite data type or an invalid length is specified. For example,\n             suppose dt1 contains dt2. Therefore it is not valid to insert dt1 to dt2 since\n             this would cause a cyclic dependency."
        }
      ]
    },
    {
      "name": "insertAtOffset",
      "comment": "Inserts a new datatype at the specified offset into this structure. Inserting a component\n will cause any conflicting components to shift down to the extent necessary to avoid a\n conflict.\n \n This method does not support bit-field insertions which must use the method \n #insertBitFieldAt(int, int, int, DataType, int, String, String).",
      "javadoc": "Inserts a new datatype at the specified offset into this structure. Inserting a component\n will cause any conflicting components to shift down to the extent necessary to avoid a\n conflict.\n \u003cp\u003e\n This method does not support bit-field insertions which must use the method \n {@link #insertBitFieldAt(int, int, int, DataType, int, String, String)}.\n@param offset the byte offset into the structure where the new datatype is to be inserted.\n@param dataType the datatype to insert.  If {@link DataType#DEFAULT} is specified for a packed \n \t\t\t\tstructure an {@link Undefined1DataType} will be used in its place.\n@param length the length to associate with the dataType. For fixed length types a length\n            \u0026lt;\u003d 0 will use the length of the resolved dataType.\n@param name the field name to associate with this component.\n@param comment the comment to associate with this component.\n@return the componentDataType created.\n@throws IllegalArgumentException if the specified data type is not allowed to be inserted\n             into this composite data type or an invalid length is specified. For example,\n             suppose dt1 contains dt2. Therefore it is not valid to insert dt1 to dt2 since\n             this would cause a cyclic dependency.",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "int",
          "type_short": "int",
          "comment": "the byte offset into the structure where the new datatype is to be inserted."
        },
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the datatype to insert.  If DataType#DEFAULT is specified for a packed \n \t\t\t\tstructure an Undefined1DataType will be used in its place."
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "the length to associate with the dataType. For fixed length types a length\n            \u003d 0 will use the length of the resolved dataType."
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the field name to associate with this component."
        },
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the comment to associate with this component."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the componentDataType created."
      },
      "throws": [
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if the specified data type is not allowed to be inserted\n             into this composite data type or an invalid length is specified. For example,\n             suppose dt1 contains dt2. Therefore it is not valid to insert dt1 to dt2 since\n             this would cause a cyclic dependency."
        }
      ]
    },
    {
      "name": "deleteAtOffset",
      "comment": "Deletes all defined components containing the specified offset in this structure. If the offset\n corresponds to a bit-field or zero-length component (e.g., 0-element array) multiple \n components may be deleted.  Bit-fields are only cleared and may leave residual undefined \n components in their place.  This method will generally reduce the length of the structure.\n The #clearAtOffset(int) method should be used for non-packed structures to \n preserve the structure length and placement of other components.",
      "javadoc": "Deletes all defined components containing the specified offset in this structure. If the offset\n corresponds to a bit-field or zero-length component (e.g., 0-element array) multiple \n components may be deleted.  Bit-fields are only cleared and may leave residual undefined \n components in their place.  This method will generally reduce the length of the structure.\n The {@link #clearAtOffset(int)} method should be used for non-packed structures to \n preserve the structure length and placement of other components.\n@param offset the byte offset into the structure where the component(s) are to be deleted.\n An offset equal to the structure length may be specified to delete any trailing zero-length \n components.\n@throws IllegalArgumentException if a negative offset is specified",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "int",
          "type_short": "int",
          "comment": "the byte offset into the structure where the component(s) are to be deleted.\n An offset equal to the structure length may be specified to delete any trailing zero-length \n components."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "if a negative offset is specified"
        }
      ]
    },
    {
      "name": "deleteAll",
      "comment": "Remove all components from this structure, effectively setting the\n length to zero.  Packing and minimum alignment settings are unaffected.",
      "javadoc": "Remove all components from this structure, effectively setting the\n length to zero.  Packing and minimum alignment settings are unaffected.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "clearAtOffset",
      "comment": "Clears all defined components containing the specified offset in this structure. If the offset\n corresponds to a bit-field or zero-length component (e.g., 0-element array) multiple \n components may be cleared.  This method will preserve the structure length and placement \n of other components since freed space will appear as undefined components.\n \n To avoid clearing zero-length components at a specified offset within a non-packed structure,\n the #replaceAtOffset(int, DataType, int, String, String) may be used with to clear\n only the sized component at the offset by specified DataType#DEFAULT as the replacement\n datatype.",
      "javadoc": "Clears all defined components containing the specified offset in this structure. If the offset\n corresponds to a bit-field or zero-length component (e.g., 0-element array) multiple \n components may be cleared.  This method will preserve the structure length and placement \n of other components since freed space will appear as undefined components.\n \u003cp\u003e\n To avoid clearing zero-length components at a specified offset within a non-packed structure,\n the {@link #replaceAtOffset(int, DataType, int, String, String)} may be used with to clear\n only the sized component at the offset by specified {@link DataType#DEFAULT} as the replacement\n datatype.\n@param offset the byte offset into the structure where the component(s) are to be deleted.",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "int",
          "type_short": "int",
          "comment": "the byte offset into the structure where the component(s) are to be deleted."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "clearComponent",
      "comment": "Clears the defined component at the specified component ordinal. Clearing a component within\n a non-packed structure causes a defined component to be replaced with a number of undefined \n components.  This may not the case when clearing a zero-length component or bit-field \n which may not result in such undefined components.  In the case of a packed structure \n clearing is always completed without backfill.",
      "javadoc": "Clears the defined component at the specified component ordinal. Clearing a component within\n a non-packed structure causes a defined component to be replaced with a number of undefined \n components.  This may not the case when clearing a zero-length component or bit-field \n which may not result in such undefined components.  In the case of a packed structure \n clearing is always completed without backfill.\n@param ordinal the ordinal of the component to clear.\n@throws IndexOutOfBoundsException if component ordinal is out of bounds",
      "static": false,
      "params": [
        {
          "name": "ordinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "the ordinal of the component to clear."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.IndexOutOfBoundsException",
          "type_short": "IndexOutOfBoundsException",
          "comment": "if component ordinal is out of bounds"
        }
      ]
    },
    {
      "name": "replace",
      "comment": "Replaces the component at the specified ordinal with a new component using the \n specified datatype, length, name and comment.  In the case of a packed structure \n a 1-for-1 replacement will occur.  In the case of a non-packed structure certain\n restrictions apply:\n \n A zero-length component may only be replaced with another zero-length component.\n If ordinal corresponds to a bit-field, all bit-fields which overlap the specified \n bit-field will be replaced.\n \n There must be sufficient space to complete the replacement factoring in the space freed \n by the consumed component(s).  If there are no remaining defined components beyond the \n consumed components the structure will expand its length as needed. For a packed structure, this \n method behaves the same as a ordinal-based delete followed by an insert.\n \n Datatypes not permitted include FactoryDataType types, non-sizable \n Dynamic types, and those which result in a circular direct dependency.\n \n NOTE: In general, it is not recommended that this method be used with non-packed \n structures where the replaced component is a bit-field.",
      "javadoc": "Replaces the component at the specified ordinal with a new component using the \n specified datatype, length, name and comment.  In the case of a packed structure \n a 1-for-1 replacement will occur.  In the case of a non-packed structure certain\n restrictions apply:\n \u003cul\u003e\n \u003cli\u003eA zero-length component may only be replaced with another zero-length component.\u003c/li\u003e\n \u003cli\u003eIf ordinal corresponds to a bit-field, all bit-fields which overlap the specified \n bit-field will be replaced.\u003c/li\u003e\n \u003c/ul\u003e\n There must be sufficient space to complete the replacement factoring in the space freed \n by the consumed component(s).  If there are no remaining defined components beyond the \n consumed components the structure will expand its length as needed. For a packed structure, this \n method behaves the same as a ordinal-based delete followed by an insert.\n \u003cp\u003e\n Datatypes not permitted include {@link FactoryDataType} types, non-sizable \n {@link Dynamic} types, and those which result in a circular direct dependency.\n \u003cp\u003e\n NOTE: In general, it is not recommended that this method be used with non-packed \n structures where the replaced component is a bit-field.\n@param ordinal the ordinal of the component to be replaced.\n@param dataType the datatype to insert. If {@link DataType#DEFAULT} is specified for a packed \n             structure an {@link Undefined1DataType} will be used in its place.  If {@link DataType#DEFAULT} \n             is specified for a non-packed structure this is equivelant to {@link #clearComponent(int)}, ignoring\n             the length, name and comment arguments.\n@param length component length for containing the specified dataType. A positive length is required \n             for sizable {@link Dynamic} datatypes and should be specified as -1 for fixed-length\n             datatypes to rely on their resolved size.\n@return the new component.\n@throws IllegalArgumentException may be caused by: 1) invalid offset specified, 2) invalid datatype or \n             associated length specified, or 3) insufficient space for replacement.\n@throws IndexOutOfBoundsException if component ordinal is out of bounds",
      "static": false,
      "params": [
        {
          "name": "ordinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "the ordinal of the component to be replaced."
        },
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the datatype to insert. If DataType#DEFAULT is specified for a packed \n             structure an Undefined1DataType will be used in its place.  If DataType#DEFAULT \n             is specified for a non-packed structure this is equivelant to #clearComponent(int), ignoring\n             the length, name and comment arguments."
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "component length for containing the specified dataType. A positive length is required \n             for sizable Dynamic datatypes and should be specified as -1 for fixed-length\n             datatypes to rely on their resolved size."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the new component."
      },
      "throws": [
        {
          "type_long": "java.lang.IndexOutOfBoundsException",
          "type_short": "IndexOutOfBoundsException",
          "comment": "if component ordinal is out of bounds"
        },
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "may be caused by: 1) invalid offset specified, 2) invalid datatype or \n             associated length specified, or 3) insufficient space for replacement."
        }
      ]
    },
    {
      "name": "replace",
      "comment": "Replaces the component at the specified ordinal with a new component using the \n specified datatype, length, name and comment.  In the case of a packed structure \n a 1-for-1 replacement will occur.  In the case of a non-packed structure certain\n restrictions apply:\n \n A zero-length component may only be replaced with another zero-length component.\n If ordinal corresponds to a bit-field, all bit-fields which overlap the specified \n bit-field will be replaced.\n \n There must be sufficient space to complete the replacement factoring in the space freed \n by the consumed component(s).  If there are no remaining defined components beyond the \n consumed components the structure will expand its length as needed. For a packed structure, this \n method behaves the same as a ordinal-based delete followed by an insert.\n \n Datatypes not permitted include FactoryDataType types, non-sizable \n Dynamic types, and those which result in a circular direct dependency.\n \n NOTE: In general, it is not recommended that this method be used with non-packed \n structures where the replaced component is a bit-field.",
      "javadoc": "Replaces the component at the specified ordinal with a new component using the \n specified datatype, length, name and comment.  In the case of a packed structure \n a 1-for-1 replacement will occur.  In the case of a non-packed structure certain\n restrictions apply:\n \u003cul\u003e\n \u003cli\u003eA zero-length component may only be replaced with another zero-length component.\u003c/li\u003e\n \u003cli\u003eIf ordinal corresponds to a bit-field, all bit-fields which overlap the specified \n bit-field will be replaced.\u003c/li\u003e\n \u003c/ul\u003e\n There must be sufficient space to complete the replacement factoring in the space freed \n by the consumed component(s).  If there are no remaining defined components beyond the \n consumed components the structure will expand its length as needed. For a packed structure, this \n method behaves the same as a ordinal-based delete followed by an insert.\n \u003cp\u003e\n Datatypes not permitted include {@link FactoryDataType} types, non-sizable \n {@link Dynamic} types, and those which result in a circular direct dependency.\n \u003cp\u003e\n NOTE: In general, it is not recommended that this method be used with non-packed \n structures where the replaced component is a bit-field.\n@param ordinal the ordinal of the component to be replaced.\n@param dataType the datatype to insert.  If {@link DataType#DEFAULT} is specified for a packed \n             structure an {@link Undefined1DataType} will be used in its place.  If {@link DataType#DEFAULT} \n             is specified for a non-packed structure this is equivelant to {@link #clearComponent(int)}, ignoring\n             the length, name and comment arguments.\n@param length component length for containing the specified dataType. A positive length is required \n             for sizable {@link Dynamic} datatypes and should be specified as -1 for fixed-length\n             datatypes to rely on their resolved size.\n@param name the field name to associate with this component or null.\n@param comment the comment to associate with this component or null.\n@return the new component.\n@throws IllegalArgumentException may be caused by: 1) invalid offset specified, 2) invalid datatype or \n             associated length specified, or 3) insufficient space for replacement.\n@throws IndexOutOfBoundsException if component ordinal is out of bounds",
      "static": false,
      "params": [
        {
          "name": "ordinal",
          "type_long": "int",
          "type_short": "int",
          "comment": "the ordinal of the component to be replaced."
        },
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the datatype to insert.  If DataType#DEFAULT is specified for a packed \n             structure an Undefined1DataType will be used in its place.  If DataType#DEFAULT \n             is specified for a non-packed structure this is equivelant to #clearComponent(int), ignoring\n             the length, name and comment arguments."
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "component length for containing the specified dataType. A positive length is required \n             for sizable Dynamic datatypes and should be specified as -1 for fixed-length\n             datatypes to rely on their resolved size."
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the field name to associate with this component or null."
        },
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the comment to associate with this component or null."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the new component."
      },
      "throws": [
        {
          "type_long": "java.lang.IndexOutOfBoundsException",
          "type_short": "IndexOutOfBoundsException",
          "comment": "if component ordinal is out of bounds"
        },
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "may be caused by: 1) invalid offset specified, 2) invalid datatype or \n             associated length specified, or 3) insufficient space for replacement."
        }
      ]
    },
    {
      "name": "replaceAtOffset",
      "comment": "Replaces all components containing the specified byte offset with a new component using the \n specified datatype, length, name and comment. If the offset corresponds to a bit-field \n more than one component may be consumed by this replacement.  \n \n This method may not be used to replace a zero-length component since there may be any number \n of zero-length components at the same offset. If the only defined component(s) at the specified\n offset are zero-length the subsequent undefined will be replaced in the case of a non-packed \n structure.  For a packed structure such a case would be treated as an insert as would an offset \n which is not contained within a component.  \n \n For a non-packed structure a replacement will attempt to consume sufficient\n space within moving other defined components.  There must be sufficient space to complete \n the replacement factoring in the space freed by the consumed component(s).  When replacing the \n last defined component the structure size will be expanded as needed to fit the new component.\n For a packed If there are no remaining defined components beyond \n the consumed components, or an offset equals to the structure length is specified, the\n structure will expand its length as needed. \n \n For a non-packed structure the new component will use the specified offset.  In the case of \n packed structure, the actual offset will be determined during a repack.\n \n Datatypes not permitted include FactoryDataType types, non-sizable \n Dynamic types, and those which result in a circular direct dependency.",
      "javadoc": "Replaces all components containing the specified byte offset with a new component using the \n specified datatype, length, name and comment. If the offset corresponds to a bit-field \n more than one component may be consumed by this replacement.  \n \u003cp\u003e\n This method may not be used to replace a zero-length component since there may be any number \n of zero-length components at the same offset. If the only defined component(s) at the specified\n offset are zero-length the subsequent undefined will be replaced in the case of a non-packed \n structure.  For a packed structure such a case would be treated as an insert as would an offset \n which is not contained within a component.  \n \u003cp\u003e\n For a non-packed structure a replacement will attempt to consume sufficient\n space within moving other defined components.  There must be sufficient space to complete \n the replacement factoring in the space freed by the consumed component(s).  When replacing the \n last defined component the structure size will be expanded as needed to fit the new component.\n For a packed If there are no remaining defined components beyond \n the consumed components, or an offset equals to the structure length is specified, the\n structure will expand its length as needed. \n \u003cp\u003e\n For a non-packed structure the new component will use the specified offset.  In the case of \n packed structure, the actual offset will be determined during a repack.\n \u003cp\u003e\n Datatypes not permitted include {@link FactoryDataType} types, non-sizable \n {@link Dynamic} types, and those which result in a circular direct dependency.\n@param offset the byte offset into the structure where the datatype is to be placed.  The specified\n             offset must be less than the length of the structure.\n@param dataType the datatype to insert.  If {@link DataType#DEFAULT} is specified for a packed \n \t\t\t   structure an {@link Undefined1DataType} will be used in its place.  If {@link DataType#DEFAULT} \n             is specified for a non-packed structure this is equivelant to clearing all components, \n             which contain the specified offset, ignoring the length, name and comment arguments.\n@param length component length for containing the specified dataType. A positive length is required \n             for sizable {@link Dynamic} datatypes and should be specified as -1 for fixed-length\n             datatypes to rely on their resolved size.\n@param name the field name to associate with this component or null.\n@param comment the comment to associate with this component or null.\n@return the new component.\n@throws IllegalArgumentException may be caused by: 1) invalid offset specified, 2) invalid datatype or \n             associated length specified, or 3) insufficient space for replacement.",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "int",
          "type_short": "int",
          "comment": "the byte offset into the structure where the datatype is to be placed.  The specified\n             offset must be less than the length of the structure."
        },
        {
          "name": "dataType",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the datatype to insert.  If DataType#DEFAULT is specified for a packed \n \t\t\t   structure an Undefined1DataType will be used in its place.  If DataType#DEFAULT \n             is specified for a non-packed structure this is equivelant to clearing all components, \n             which contain the specified offset, ignoring the length, name and comment arguments."
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "component length for containing the specified dataType. A positive length is required \n             for sizable Dynamic datatypes and should be specified as -1 for fixed-length\n             datatypes to rely on their resolved size."
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the field name to associate with this component or null."
        },
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the comment to associate with this component or null."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataTypeComponent",
        "type_short": "DataTypeComponent",
        "comment": "the new component."
      },
      "throws": [
        {
          "type_long": "java.lang.IllegalArgumentException",
          "type_short": "IllegalArgumentException",
          "comment": "may be caused by: 1) invalid offset specified, 2) invalid datatype or \n             associated length specified, or 3) insufficient space for replacement."
        }
      ]
    },
    {
      "name": "growStructure",
      "comment": "Increases the size of the structure by the specified amount by adding undefined filler at the\n end of the structure.  NOTE: This method only has an affect on non-packed structures.",
      "javadoc": "Increases the size of the structure by the specified amount by adding undefined filler at the\n end of the structure.  NOTE: This method only has an affect on non-packed structures.\n@param amount the amount by which to grow the structure.\n@throws IllegalArgumentException if amount \u0026lt; 1",
      "static": false,
      "params": [
        {
          "name": "amount",
          "type_long": "int",
          "type_short": "int",
          "comment": "the amount by which to grow the structure."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    }
  ]
}
