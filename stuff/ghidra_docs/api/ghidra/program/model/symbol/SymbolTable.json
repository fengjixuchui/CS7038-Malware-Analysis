{
  "name": "SymbolTable",
  "comment": "A SymbolTable manages the Symbols defined in a program.\n \n A Symbol is an association between an Address,\n a String name. In addition, symbols may have one or more\n References.\n \n A Reference is a 4-tuple of a source address, destination address, type,\n and either a mnemonic or operand index\n \n Any address in a program can have more than one symbol associated to it.\n At any given time, one and only one symbol will be designated as the primary.\n \n A symbol can be either global or local. Local symbols belong to some namespace other than\n the global namespace.\n \n Label and Function symbols do not have to have unique names with a namespace. All other symbols\n must be unique within a namespace and be unique with all other symbols that must be unique.\n In other words you can have a several functions named \"foo\" and several labels named \"foo\"\n in the same namespace.  But you can\u0027t have a class named \"foo\" and a namespace named \"foo\".\n But you can have a class named \"foo\" and and many functions and labels named \"foo\" all\n in the same namespace.\n \n A symbol can also be designated as dynamic. Which means the name is\n generated on-the-fly by the system based on its context.",
  "javadoc": "A SymbolTable manages the Symbols defined in a program.\n \u003cbr\u003e\n A Symbol is an association between an Address,\n a String name. In addition, symbols may have one or more\n References.\n \u003cbr\u003e\n A Reference is a 4-tuple of a source address, destination address, type,\n and either a mnemonic or operand index\n \u003cbr\u003e\n Any address in a program can have more than one symbol associated to it.\n At any given time, one and only one symbol will be designated as the primary.\n \u003cbr\u003e\n A symbol can be either global or local. Local symbols belong to some namespace other than\n the global namespace.\n \u003cbr\u003e\n Label and Function symbols do not have to have unique names with a namespace. All other symbols\n must be unique within a namespace and be unique with all other symbols that must be unique.\n In other words you can have a several functions named \"foo\" and several labels named \"foo\"\n in the same namespace.  But you can\u0027t have a class named \"foo\" and a namespace named \"foo\".\n But you can have a class named \"foo\" and and many functions and labels named \"foo\" all\n in the same namespace.\n \u003cbr\u003e\n A symbol can also be designated as dynamic. Which means the name is\n generated on-the-fly by the system based on its context.",
  "static": false,
  "implements": [],
  "fields": [],
  "methods": [
    {
      "name": "createLabel",
      "comment": "Create a label symbol with the given name associated to the given\n Address. The symbol will be global and be of type SymbolType.CODE. Label\n Symbols do not have to have unique names.\n If this is the first symbol defined for the address it becomes\n the primary.",
      "javadoc": "Create a label symbol with the given name associated to the given\n Address. The symbol will be global and be of type SymbolType.CODE. Label\n Symbols do not have to have unique names.\n If this is the first symbol defined for the address it becomes\n the primary.\n@param addr the address at which to create a symbol\n@param name the name of the symbol.\n@param source the source of this symbol\n \u003cbr\u003eSome symbol types, such as function symbols, can set the source to Symbol.DEFAULT.\n@return new code or function symbol\n@throws InvalidInputException thrown if names contains white space, is zero length, or is\n null for non-default source.\n@throws IllegalArgumentException if you try to set the source to DEFAULT for a symbol type\n that doesn\u0027t allow it, or an improper addr is specified",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address at which to create a symbol"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbol."
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source of this symbol\n Some symbol types, such as function symbols, can set the source to Symbol.DEFAULT."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "new code or function symbol"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "thrown if names contains white space, is zero length, or is\n null for non-default source."
        }
      ]
    },
    {
      "name": "createLabel",
      "comment": "Create a label symbol with the given name associated to the given\n Address and namespace. The symbol will be of type SymbolType.CODE.\n If this is the first symbol defined for the address it becomes\n the primary symbol.  If a symbol with that name already exists at the\n address, it will be returned instead with its namespace changed to the new\n namespace unless the new symbol is in the global space, in which case the namespace\n will remain as is.",
      "javadoc": "Create a label symbol with the given name associated to the given\n Address and namespace. The symbol will be of type SymbolType.CODE.\n If this is the first symbol defined for the address it becomes\n the primary symbol.  If a symbol with that name already exists at the\n address, it will be returned instead with its namespace changed to the new\n namespace unless the new symbol is in the global space, in which case the namespace\n will remain as is.\n@param addr the address at which to create a symbol\n@param name the name of the symbol.\n@param namespace the namespace of the symbol.\n@param source the source of this symbol\n \u003cbr\u003eSome symbol types, such as function symbols, can set the source to Symbol.DEFAULT.\n@return new code or function symbol\n@throws InvalidInputException thrown if names contains white space, is zero length, or is\n null for non-default source.  Also thrown if invalid parentNamespace is specified.\n@throws IllegalArgumentException if you try to set the source to DEFAULT for a symbol type\n that doesn\u0027t allow it, or an improper addr is specified",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address at which to create a symbol"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbol."
        },
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the namespace of the symbol."
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source of this symbol\n Some symbol types, such as function symbols, can set the source to Symbol.DEFAULT."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "new code or function symbol"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "thrown if names contains white space, is zero length, or is\n null for non-default source.  Also thrown if invalid parentNamespace is specified."
        }
      ]
    },
    {
      "name": "removeSymbolSpecial",
      "comment": "Removes the specified symbol from the symbol table.  If removing any non-function\n symbol the behavior will be the same as invoking Symbol#delete() on the\n symbol.  Use of this method for non-function symbols is discouraged.\n \n WARNING! If removing a function symbol the behavior differs from directly\n invoking Symbol#delete() on the function symbol.\n \n When removing a function symbol this method has the following behavior:\n \n If the function is a default symbol (e.g., FUN_12345678) this method\n has no affect and will return null\n otherwise if another label exists at the function entry point, that\n label will be removed and the function will be renamed with that labels name\n If no other labels exist at the function entry, the function will\n be renamed to the default function name\n \n Any reference bound to a symbol removed will loose that\n symbol specific binding.",
      "javadoc": "Removes the specified symbol from the symbol table.  If removing any \u003cb\u003enon-function\u003c/b\u003e\n symbol the behavior will be the same as invoking {@link Symbol#delete()} on the\n symbol.  Use of this method for non-function symbols is discouraged.\n \u003cp\u003e\n \u003cb\u003eWARNING!\u003c/b\u003e If removing a function symbol the behavior differs from directly\n invoking {@link Symbol#delete()} on the function symbol.\n \u003cp\u003e\n When removing a function symbol this method has the following behavior:\n \u003cul\u003e\n \u003cli\u003eIf the function is a default symbol (e.g., FUN_12345678) this method\n has no affect and will return null\u003c/li\u003e\n \u003cli\u003eotherwise if another label exists at the function entry point, that\n label will be removed and the function will be renamed with that labels name\u003c/li\u003e\n \u003cli\u003eIf no other labels exist at the function entry, the function will\n be renamed to the default function name\u003c/li\u003e\n \u003c/ul\u003e\n Any reference bound to a symbol removed will loose that\n symbol specific binding.\n@param sym the symbol to be removed.\n@return false, if removal of the symbol fails",
      "static": false,
      "params": [
        {
          "name": "sym",
          "type_long": "ghidra.program.model.symbol.Symbol",
          "type_short": "Symbol",
          "comment": "the symbol to be removed."
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "false, if removal of the symbol fails"
      },
      "throws": []
    },
    {
      "name": "getSymbol",
      "comment": "Get the symbol for the given symbol ID.",
      "javadoc": "Get the symbol for the given symbol ID.\n@param symbolID the id of the symbol to be retrieved.\n@return null if there is no symbol with the given ID.",
      "static": false,
      "params": [
        {
          "name": "symbolID",
          "type_long": "long",
          "type_short": "long",
          "comment": "the id of the symbol to be retrieved."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "null if there is no symbol with the given ID."
      },
      "throws": []
    },
    {
      "name": "getSymbol",
      "comment": "Get the symbol with the given name, address, and namespace.\n \n Note that for a symbol to be uniquely specified, all these parameters are required. Any\n method that queries for symbols using just one or two of these parameters will return a list\n of symbols. This method will not return a default thunk (i.e., thunk function symbol with\n default source type) since it mirrors the name and parent namespace of the function it\n thunks.",
      "javadoc": "Get the symbol with the given name, address, and namespace.\n \u003cP\u003e\n Note that for a symbol to be uniquely specified, all these parameters are required. Any\n method that queries for symbols using just one or two of these parameters will return a list\n of symbols. This method will not return a default thunk (i.e., thunk function symbol with\n default source type) since it mirrors the name and parent namespace of the function it\n thunks.\n@param name the name of the symbol to retrieve\n@param addr the address of the symbol to retrieve\n@param namespace the namespace of the symbol to retrieve. May be null which indicates global\n namespace.\n@return the symbol which matches the specified criteria or null if not found\n@see #getGlobalSymbol(String, Address) for a convenience method if the namespace is the\n global namespace.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbol to retrieve"
        },
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address of the symbol to retrieve"
        },
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the namespace of the symbol to retrieve. May be null which indicates global\n namespace."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the symbol which matches the specified criteria or null if not found"
      },
      "throws": []
    },
    {
      "name": "getGlobalSymbol",
      "comment": "Get the global symbol with the given name and address.  Note that this results in a single\n Symbol because of an additional restriction that allows only one symbol with a given name\n at the same address and namespace (in this case the global namespace).\n\n This is just a convenience method for #getSymbol(String, Address, Namespace) where\n the namespace is the global namespace.\n \n NOTE: This method will not return a default thunk (i.e., thunk function symbol with\n default source type) since it mirrors the name and parent namespace of the function it\n thunks.",
      "javadoc": "Get the global symbol with the given name and address.  Note that this results in a single\n Symbol because of an additional restriction that allows only one symbol with a given name\n at the same address and namespace (in this case the global namespace).\n\n \u003cP\u003eThis is just a convenience method for {@link #getSymbol(String, Address, Namespace)} where\n the namespace is the global namespace.\n \n \u003cp\u003eNOTE: This method will not return a default thunk (i.e., thunk function symbol with\n default source type) since it mirrors the name and parent namespace of the function it\n thunks.\n@param name the name of the symbol to retrieve\n@param addr the address of the symbol to retrieve\n@return the symbol which matches the specified criteria in the global namespace or null if\n not found\n@see #getSymbol(String, Address, Namespace)",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbol to retrieve"
        },
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address of the symbol to retrieve"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the symbol which matches the specified criteria in the global namespace or null if\n not found"
      },
      "throws": []
    },
    {
      "name": "getGlobalSymbols",
      "comment": "Returns a list of all global symbols with the given name.\n \n NOTE: This method will not return default thunks (i.e.,\n thunk function symbol with default source type).",
      "javadoc": "Returns a list of all global symbols with the given name.\n \n \u003cp\u003eNOTE: This method will not return default thunks (i.e.,\n thunk function symbol with default source type).\u003c/p\u003e\n@param name the name of the symbols to retrieve.\n@return a list of all global symbols with the given name.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbols to retrieve."
        }
      ],
      "return": {
        "type_long": "java.util.List\u003cghidra.program.model.symbol.Symbol\u003e",
        "type_short": "List",
        "comment": "a list of all global symbols with the given name."
      },
      "throws": []
    },
    {
      "name": "getLabelOrFunctionSymbols",
      "comment": "Returns all the label or function symbols that have the given name in the given namespace.\n \n NOTE: This method will not return a default thunk (i.e., thunk function symbol with default source type)\n since it mirrors the name and parent namespace of the function it thunks.",
      "javadoc": "Returns all the label or function symbols that have the given name in the given namespace.\n \n \u003cp\u003eNOTE: This method will not return a default thunk (i.e., thunk function symbol with default source type)\n since it mirrors the name and parent namespace of the function it thunks.\u003c/p\u003e\n@param name the name of the symbols to search for.\n@param namespace the namespace to search.  If null, then the global namespace is assumed.\n@return a list of all the label or function symbols with the given name in the given namespace.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbols to search for."
        },
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the namespace to search.  If null, then the global namespace is assumed."
        }
      ],
      "return": {
        "type_long": "java.util.List\u003cghidra.program.model.symbol.Symbol\u003e",
        "type_short": "List",
        "comment": "a list of all the label or function symbols with the given name in the given namespace."
      },
      "throws": []
    },
    {
      "name": "getNamespaceSymbol",
      "comment": "Returns a generic namespace symbol with the given name in the given namespace.",
      "javadoc": "Returns a generic namespace symbol with the given name in the given namespace.\n@param name the name of the namespace symbol to retrieve.\n@param namespace the namespace containing the symbol to retrieve.\n@return a generic namespace symbol with the given name in the given namespace.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the namespace symbol to retrieve."
        },
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the namespace containing the symbol to retrieve."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "a generic namespace symbol with the given name in the given namespace."
      },
      "throws": []
    },
    {
      "name": "getLibrarySymbol",
      "comment": "Returns the library symbol with the given name.",
      "javadoc": "Returns the library symbol with the given name.\n@param name the name of the library symbol to retrieve.\n@return the library symbol with the given name.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the library symbol to retrieve."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the library symbol with the given name."
      },
      "throws": []
    },
    {
      "name": "getClassSymbol",
      "comment": "Returns the class symbol with the given name in the given namespace.",
      "javadoc": "Returns the class symbol with the given name in the given namespace.\n@param name the name of the class.\n@param namespace the namespace to search for the class.\n@return the class symbol with the given name in the given namespace.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the class."
        },
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the namespace to search for the class."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the class symbol with the given name in the given namespace."
      },
      "throws": []
    },
    {
      "name": "getParameterSymbol",
      "comment": "Returns the parameter symbol with the given name in the given namespace.",
      "javadoc": "Returns the parameter symbol with the given name in the given namespace.\n@param name the name of the parameter.\n@param namespace the namespace (function) to search for the class.\n@return the parameter symbol with the given name in the given namespace.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the parameter."
        },
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the namespace (function) to search for the class."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the parameter symbol with the given name in the given namespace."
      },
      "throws": []
    },
    {
      "name": "getLocalVariableSymbol",
      "comment": "Returns the local variable symbol with the given name in the given namespace.",
      "javadoc": "Returns the local variable symbol with the given name in the given namespace.\n@param name the name of the local variable.\n@param namespace the namespace (function) to search for the class.\n@return the local variable symbol with the given name in the given namespace.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the local variable."
        },
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the namespace (function) to search for the class."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the local variable symbol with the given name in the given namespace."
      },
      "throws": []
    },
    {
      "name": "getSymbols",
      "comment": "Returns a list of all symbols with the given name in the given namespace.\n \n NOTE: The resulting iterator will not return default thunks (i.e.,\n thunk function symbol with default source type).",
      "javadoc": "Returns a list of all symbols with the given name in the given namespace.\n \n \u003cp\u003eNOTE: The resulting iterator will not return default thunks (i.e.,\n thunk function symbol with default source type).\u003c/p\u003e\n@param name the name of the symbols to retrieve.\n@param namespace the namespace to search for symbols.\n@return all symbols which satisfy specified criteria",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbols to retrieve."
        },
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the namespace to search for symbols."
        }
      ],
      "return": {
        "type_long": "java.util.List\u003cghidra.program.model.symbol.Symbol\u003e",
        "type_short": "List",
        "comment": "all symbols which satisfy specified criteria"
      },
      "throws": []
    },
    {
      "name": "getVariableSymbol",
      "comment": "Returns a symbol that is either a parameter or local variable.  There can be only\n one because these symbol types have a unique name requirement.",
      "javadoc": "Returns a symbol that is either a parameter or local variable.  There can be only\n one because these symbol types have a unique name requirement.\n@param name the name of the variable.\n@param function the function to search.\n@return a parameter or local variable symbol with the given name.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the variable."
        },
        {
          "name": "function",
          "type_long": "ghidra.program.model.listing.Function",
          "type_short": "Function",
          "comment": "the function to search."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "a parameter or local variable symbol with the given name."
      },
      "throws": []
    },
    {
      "name": "getNamespace",
      "comment": "Returns the namespace with the given name in the given parent namespace.  The namespace\n returned can be either a generic namespace or a class or library.  It does not include\n functions.",
      "javadoc": "Returns the namespace with the given name in the given parent namespace.  The namespace\n returned can be either a generic namespace or a class or library.  It does not include\n functions.\n@param name the name of the namespace to be retrieved.\n@param namespace the parent namespace of the namespace to be retrieved.\n@return the namespace with the given name in the given parent namespace.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the namespace to be retrieved."
        },
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the parent namespace of the namespace to be retrieved."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Namespace",
        "type_short": "Namespace",
        "comment": "the namespace with the given name in the given parent namespace."
      },
      "throws": []
    },
    {
      "name": "getSymbols",
      "comment": "Returns all the symbols with the given name.\n \n NOTE: The resulting iterator will not return default thunks (i.e.,\n thunk function symbol with default source type).",
      "javadoc": "Returns all the symbols with the given name.\n \n \u003cp\u003eNOTE: The resulting iterator will not return default thunks (i.e.,\n thunk function symbol with default source type).\u003c/p\u003e\n@param name the name of symbols to search for.\n@return array of symbols with the given name",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of symbols to search for."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "array of symbols with the given name"
      },
      "throws": []
    },
    {
      "name": "getAllSymbols",
      "comment": "Returns an iterator over all symbols, including Dynamic symbols if\n includeDynamicSymbols is true.",
      "javadoc": "Returns an iterator over all symbols, including Dynamic symbols if\n includeDynamicSymbols is true.\n@param includeDynamicSymbols if true, the iterator will include dynamicSymbols\n@return symbol iterator",
      "static": false,
      "params": [
        {
          "name": "includeDynamicSymbols",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true, the iterator will include dynamicSymbols"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "symbol iterator"
      },
      "throws": []
    },
    {
      "name": "getSymbol",
      "comment": "Returns the symbol that this reference is associated with.",
      "javadoc": "Returns the symbol that this reference is associated with.\n@param ref the reference to find the associated symbol for.\n@return referenced symbol",
      "static": false,
      "params": [
        {
          "name": "ref",
          "type_long": "ghidra.program.model.symbol.Reference",
          "type_short": "Reference",
          "comment": "the reference to find the associated symbol for."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "referenced symbol"
      },
      "throws": []
    },
    {
      "name": "getPrimarySymbol",
      "comment": "Returns the primary symbol at the specified\n address.  This method will always return null if the address specified\n is neither a Memory address nor an External address.",
      "javadoc": "Returns the primary symbol at the specified\n address.  This method will always return null if the address specified\n is neither a Memory address nor an External address.\n@param addr the address at which to retrieve the primary symbol\n@return symbol, or null if no symbol at that address",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address at which to retrieve the primary symbol"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "symbol, or null if no symbol at that address"
      },
      "throws": []
    },
    {
      "name": "getSymbols",
      "comment": "Returns all the symbols at the given address.  When addr is a memory address\n the primary symbol will be returned in array slot 0.\n WARNING! Use of this method with a Variable address is highly discouraged since\n a single Variable address could be used multiple times by many functions.\n Note that unless all the symbols are needed at once, you should consider using\n the #getSymbolsAsIterator(Address) method instead.",
      "javadoc": "Returns all the symbols at the given address.  When addr is a memory address\n the primary symbol will be returned in array slot 0.\n WARNING! Use of this method with a Variable address is highly discouraged since\n a single Variable address could be used multiple times by many functions.\n Note that unless all the symbols are needed at once, you should consider using\n the {@link #getSymbolsAsIterator(Address)} method instead.\n@param addr the address at which to retrieve all symbols.\n@return a zero-length array when no symbols are defined at address.\n@see #getSymbolsAsIterator(Address)",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address at which to retrieve all symbols."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol[]",
        "type_short": "ghidra.program.model.symbol.Symbol[]",
        "comment": "a zero-length array when no symbols are defined at address."
      },
      "throws": []
    },
    {
      "name": "getSymbolsAsIterator",
      "comment": "Returns a symbol iterator over all the symbols at the given address.  Use this instead of\n #getSymbols(Address) when you do not need to get all symbols, but rather are\n searching for a particular symbol.   This method prevents all symbols at the given address\n from being loaded up front.",
      "javadoc": "Returns a symbol iterator over all the symbols at the given address.  Use this instead of\n {@link #getSymbols(Address)} when you do not need to get all symbols, but rather are\n searching for a particular symbol.   This method prevents all symbols at the given address\n from being loaded up front.\n@param addr the address at which to retrieve all symbols\n@return an iterator over all the symbols at the given address\n@see #getSymbols(Address)",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address at which to retrieve all symbols"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "an iterator over all the symbols at the given address"
      },
      "throws": []
    },
    {
      "name": "getUserSymbols",
      "comment": "Returns an array of all user defined symbols at the given address",
      "javadoc": "Returns an array of all user defined symbols at the given address\n@param addr the address at which to retrieve all user defined symbols.\n@return all symbols at specified address",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address at which to retrieve all user defined symbols."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol[]",
        "type_short": "ghidra.program.model.symbol.Symbol[]",
        "comment": "all symbols at specified address"
      },
      "throws": []
    },
    {
      "name": "getSymbols",
      "comment": "Returns an iterator over all the symbols in the given namespace\n \n NOTE: The resulting iterator will not return default thunks (i.e.,\n thunk function symbol with default source type).",
      "javadoc": "Returns an iterator over all the symbols in the given namespace\n \n \u003cp\u003eNOTE: The resulting iterator will not return default thunks (i.e.,\n thunk function symbol with default source type).\u003c/p\u003e\n@param namespace the namespace to search for symbols.\n@return symbol iterator",
      "static": false,
      "params": [
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the namespace to search for symbols."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "symbol iterator"
      },
      "throws": []
    },
    {
      "name": "getSymbols",
      "comment": "Returns an iterator over all the symbols in the given namespace\n \n NOTE: This method will not return a default thunk (i.e.,\n thunk function symbol with default source type).",
      "javadoc": "Returns an iterator over all the symbols in the given namespace\n \n \u003cp\u003eNOTE: This method will not return a default thunk (i.e.,\n thunk function symbol with default source type).\u003c/p\u003e\n@param namespaceID the namespace ID to search for symbols.\n@return symbol iterator",
      "static": false,
      "params": [
        {
          "name": "namespaceID",
          "type_long": "long",
          "type_short": "long",
          "comment": "the namespace ID to search for symbols."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "symbol iterator"
      },
      "throws": []
    },
    {
      "name": "hasSymbol",
      "comment": "Return true if there exists a symbol at the given address.",
      "javadoc": "Return true if there exists a symbol at the given address.\n@param addr address to check for an existing symbol\n@return true if any symbol exists",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "address to check for an existing symbol"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if any symbol exists"
      },
      "throws": []
    },
    {
      "name": "getDynamicSymbolID",
      "comment": "Get the unique symbol ID for a dynamic symbol associated with the specified addr.\n The generation of this symbol ID does not reflect the presence of a dynamic symbol\n at the specified addr.  This symbol ID should not be permanently stored since the encoding\n may change between software releases.",
      "javadoc": "Get the unique symbol ID for a dynamic symbol associated with the specified addr.\n The generation of this symbol ID does not reflect the presence of a dynamic symbol\n at the specified addr.  This symbol ID should not be permanently stored since the encoding\n may change between software releases.\n@param addr dynamic symbol address\n@return unique symbol ID",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "dynamic symbol address"
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "unique symbol ID"
      },
      "throws": []
    },
    {
      "name": "getSymbolIterator",
      "comment": "Returns a an iterator over all symbols that match the given search string.\n \n NOTE: The iterator is in the forward direction only and will not return default thunk\n functions. The resulting iterator will not return default thunks (i.e.,\n thunk function symbol with default source type).",
      "javadoc": "Returns a an iterator over all symbols that match the given search string.\n \n \u003cp\u003eNOTE: The iterator is in the forward direction only and will not return default thunk\n functions. The resulting iterator will not return default thunks (i.e.,\n thunk function symbol with default source type).\n@param searchStr the string to search for (may contain * to match any sequence\n or ? to match a single char)\n@param caseSensitive flag to determine if the search is case sensitive or not.\n@return symbol iterator",
      "static": false,
      "params": [
        {
          "name": "searchStr",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the string to search for (may contain * to match any sequence\n or ? to match a single char)"
        },
        {
          "name": "caseSensitive",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "flag to determine if the search is case sensitive or not."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "symbol iterator"
      },
      "throws": []
    },
    {
      "name": "getSymbols",
      "comment": "Returns all the symbols of the given type within the given address set.",
      "javadoc": "Returns all the symbols of the given type within the given address set.\n@param set the address set in which to look for symbols of the given type (required).\n@param type the SymbolType to look for.\n@param forward the direction within the addressSet to search\n@return symbol iterator",
      "static": false,
      "params": [
        {
          "name": "set",
          "type_long": "ghidra.program.model.address.AddressSetView",
          "type_short": "AddressSetView",
          "comment": "the address set in which to look for symbols of the given type (required)."
        },
        {
          "name": "type",
          "type_long": "ghidra.program.model.symbol.SymbolType",
          "type_short": "SymbolType",
          "comment": "the SymbolType to look for."
        },
        {
          "name": "forward",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "the direction within the addressSet to search"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "symbol iterator"
      },
      "throws": []
    },
    {
      "name": "getNumSymbols",
      "comment": "Returns the total number of symbols in the table.",
      "javadoc": "Returns the total number of symbols in the table.\n@return total number of symbols",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "total number of symbols"
      },
      "throws": []
    },
    {
      "name": "getSymbolIterator",
      "comment": "Get iterator over all label symbols. Labels are defined on memory locations.",
      "javadoc": "Get iterator over all label symbols. Labels are defined on memory locations.\n@return symbol iterator",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "symbol iterator"
      },
      "throws": []
    },
    {
      "name": "getDefinedSymbols",
      "comment": "Returns an iterator over all defined symbols in no particular order.",
      "javadoc": "Returns an iterator over all defined symbols in no particular order.\n@return symbol iterator",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "symbol iterator"
      },
      "throws": []
    },
    {
      "name": "getExternalSymbol",
      "comment": "Returns the external symbol with the given name.",
      "javadoc": "Returns the external symbol with the given name.\n@param name the name of the symbol to be retrieved.\n@return symbol, or null if no external symbol has that name",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbol to be retrieved."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "symbol, or null if no external symbol has that name"
      },
      "throws": []
    },
    {
      "name": "getExternalSymbols",
      "comment": "Returns all the external symbols with the given name.",
      "javadoc": "Returns all the external symbols with the given name.\n@param name the name of symbols to search for.\n@return array of external symbols with the given name",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of symbols to search for."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "array of external symbols with the given name"
      },
      "throws": []
    },
    {
      "name": "getExternalSymbols",
      "comment": "Returns an iterator over all defined external symbols in no particular order.",
      "javadoc": "Returns an iterator over all defined external symbols in no particular order.\n@return symbol iterator",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "symbol iterator"
      },
      "throws": []
    },
    {
      "name": "getSymbolIterator",
      "comment": "Returns an iterator over all symbols.",
      "javadoc": "Returns an iterator over all symbols.\n@param forward true means the iterator is in the forward direction\n@return symbol iterator",
      "static": false,
      "params": [
        {
          "name": "forward",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true means the iterator is in the forward direction"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "symbol iterator"
      },
      "throws": []
    },
    {
      "name": "getSymbolIterator",
      "comment": "Get iterator over all symbols starting at\n the specified startAddr",
      "javadoc": "Get iterator over all symbols starting at\n the specified \u003ccode\u003estartAddr\u003c/code\u003e\n@param startAddr the address at which to begin the iteration.\n@param forward true means the iterator is in the forward direction\n@return symbol iterator",
      "static": false,
      "params": [
        {
          "name": "startAddr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address at which to begin the iteration."
        },
        {
          "name": "forward",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true means the iterator is in the forward direction"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "symbol iterator"
      },
      "throws": []
    },
    {
      "name": "getPrimarySymbolIterator",
      "comment": "Get iterator over all primary symbols.",
      "javadoc": "Get iterator over all primary symbols.\n@param forward true means the iterator is in the forward direction\n@return symbol iterator",
      "static": false,
      "params": [
        {
          "name": "forward",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true means the iterator is in the forward direction"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "symbol iterator"
      },
      "throws": []
    },
    {
      "name": "getPrimarySymbolIterator",
      "comment": "Get iterator over only primary symbols starting at\n the specified startAddr",
      "javadoc": "Get iterator over only primary symbols starting at\n the specified \u003ccode\u003estartAddr\u003c/code\u003e\n@param startAddr the address at which to begin the iteration.\n@param forward true means the iterator is in the forward direction\n@return symbol iterator",
      "static": false,
      "params": [
        {
          "name": "startAddr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address at which to begin the iteration."
        },
        {
          "name": "forward",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true means the iterator is in the forward direction"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "symbol iterator"
      },
      "throws": []
    },
    {
      "name": "getPrimarySymbolIterator",
      "comment": "Get an iterator over symbols at addresses in the given addressSet",
      "javadoc": "Get an iterator over symbols at addresses in the given addressSet\n@param asv the set of address over which to iterate symbols (required).\n@param forward true means the iterator is in the forward direction\n@return symbol iterator",
      "static": false,
      "params": [
        {
          "name": "asv",
          "type_long": "ghidra.program.model.address.AddressSetView",
          "type_short": "AddressSetView",
          "comment": "the set of address over which to iterate symbols (required)."
        },
        {
          "name": "forward",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true means the iterator is in the forward direction"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "symbol iterator"
      },
      "throws": []
    },
    {
      "name": "addExternalEntryPoint",
      "comment": "Sets the given address to be an external entry point.",
      "javadoc": "Sets the given address to be an external entry point.\n@param addr the address to set as an external entry point.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to set as an external entry point."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "removeExternalEntryPoint",
      "comment": "Removes the given address as an external entry point.",
      "javadoc": "Removes the given address as an external entry point.\n@param addr the address to remove as an external entry point.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to remove as an external entry point."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isExternalEntryPoint",
      "comment": "Returns true if the given address has been set as an external entry point.",
      "javadoc": "Returns true if the given address has been set as an external entry point.\n@param addr address to test for external entry point.\n@return true if specified address has been marked as an entry point, else false",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "address to test for external entry point."
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if specified address has been marked as an entry point, else false"
      },
      "throws": []
    },
    {
      "name": "getExternalEntryPointIterator",
      "comment": "Get forward/back iterator over addresses that are entry points.",
      "javadoc": "Get forward/back iterator over addresses that are entry points.\n@return entry-point address iterator",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.AddressIterator",
        "type_short": "AddressIterator",
        "comment": "entry-point address iterator"
      },
      "throws": []
    },
    {
      "name": "getLabelHistory",
      "comment": "Get the label history objects for the given address. The history\n object records changes made to labels at some address.",
      "javadoc": "Get the label history objects for the given address. The history\n object records changes made to labels at some address.\n@param addr address of the label change\n@return array of history objects",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "address of the label change"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.LabelHistory[]",
        "type_short": "ghidra.program.model.symbol.LabelHistory[]",
        "comment": "array of history objects"
      },
      "throws": []
    },
    {
      "name": "getLabelHistory",
      "comment": "Get an iterator over all the label history objects.",
      "javadoc": "Get an iterator over all the label history objects.\n@return label history iterator",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.Iterator\u003cghidra.program.model.symbol.LabelHistory\u003e",
        "type_short": "Iterator",
        "comment": "label history iterator"
      },
      "throws": []
    },
    {
      "name": "hasLabelHistory",
      "comment": "Return true if there is a history of label changes at the given address.",
      "javadoc": "Return true if there is a history of label changes at the given address.\n@param addr the address to check for symbol history.\n@return true if label history exists for specified address, else false",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to check for symbol history."
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if label history exists for specified address, else false"
      },
      "throws": []
    },
    {
      "name": "getNamespace",
      "comment": "Returns the lowest level Namespace within which the specified address is contained.",
      "javadoc": "Returns the lowest level Namespace within which the specified address is contained.\n@param addr the address for which to finds its enclosing namespace.\n@return namespace which contains specified address",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address for which to finds its enclosing namespace."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Namespace",
        "type_short": "Namespace",
        "comment": "namespace which contains specified address"
      },
      "throws": []
    },
    {
      "name": "getClassNamespaces",
      "comment": "Returns all Class Namespaces defined within the program in an arbitrary ordering.",
      "javadoc": "Returns all Class Namespaces defined within the program in an arbitrary ordering.\n@return iterator of {@link GhidraClass}",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.Iterator\u003cghidra.program.model.listing.GhidraClass\u003e",
        "type_short": "Iterator",
        "comment": "iterator of GhidraClass"
      },
      "throws": []
    },
    {
      "name": "createClass",
      "comment": "Create a class namespace in the given parent namespace.",
      "javadoc": "Create a class namespace in the given parent namespace.\n@param parent parent namespace\n@param name name of the namespace\n@param source the source of this class namespace\u0027s symbol\n@return new class namespace\n@throws DuplicateNameException thrown if another non function or label symbol exists with\n the given name\n@throws InvalidInputException throw if the name has invalid characters or is null\n@throws IllegalArgumentException if you try to set the source to \u0027Symbol.DEFAULT\u0027.",
      "static": false,
      "params": [
        {
          "name": "parent",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "parent namespace"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "name of the namespace"
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source of this class namespace\u0027s symbol"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.GhidraClass",
        "type_short": "GhidraClass",
        "comment": "new class namespace"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "thrown if another non function or label symbol exists with\n the given name"
        },
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "throw if the name has invalid characters or is null"
        }
      ]
    },
    {
      "name": "getChildren",
      "comment": "Returns an iterator over all symbols that have the given symbol as its parent.\n \n NOTE: The resulting iterator will not return default thunks (i.e., thunk function symbol\n with default source type).",
      "javadoc": "Returns an iterator over all symbols that have the given symbol as its parent.\n \n \u003cp\u003eNOTE: The resulting iterator will not return default thunks (i.e., thunk function symbol\n with default source type).\n@param parentSymbol the parent symbol\n@return symbol iterator",
      "static": false,
      "params": [
        {
          "name": "parentSymbol",
          "type_long": "ghidra.program.model.symbol.Symbol",
          "type_short": "Symbol",
          "comment": "the parent symbol"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.SymbolIterator",
        "type_short": "SymbolIterator",
        "comment": "symbol iterator"
      },
      "throws": []
    },
    {
      "name": "createExternalLibrary",
      "comment": "Creates a Library namespace with the given name.",
      "javadoc": "Creates a Library namespace with the given name.\n@param name the name of the new Library namespace\n@param source the source of this external library\u0027s symbol\n@return the new Library namespace.\n@throws InvalidInputException if the name is invalid.\n@throws IllegalArgumentException if you try to set the source to \u0027Symbol.DEFAULT\u0027.\n@throws DuplicateNameException thrown if another non function or label\n symbol exists with the given name",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the new Library namespace"
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source of this external library\u0027s symbol"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Library",
        "type_short": "Library",
        "comment": "the new Library namespace."
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "thrown if another non function or label\n symbol exists with the given name"
        },
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if the name is invalid."
        }
      ]
    },
    {
      "name": "createNameSpace",
      "comment": "Creates a new namespace.",
      "javadoc": "Creates a new namespace.\n@param parent the parent namespace for the new namespace\n@param name the name of the new namespace\n@param source the source of this namespace\u0027s symbol\n@return the new Namespace object.\n@throws DuplicateNameException thrown if another non function or label symbol\n exists with the given name\n@throws InvalidInputException if the name is invalid.\n@throws IllegalArgumentException if you try to set the source to \u0027Symbol.DEFAULT\u0027.",
      "static": false,
      "params": [
        {
          "name": "parent",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the parent namespace for the new namespace"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the new namespace"
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source of this namespace\u0027s symbol"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Namespace",
        "type_short": "Namespace",
        "comment": "the new Namespace object."
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "thrown if another non function or label symbol\n exists with the given name"
        },
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if the name is invalid."
        }
      ]
    },
    {
      "name": "convertNamespaceToClass",
      "comment": "Converts the given namespace to a class namespace",
      "javadoc": "Converts the given namespace to a class namespace\n@param namespace the namespace to convert\n@return the new class\n@throws IllegalArgumentException if the given parent namespace is from a different program\n         than that of this symbol table\n@throws ConcurrentModificationException if the given parent namespace has been deleted",
      "static": false,
      "params": [
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the namespace to convert"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.GhidraClass",
        "type_short": "GhidraClass",
        "comment": "the new class"
      },
      "throws": []
    },
    {
      "name": "getOrCreateNameSpace",
      "comment": "Gets an existing namespace with the given name in the given parent.  If no namespace exists,\n then one will be created.",
      "javadoc": "Gets an existing namespace with the given name in the given parent.  If no namespace exists,\n then one will be created.\n@param parent the parent namespace\n@param name the namespace name\n@param source the source type for the namespace if one is created\n@return the namespace\n@throws DuplicateNameException thrown if another non function or label symbol exists with\n         the given name\n@throws InvalidInputException if the name is invalid\n@throws IllegalArgumentException if the given parent namespace is from a different program\n         than that of this symbol table\n@throws ConcurrentModificationException if the given parent namespace has been deleted",
      "static": false,
      "params": [
        {
          "name": "parent",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the parent namespace"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the namespace name"
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source type for the namespace if one is created"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Namespace",
        "type_short": "Namespace",
        "comment": "the namespace"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "thrown if another non function or label symbol exists with\n         the given name"
        },
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if the name is invalid"
        }
      ]
    }
  ]
}
