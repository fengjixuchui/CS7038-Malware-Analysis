{
  "name": "SymbolUtilities",
  "comment": "Class with static methods to deal with symbol strings.",
  "javadoc": "Class with static methods to deal with symbol strings.",
  "static": false,
  "implements": [],
  "extends": "java.lang.Object",
  "fields": [
    {
      "name": "MAX_SYMBOL_NAME_LENGTH",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "2000"
    },
    {
      "name": "DEFAULT_SUBROUTINE_PREFIX",
      "comment": "Default prefix for a subroutine",
      "javadoc": "Default prefix for a subroutine",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"SUB_\""
    },
    {
      "name": "DEFAULT_SYMBOL_PREFIX",
      "comment": "Default prefix for a reference that has flow\n but is not a call.",
      "javadoc": "Default prefix for a reference that has flow\n but is not a call.",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"LAB_\""
    },
    {
      "name": "DEFAULT_DATA_PREFIX",
      "comment": "Default prefix for a data reference.",
      "javadoc": "Default prefix for a data reference.",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"DAT_\""
    },
    {
      "name": "DEFAULT_UNKNOWN_PREFIX",
      "comment": "Default prefix for reference that is unknown.",
      "javadoc": "Default prefix for reference that is unknown.",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"UNK_\""
    },
    {
      "name": "DEFAULT_EXTERNAL_ENTRY_PREFIX",
      "comment": "Default prefix for an entry point.",
      "javadoc": "Default prefix for an entry point.",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"EXT_\""
    },
    {
      "name": "DEFAULT_FUNCTION_PREFIX",
      "comment": "Default prefix for a function.",
      "javadoc": "Default prefix for a function.",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"FUN_\""
    },
    {
      "name": "DEFAULT_INTERNAL_REF_PREFIX",
      "comment": "Default prefix for a reference that is offcut.",
      "javadoc": "Default prefix for a reference that is offcut.",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"OFF_\""
    },
    {
      "name": "UNDERSCORE",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"_\""
    },
    {
      "name": "PLUS",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"+\""
    },
    {
      "name": "UNK_LEVEL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "0"
    },
    {
      "name": "DAT_LEVEL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "1"
    },
    {
      "name": "LAB_LEVEL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "2"
    },
    {
      "name": "SUB_LEVEL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "3"
    },
    {
      "name": "EXT_LEVEL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "5"
    },
    {
      "name": "FUN_LEVEL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "6"
    },
    {
      "name": "DYNAMIC_PREFIX_ARRAY",
      "comment": "Array of default prefixes.",
      "javadoc": "Array of default prefixes.",
      "static": true,
      "type_long": "java.lang.String[]",
      "type_short": "java.lang.String[]",
      "constant_value": null
    },
    {
      "name": "DYNAMIC_DATA_TYPE_PREFIXES",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.util.List\u003cjava.lang.String\u003e",
      "type_short": "List",
      "constant_value": null
    },
    {
      "name": "MIN_LABEL_ADDRESS_DIGITS",
      "comment": "Any dynamic label will have an address with this minimum length or longer",
      "javadoc": "Any dynamic label will have an address with this minimum length or longer",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "4"
    },
    {
      "name": "ORDINAL_PREFIX",
      "comment": "The standard prefix for denoting the ordinal\n values of a symbol.",
      "javadoc": "The standard prefix for denoting the ordinal\n values of a symbol.",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"Ordinal_\""
    },
    {
      "name": "INVALIDCHARS",
      "comment": "Invalid characters for a symbol name.",
      "javadoc": "Invalid characters for a symbol name.",
      "static": true,
      "type_long": "char[]",
      "type_short": "char[]",
      "constant_value": null
    },
    {
      "name": "CASE_INSENSITIVE_SYMBOL_NAME_COMPARATOR",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.util.Comparator\u003cghidra.program.model.symbol.Symbol\u003e",
      "type_short": "Comparator",
      "constant_value": null
    }
  ],
  "methods": [
    {
      "name": "\u003cinit\u003e",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getDynamicDataTypePrefixes",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [],
      "return": {
        "type_long": "java.util.List\u003cjava.lang.String\u003e",
        "type_short": "List",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getOrdinalValue",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "symbolName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "containsInvalidChars",
      "comment": "Check for invalid characters\n (space, colon, asterisk, plus, bracket)\n in labels.",
      "javadoc": "Check for invalid characters\n (space, colon, asterisk, plus, bracket)\n in labels.\n@param str the string to be checked for invalid characters.\n@return boolean true if no invalid chars",
      "static": true,
      "params": [
        {
          "name": "str",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the string to be checked for invalid characters."
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "boolean true if no invalid chars"
      },
      "throws": []
    },
    {
      "name": "getDefaultFunctionName",
      "comment": "Generates a default function name for a given address.",
      "javadoc": "Generates a default function name for a given address.\n@param addr the entry point of the function.\n@return the default generated name for the function.",
      "static": true,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the entry point of the function."
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the default generated name for the function."
      },
      "throws": []
    },
    {
      "name": "isReservedExternalDefaultName",
      "comment": "Returns true if the specified name is reserved as a default external name.",
      "javadoc": "Returns true if the specified name is reserved as a default external name.\n@param name\n@param addrFactory\n@return true if the specified name is reserved as a default external name.",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "addrFactory",
          "type_long": "ghidra.program.model.address.AddressFactory",
          "type_short": "AddressFactory",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the specified name is reserved as a default external name."
      },
      "throws": []
    },
    {
      "name": "getDefaultExternalFunctionName",
      "comment": "Generates a default external name for an external function",
      "javadoc": "Generates a default external name for an external function\n@param addr the memory address referred to by the external.\n@return the default generated name for the external.",
      "static": true,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the memory address referred to by the external."
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the default generated name for the external."
      },
      "throws": []
    },
    {
      "name": "getDefaultExternalName",
      "comment": "Generates a default external name for a given external data/code location.",
      "javadoc": "Generates a default external name for a given external data/code location.\n@param addr the memory address referred to by the external.\n@param dt data type associated with the specified external memory address\n@return the default generated name for the external.",
      "static": true,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the memory address referred to by the external."
        },
        {
          "name": "dt",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "data type associated with the specified external memory address"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the default generated name for the external."
      },
      "throws": []
    },
    {
      "name": "isReservedDynamicLabelName",
      "comment": "Returns true if the given name could match a default dynamic label (EXT, LAB, SUB, FUN, DAT)\n at some address.\n WARNING! Does not handle dynamic labels which use data-type prefixes -\n see #isDynamicSymbolPattern(String, boolean) for more liberal check",
      "javadoc": "Returns true if the given name could match a default dynamic label (EXT, LAB, SUB, FUN, DAT)\n at some address.\n WARNING! Does not handle dynamic labels which use data-type prefixes -\n see {@link #isDynamicSymbolPattern(String, boolean)} for more liberal check",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "addrFactory",
          "type_long": "ghidra.program.model.address.AddressFactory",
          "type_short": "AddressFactory",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "validateName",
      "comment": "Validate the given symbol name: cannot be null, cannot be an empty string, cannot contain blank\n characters, cannot be a reserved name.",
      "javadoc": "Validate the given symbol name: cannot be null, cannot be an empty string, cannot contain blank\n characters, cannot be a reserved name.\n@param name symbol name to be validated\n@throws InvalidInputException invalid or reserved name has been specified",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "symbol name to be validated"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "invalid or reserved name has been specified"
        }
      ]
    },
    {
      "name": "startsWithDefaultDynamicPrefix",
      "comment": "Returns true if the given name starts with a possible default symbol prefix.",
      "javadoc": "Returns true if the given name starts with a possible default symbol prefix.\n@param name the name string to test.\n@return true if name starts with a know dynamic prefix",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name string to test."
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if name starts with a know dynamic prefix"
      },
      "throws": []
    },
    {
      "name": "findDynamicPrefix",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isDynamicSymbolPattern",
      "comment": "Tests if the given name is a possible dynamic symbol name.\n WARNING! This method should be used carefully since it will return true for\n any name which starts with a known dynamic label prefix or ends with an \u0027_\u0027 \n followed by a valid hex value.",
      "javadoc": "Tests if the given name is a possible dynamic symbol name.\n WARNING! This method should be used carefully since it will return true for\n any name which starts with a known dynamic label prefix or ends with an \u0027_\u0027 \n followed by a valid hex value.\n@param name the name to test\n@param caseSensitive true if case matters.\n@return true if name is a possible dynamic symbol name, else false",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name to test"
        },
        {
          "name": "caseSensitive",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if case matters."
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if name is a possible dynamic symbol name, else false"
      },
      "throws": []
    },
    {
      "name": "isHexDigits",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "suffix",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isHexDigit",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "c",
          "type_long": "char",
          "type_short": "char",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isInvalidChar",
      "comment": "Returns true if the specified char\n is not valid for use in a symbol name",
      "javadoc": "Returns true if the specified char\n is not valid for use in a symbol name\n@param c the character to be tested as a valid symbol character.\n@return return true if c is an invalid char within a symbol name, else false",
      "static": true,
      "params": [
        {
          "name": "c",
          "type_long": "char",
          "type_short": "char",
          "comment": "the character to be tested as a valid symbol character."
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "return true if c is an invalid char within a symbol name, else false"
      },
      "throws": []
    },
    {
      "name": "replaceInvalidChars",
      "comment": "Removes from the given string any invalid characters or replaces\n them with underscores.\n\n For example:\n given \"a:b*c\", the return value would be \"a_b_c\"",
      "javadoc": "Removes from the given string any invalid characters or replaces\n them with underscores.\n\n For example:\n given \"a:b*c\", the return value would be \"a_b_c\"\n@param str the string to have invalid chars converted to underscores or removed.\n@param replaceWithUnderscore - true means replace the invalid\n chars with underscore. if false, then just drop the invalid chars\n@return modified string",
      "static": true,
      "params": [
        {
          "name": "str",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the string to have invalid chars converted to underscores or removed."
        },
        {
          "name": "replaceWithUnderscore",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "- true means replace the invalid\n chars with underscore. if false, then just drop the invalid chars"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "modified string"
      },
      "throws": []
    },
    {
      "name": "getDynamicOffcutName",
      "comment": "Create a dynamic label name for an offcut reference.",
      "javadoc": "Create a dynamic label name for an offcut reference.\n@param addr the address at which to create an offcut reference name.\n@return dynamic offcut label name",
      "static": true,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address at which to create an offcut reference name."
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "dynamic offcut label name"
      },
      "throws": []
    },
    {
      "name": "getDynamicName",
      "comment": "Create a name for a dynamic symbol with a 3-letter prefix based upon reference level\n and an address.  Acceptable referenceLevel\u0027s are: \n #UNK_LEVEL, #DAT_LEVEL, #LAB_LEVEL, #SUB_LEVEL, \n #EXT_LEVEL, #FUN_LEVEL.",
      "javadoc": "Create a name for a dynamic symbol with a 3-letter prefix based upon reference level\n and an address.  Acceptable referenceLevel\u0027s are: \n {@link #UNK_LEVEL}, {@link #DAT_LEVEL}, {@link #LAB_LEVEL}, {@link #SUB_LEVEL}, \n {@link #EXT_LEVEL}, {@link #FUN_LEVEL}.\n@param referenceLevel the type of reference for which to create a dynamic name.\n@param addr the address at which to create a dynamic name.\n@return dynamic symbol name",
      "static": true,
      "params": [
        {
          "name": "referenceLevel",
          "type_long": "int",
          "type_short": "int",
          "comment": "the type of reference for which to create a dynamic name."
        },
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address at which to create a dynamic name."
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "dynamic symbol name"
      },
      "throws": []
    },
    {
      "name": "getDynamicName",
      "comment": "Create a name for a dynamic symbol.",
      "javadoc": "Create a name for a dynamic symbol.\n@param program the current program\n@param addr the address of the symbol for which to generate a name\n@return a name for the symbol at the given address",
      "static": true,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": "the current program"
        },
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address of the symbol for which to generate a name"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "a name for the symbol at the given address"
      },
      "throws": []
    },
    {
      "name": "getDynamicDataName",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "data",
          "type_long": "ghidra.program.model.listing.Data",
          "type_short": "Data",
          "comment": ""
        },
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": ""
        },
        {
          "name": "refLevel",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "generateOffcutDataName",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "data",
          "type_long": "ghidra.program.model.listing.Data",
          "type_short": "Data",
          "comment": ""
        },
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": ""
        },
        {
          "name": "offcutOffset",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        },
        {
          "name": "refLevel",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        },
        {
          "name": "isString",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getDynamicInstructionName",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": ""
        },
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": ""
        },
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": ""
        },
        {
          "name": "refLevel",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getDyanmicOffcutInstructionName",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": ""
        },
        {
          "name": "codeUnitAddress",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": ""
        },
        {
          "name": "diff",
          "type_long": "long",
          "type_short": "long",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "normalizeSegmentedAddress",
      "comment": "normalize to code unit address (in case we have segmented addresses)",
      "javadoc": "normalize to code unit address (in case we have segmented addresses)",
      "static": true,
      "params": [
        {
          "name": "codeUnit",
          "type_long": "ghidra.program.model.listing.CodeUnit",
          "type_short": "CodeUnit",
          "comment": ""
        },
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "parseDynamicName",
      "comment": "Parse a dynamic name and return its address or null if unable to parse.",
      "javadoc": "Parse a dynamic name and return its address or null if unable to parse.\n@param factory address factory\n@param name the dynamic label name to parse into an address.\n@return address corresponding to symbol name if it satisfies possible dynamic naming\n or null if unable to parse address fro name",
      "static": true,
      "params": [
        {
          "name": "factory",
          "type_long": "ghidra.program.model.address.AddressFactory",
          "type_short": "AddressFactory",
          "comment": "address factory"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the dynamic label name to parse into an address."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "address corresponding to symbol name if it satisfies possible dynamic naming\n or null if unable to parse address fro name"
      },
      "throws": []
    },
    {
      "name": "findAddressSpace",
      "comment": "Returns the addressSpace that matches the largest range of parsed pieces, ignoring the first and\n last piece (which can\u0027t be part of an addressSpace name).  In other words if the array of strings\n passed in is {\"a\",\"b\",\"c\",\"d\",\"e\"}, it will test for addresSpaces named \"b_c_d\", then \"c_d\", and\n finally \"d\".",
      "javadoc": "Returns the addressSpace that matches the largest range of parsed pieces, ignoring the first and\n last piece (which can\u0027t be part of an addressSpace name).  In other words if the array of strings\n passed in is {\"a\",\"b\",\"c\",\"d\",\"e\"}, it will test for addresSpaces named \"b_c_d\", then \"c_d\", and\n finally \"d\".\n@param factory the address factory containing the valid addressSpaces.\n@param pieces the array of parsed label pieces\n@return The addressSpace the matches the biggest string, or the default space if no match is found.",
      "static": true,
      "params": [
        {
          "name": "factory",
          "type_long": "ghidra.program.model.address.AddressFactory",
          "type_short": "AddressFactory",
          "comment": "the address factory containing the valid addressSpaces."
        },
        {
          "name": "pieces",
          "type_long": "java.lang.String[]",
          "type_short": "java.lang.String[]",
          "comment": "the array of parsed label pieces"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.AddressSpace",
        "type_short": "AddressSpace",
        "comment": "The addressSpace the matches the biggest string, or the default space if no match is found."
      },
      "throws": []
    },
    {
      "name": "buildSpaceName",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "pieces",
          "type_long": "java.lang.String[]",
          "type_short": "java.lang.String[]",
          "comment": ""
        },
        {
          "name": "start",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        },
        {
          "name": "end",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getAddressString",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getDefaultParamName",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "ordinal",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isDefaultParameterName",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getDefaultLocalName",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": ""
        },
        {
          "name": "stackOffset",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        },
        {
          "name": "firstUseOffset",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getDefaultLocalName",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": ""
        },
        {
          "name": "storage",
          "type_long": "ghidra.program.model.listing.VariableStorage",
          "type_short": "VariableStorage",
          "comment": ""
        },
        {
          "name": "firstUseOffset",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isDefaultLocalName",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": ""
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "storage",
          "type_long": "ghidra.program.model.listing.VariableStorage",
          "type_short": "VariableStorage",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getVariableAddressString",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isPossibleDefaultLocalOrParamName",
      "comment": "Returns true if the given name is a possible default parameter name or local variable name",
      "javadoc": "Returns true if the given name is a possible default parameter name or local variable name\n@param name the name to check to see if it is a possible default local or parameter name\n@return true if the given name is a possible default parameter name or local variable name",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name to check to see if it is a possible default local or parameter name"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the given name is a possible default parameter name or local variable name"
      },
      "throws": []
    },
    {
      "name": "isPossibleDefaultExternalName",
      "comment": "Checks if the given name could be a default external location name",
      "javadoc": "Checks if the given name could be a default external location name\n@param name the name to check\n@return true if the given name is a possible default external location name",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name to check"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the given name is a possible default external location name"
      },
      "throws": []
    },
    {
      "name": "isDefaultLocalStackName",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "removeFirstUseOffset",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "str",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getAddressAppendedName",
      "comment": "Creates the standard symbol name for symbols that have the addresses appended to the \n name following an \"@\" character in order to make it unique.",
      "javadoc": "Creates the standard symbol name for symbols that have the addresses appended to the \n name following an \"@\" character in order to make it unique.\n@param name the \"true\" name of the symbol\n@param address the address to be appended\n@return the name with the address appended.",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the \"true\" name of the symbol"
        },
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to be appended"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the name with the address appended."
      },
      "throws": []
    },
    {
      "name": "getAddressAppendedName",
      "comment": "Creates the a symbol name for symbols that have the addresses appended to the \n name in order to make it unique.",
      "javadoc": "Creates the a symbol name for symbols that have the addresses appended to the \n name in order to make it unique.\n@param name the \"true\" name of the symbol\n@param address the address to be appended\n@param suffixSeparator \"@\" or \"_\"\n@return the name with the address appended.",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the \"true\" name of the symbol"
        },
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to be appended"
        },
        {
          "name": "suffixSeparator",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "\"@\" or \"_\""
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the name with the address appended."
      },
      "throws": []
    },
    {
      "name": "getCleanSymbolName",
      "comment": "Gets the base symbol name regardless of whether or not the address has been appended.",
      "javadoc": "Gets the base symbol name regardless of whether or not the address has been appended.\n@param symbol the symbol to get the clean name for.\n@return the base symbol name where the {@literal \"@\u003caddress\u003e\"} has been stripped away if it exists.",
      "static": true,
      "params": [
        {
          "name": "symbol",
          "type_long": "ghidra.program.model.symbol.Symbol",
          "type_short": "Symbol",
          "comment": "the symbol to get the clean name for."
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the base symbol name where the  has been stripped away if it exists."
      },
      "throws": []
    },
    {
      "name": "getCleanSymbolName",
      "comment": "Gets the base symbol name regardless of whether or not the address has been appended \n using either the standard \"@\" separator, or the less preferred \"_\" separator.  The\n address string extension must match that which is produced by the \n #getAddressString(Address) method for it to be recognized.",
      "javadoc": "Gets the base symbol name regardless of whether or not the address has been appended \n using either the standard \"@\" separator, or the less preferred \"_\" separator.  The\n address string extension must match that which is produced by the \n {@link #getAddressString(Address)} method for it to be recognized.\n@param symbolName a symbol name to get the clean name for.\n@param address the symbol\u0027s address\n@return the base symbol name where the {@literal \"@\u003caddress\u003e\"} has been stripped away if it exists.",
      "static": true,
      "params": [
        {
          "name": "symbolName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "a symbol name to get the clean name for."
        },
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the symbol\u0027s address"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the base symbol name where the  has been stripped away if it exists."
      },
      "throws": []
    },
    {
      "name": "getSymbolTypeDisplayName",
      "comment": "Returns display text suitable for describing in the GUI the SymbolType of the\n given symbol",
      "javadoc": "Returns display text suitable for describing in the GUI the {@link SymbolType} of the\n given symbol\n@param symbol The symbol from which to get the SymbolType\n@return a display string for the SymbolType",
      "static": true,
      "params": [
        {
          "name": "symbol",
          "type_long": "ghidra.program.model.symbol.Symbol",
          "type_short": "Symbol",
          "comment": "The symbol from which to get the SymbolType"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "a display string for the SymbolType"
      },
      "throws": []
    },
    {
      "name": "getExpectedLabelOrFunctionSymbol",
      "comment": "Returns the unique global label or function symbol with the given name. Also, logs if there\n is not exactly one symbol with that name.",
      "javadoc": "Returns the unique global label or function symbol with the given name. Also, logs if there\n is not exactly one symbol with that name.\n@param program the program to search.\n@param symbolName the name of the global label or function symbol to search.\n@param errorConsumer the object to use for reporting errors via it\u0027s accept() method.\n@return symbol if a unique label/function symbol with name is found or null",
      "static": true,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": "the program to search."
        },
        {
          "name": "symbolName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the global label or function symbol to search."
        },
        {
          "name": "errorConsumer",
          "type_long": "java.util.function.Consumer\u003cjava.lang.String\u003e",
          "type_short": "Consumer",
          "comment": "the object to use for reporting errors via it\u0027s accept() method."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "symbol if a unique label/function symbol with name is found or null"
      },
      "throws": []
    },
    {
      "name": "getLabelOrFunctionSymbol",
      "comment": "Returns the unique global label or function symbol with the given name. Also, logs if there\n is more than one symbol with that name.",
      "javadoc": "Returns the unique global label or function symbol with the given name. Also, logs if there\n is more than one symbol with that name.\n@param program the program to search.\n@param symbolName the name of the global label or function symbol to search.\n@param errorConsumer the object to use for reporting errors via it\u0027s accept() method.\n@return symbol if a unique label/function symbol with name is found or null",
      "static": true,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": "the program to search."
        },
        {
          "name": "symbolName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the global label or function symbol to search."
        },
        {
          "name": "errorConsumer",
          "type_long": "java.util.function.Consumer\u003cjava.lang.String\u003e",
          "type_short": "Consumer",
          "comment": "the object to use for reporting errors via it\u0027s accept() method."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "symbol if a unique label/function symbol with name is found or null"
      },
      "throws": []
    },
    {
      "name": "createPreferredLabelOrFunctionSymbol",
      "comment": "Create label symbol giving preference to non-global symbols.  An existing function symbol\n may be returned.  If attempting to create a global symbol and the name already exists \n at the address no symbol will be created and null will be returned.  \n If attempting to create a non-global symbol, which does not exist,\n and a global symbol does exist with same name its namespace will be changed.",
      "javadoc": "Create label symbol giving preference to non-global symbols.  An existing function symbol\n may be returned.  If attempting to create a global symbol and the name already exists \n at the address no symbol will be created and null will be returned.  \n If attempting to create a non-global symbol, which does not exist,\n and a global symbol does exist with same name its namespace will be changed.\n@param program program within which the symbol should be created\n@param address memory address where symbol should be created\n@param namespace symbol namespace or null for global\n@param name symbol name\n@param source symbol source type\n@return new or existing label or function symbol or null if creating a global symbol\n whose name already exists at address\n@throws InvalidInputException if invalid symbol name provided",
      "static": true,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": "program within which the symbol should be created"
        },
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "memory address where symbol should be created"
        },
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "symbol namespace or null for global"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "symbol name"
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "symbol source type"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "new or existing label or function symbol or null if creating a global symbol\n whose name already exists at address"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.InvalidInputException",
          "type_short": "InvalidInputException",
          "comment": "if invalid symbol name provided"
        }
      ]
    },
    {
      "name": "getSymbolNameComparator",
      "comment": "Returns a comparator for symbols.  The comparison is based upon the name.  This call\n replaces the former compareTo method on Symbol.  This comparator returned here\n is case-insensitive.",
      "javadoc": "Returns a comparator for symbols.  The comparison is based upon the name.  This call\n replaces the former \u003ccode\u003ecompareTo\u003c/code\u003e method on Symbol.  This comparator returned here\n is case-insensitive.\n@return the comparator",
      "static": true,
      "params": [],
      "return": {
        "type_long": "java.util.Comparator\u003cghidra.program.model.symbol.Symbol\u003e",
        "type_short": "Comparator",
        "comment": "the comparator"
      },
      "throws": []
    }
  ]
}
