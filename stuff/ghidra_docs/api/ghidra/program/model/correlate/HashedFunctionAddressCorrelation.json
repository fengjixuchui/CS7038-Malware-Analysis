{
  "name": "HashedFunctionAddressCorrelation",
  "comment": "Correlator to construct a 1-1 map between the Instructions of two similar Functions. Matching is performed\n via a greedy algorithm that looks for sequences (n-grams) of Instructions that are similar between the two Functions.\n Similarity of two sequences is determined by comparing hashes generated by the HashCalculator object.\n \n 1) Potential sequences and their hashes are generated for both functions (see HashStore).\n 2) Sequences are pulled from the HashStore based on the uniqueness of a potential match and on the size of the sequence.\n 3) If a unique match is found between sequences, it is extended in either direction as far as possible,\n    as constrained by HashCalculator and the containing basic-blocks.\n 4) The matching Instruction pairs are put in the final map and removed from further sequence lists\n    to allow other potential matches to be considered.\n 5) Sequences with no corresponding match are also removed from consideration.\n 6) Sequences are limited to a single basic-block, and the algorithm is basic-block aware.\n    Once a match establishes a correspondence between a pair of basic blocks, the algorithm uses\n    that information to further narrow in on and disambiguate matching sequences.\n 7) If a particular sequence has matches that are not unique, the algorithm tries to disambiguate the potential\n    matches by looking at parent/child relationships of the containing basic-blocks. (see DisambiguateStrategy)\n 8) Multiple passes are attempted, each time the set of potential sequences is completely regenerated,\n    varying the range of sequence sizes for which a match is attempted and other hash parameters. This\n    allows matches discovered by earlier passes to disambiguate sequences in later passes.",
  "javadoc": "Correlator to construct a 1-1 map between the Instructions of two similar Functions. Matching is performed\n via a greedy algorithm that looks for sequences (n-grams) of Instructions that are similar between the two Functions.\n Similarity of two sequences is determined by comparing hashes generated by the HashCalculator object.\n \n 1) Potential sequences and their hashes are generated for both functions (see HashStore).\n 2) Sequences are pulled from the HashStore based on the uniqueness of a potential match and on the size of the sequence.\n 3) If a unique match is found between sequences, it is extended in either direction as far as possible,\n    as constrained by HashCalculator and the containing basic-blocks.\n 4) The matching Instruction pairs are put in the final map and removed from further sequence lists\n    to allow other potential matches to be considered.\n 5) Sequences with no corresponding match are also removed from consideration.\n 6) Sequences are limited to a single basic-block, and the algorithm is basic-block aware.\n    Once a match establishes a correspondence between a pair of basic blocks, the algorithm uses\n    that information to further narrow in on and disambiguate matching sequences.\n 7) If a particular sequence has matches that are not unique, the algorithm tries to disambiguate the potential\n    matches by looking at parent/child relationships of the containing basic-blocks. (see DisambiguateStrategy)\n 8) Multiple passes are attempted, each time the set of potential sequences is completely regenerated,\n    varying the range of sequence sizes for which a match is attempted and other hash parameters. This\n    allows matches discovered by earlier passes to disambiguate sequences in later passes.",
  "static": false,
  "implements": [
    "ghidra.program.util.FunctionAddressCorrelation"
  ],
  "extends": "java.lang.Object",
  "fields": [
    {
      "name": "srcFunction",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.program.model.listing.Function",
      "type_short": "Function",
      "constant_value": null
    },
    {
      "name": "destFunction",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.program.model.listing.Function",
      "type_short": "Function",
      "constant_value": null
    },
    {
      "name": "srcToDest",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.util.TreeMap\u003cghidra.program.model.address.Address,ghidra.program.model.address.Address\u003e",
      "type_short": "TreeMap",
      "constant_value": null
    },
    {
      "name": "destToSrc",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "java.util.TreeMap\u003cghidra.program.model.address.Address,ghidra.program.model.address.Address\u003e",
      "type_short": "TreeMap",
      "constant_value": null
    },
    {
      "name": "srcStore",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.program.model.correlate.HashStore",
      "type_short": "HashStore",
      "constant_value": null
    },
    {
      "name": "destStore",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.program.model.correlate.HashStore",
      "type_short": "HashStore",
      "constant_value": null
    },
    {
      "name": "hashCalc",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.program.model.correlate.HashCalculator",
      "type_short": "HashCalculator",
      "constant_value": null
    },
    {
      "name": "monitor",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.util.task.TaskMonitor",
      "type_short": "TaskMonitor",
      "constant_value": null
    }
  ],
  "methods": [
    {
      "name": "\u003cinit\u003e",
      "comment": "Correlates addresses between the two specified functions.",
      "javadoc": "Correlates addresses between the two specified functions.\n@param function1 the first function\n@param function2 the second function\n@param mon the task monitor that indicates progress and allows the user to cancel.\n@throws CancelledException if the user cancels\n@throws MemoryAccessException if either functions memory can\u0027t be accessed.",
      "static": false,
      "params": [
        {
          "name": "function1",
          "type_long": "ghidra.program.model.listing.Function",
          "type_short": "Function",
          "comment": "the first function"
        },
        {
          "name": "function2",
          "type_long": "ghidra.program.model.listing.Function",
          "type_short": "Function",
          "comment": "the second function"
        },
        {
          "name": "mon",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": "the task monitor that indicates progress and allows the user to cancel."
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": "if the user cancels"
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if either functions memory can\u0027t be accessed."
        }
      ]
    },
    {
      "name": "getFirstProgram",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Program",
        "type_short": "Program",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getSecondProgram",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Program",
        "type_short": "Program",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getAddressesInFirst",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.AddressSetView",
        "type_short": "AddressSetView",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getAddressesInSecond",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.AddressSetView",
        "type_short": "AddressSetView",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getTotalInstructionsInFirst",
      "comment": "Gets the total number of instructions that are in the first function.",
      "javadoc": "Gets the total number of instructions that are in the first function.\n@return the first function\u0027s instruction count.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the first function\u0027s instruction count."
      },
      "throws": []
    },
    {
      "name": "getTotalInstructionsInSecond",
      "comment": "Gets the total number of instructions that are in the second function.",
      "javadoc": "Gets the total number of instructions that are in the second function.\n@return the second function\u0027s instruction count.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the second function\u0027s instruction count."
      },
      "throws": []
    },
    {
      "name": "numMatchedInstructionsInFirst",
      "comment": "Determines the number of instructions from the first function that match an instruction\n in the second function.",
      "javadoc": "Determines the number of instructions from the first function that match an instruction\n in the second function.\n@return the number of instructions in the first function that have matches.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of instructions in the first function that have matches."
      },
      "throws": []
    },
    {
      "name": "numMatchedInstructionsInSecond",
      "comment": "Determines the number of instructions from the second function that match an instruction\n in the first function.",
      "javadoc": "Determines the number of instructions from the second function that match an instruction\n in the first function.\n@return the number of instructions in the second function that have matches.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of instructions in the second function that have matches."
      },
      "throws": []
    },
    {
      "name": "getUnmatchedInstructionsInFirst",
      "comment": "Determines the number of instructions from the first function that do not match an \n instruction in the second function.",
      "javadoc": "Determines the number of instructions from the first function that do not match an \n instruction in the second function.\n@return the number of instructions in the first function without matches.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.List\u003cghidra.program.model.listing.Instruction\u003e",
        "type_short": "List",
        "comment": "the number of instructions in the first function without matches."
      },
      "throws": []
    },
    {
      "name": "getUnmatchedInstructionsInSecond",
      "comment": "Determines the number of instructions from the second function that do not match an \n instruction in the first function.",
      "javadoc": "Determines the number of instructions from the second function that do not match an \n instruction in the first function.\n@return the number of instructions in the second function without matches.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.List\u003cghidra.program.model.listing.Instruction\u003e",
        "type_short": "List",
        "comment": "the number of instructions in the second function without matches."
      },
      "throws": []
    },
    {
      "name": "declareMatch",
      "comment": "Finalize a match between two n-grams.  Extend the match is possible, add the matching Instruction pairs to\n the final map, and remove the Instructions from further match consideration.",
      "javadoc": "Finalize a match between two n-grams.  Extend the match is possible, add the matching Instruction pairs to\n the final map, and remove the Instructions from further match consideration.\n@param srcEntry is the matching source HashEntry\n@param srcInstruct is (the starting Instruction of) the source n-gram\n@param destEntry is the matching destination HashEntry\n@param destInstruct is (the starting Instruction of) the destination n-gram\n@throws MemoryAccessException",
      "static": false,
      "params": [
        {
          "name": "srcEntry",
          "type_long": "ghidra.program.model.correlate.HashEntry",
          "type_short": "HashEntry",
          "comment": "is the matching source HashEntry"
        },
        {
          "name": "srcInstruct",
          "type_long": "ghidra.program.model.correlate.InstructHash",
          "type_short": "InstructHash",
          "comment": "is (the starting Instruction of) the source n-gram"
        },
        {
          "name": "destEntry",
          "type_long": "ghidra.program.model.correlate.HashEntry",
          "type_short": "HashEntry",
          "comment": "is the matching destination HashEntry"
        },
        {
          "name": "destInstruct",
          "type_long": "ghidra.program.model.correlate.InstructHash",
          "type_short": "InstructHash",
          "comment": "is (the starting Instruction of) the destination n-gram"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": ""
        }
      ]
    },
    {
      "name": "constructDisambiguatorTree",
      "comment": "Given multiple n-grams producing the same hash, generate secondary hashes based on the each n-gram and\n its containing block, using the DisambiguateStrategy.  Generate a histogram of secondary hashes and return\n it to the caller.",
      "javadoc": "Given multiple n-grams producing the same hash, generate secondary hashes based on the each n-gram and\n its containing block, using the DisambiguateStrategy.  Generate a histogram of secondary hashes and return\n it to the caller.\n@param entry is the HashEntry producing the duplicates\n@param strategy is the DisambiguateStrategy to use to produce secondary hashes\n@return the map of DisambiguatorEntry objects containing the histogram counts\n@throws CancelledException\n@throws MemoryAccessException",
      "static": true,
      "params": [
        {
          "name": "entry",
          "type_long": "ghidra.program.model.correlate.HashEntry",
          "type_short": "HashEntry",
          "comment": "is the HashEntry producing the duplicates"
        },
        {
          "name": "store",
          "type_long": "ghidra.program.model.correlate.HashStore",
          "type_short": "HashStore",
          "comment": ""
        },
        {
          "name": "strategy",
          "type_long": "ghidra.program.model.correlate.DisambiguateStrategy",
          "type_short": "DisambiguateStrategy",
          "comment": "is the DisambiguateStrategy to use to produce secondary hashes"
        }
      ],
      "return": {
        "type_long": "java.util.TreeMap\u003cghidra.program.model.correlate.Hash,ghidra.program.model.correlate.HashedFunctionAddressCorrelation.DisambiguatorEntry\u003e",
        "type_short": "TreeMap",
        "comment": "the map of DisambiguatorEntry objects containing the histogram counts"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": ""
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": ""
        }
      ]
    },
    {
      "name": "disambiguateNgramsWithStrategy",
      "comment": "Try to disambiguate n-grams with a single hash using a specific secondary hash strategy",
      "javadoc": "Try to disambiguate n-grams with a single hash using a specific secondary hash strategy\n@param strategy is the DisambiguateStrategy to use for secondary hashes\n@param srcEntry is the collection of n-grams with the same hash on the source side\n@param destEntry is the collection of n-grams with the same hash on the destination side\n@return the number of disambiguated matches successfully discovered\n@throws CancelledException\n@throws MemoryAccessException",
      "static": false,
      "params": [
        {
          "name": "strategy",
          "type_long": "ghidra.program.model.correlate.DisambiguateStrategy",
          "type_short": "DisambiguateStrategy",
          "comment": "is the DisambiguateStrategy to use for secondary hashes"
        },
        {
          "name": "srcEntry",
          "type_long": "ghidra.program.model.correlate.HashEntry",
          "type_short": "HashEntry",
          "comment": "is the collection of n-grams with the same hash on the source side"
        },
        {
          "name": "destEntry",
          "type_long": "ghidra.program.model.correlate.HashEntry",
          "type_short": "HashEntry",
          "comment": "is the collection of n-grams with the same hash on the destination side"
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of disambiguated matches successfully discovered"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": ""
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": ""
        }
      ]
    },
    {
      "name": "disambiguateMatchingNgrams",
      "comment": "Attempt to disambiguate n-gram pairs with the same hash using various strategies",
      "javadoc": "Attempt to disambiguate n-gram pairs with the same hash using various strategies\n@param srcEntry is the collection of n-grams with the same hash on the source side\n@param destEntry is the collection of n-grams with the same hash on the destination side\n@return true if at least one pair was matched\n@throws CancelledException\n@throws MemoryAccessException",
      "static": false,
      "params": [
        {
          "name": "srcEntry",
          "type_long": "ghidra.program.model.correlate.HashEntry",
          "type_short": "HashEntry",
          "comment": "is the collection of n-grams with the same hash on the source side"
        },
        {
          "name": "destEntry",
          "type_long": "ghidra.program.model.correlate.HashEntry",
          "type_short": "HashEntry",
          "comment": "is the collection of n-grams with the same hash on the destination side"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if at least one pair was matched"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": ""
        },
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": ""
        }
      ]
    },
    {
      "name": "findMatches",
      "comment": "Check for matches through one set of n-grams.  If non-unique matches exist, attempt to disambiguate.\n This assumes that the srcStore and destStore HashStores have already been populated with the n-gram lists",
      "javadoc": "Check for matches through one set of n-grams.  If non-unique matches exist, attempt to disambiguate.\n This assumes that the srcStore and destStore HashStores have already been populated with the n-gram lists\n@throws MemoryAccessException\n@throws CancelledException",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": ""
        },
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": ""
        }
      ]
    },
    {
      "name": "runPasses",
      "comment": "Run multiple passes with one n-gram/hash generation configuration. A pass consists of generating the sorted\n lists of n-grams for both sides, running through the lists looking for matches, and, if matches aren\u0027t unique,\n running through the disambiguation strategies. Matches that aren\u0027t unique and couldn\u0027t be disambiguated in one\n pass may be matched in later passes.",
      "javadoc": "Run multiple passes with one n-gram/hash generation configuration. A pass consists of generating the sorted\n lists of n-grams for both sides, running through the lists looking for matches, and, if matches aren\u0027t unique,\n running through the disambiguation strategies. Matches that aren\u0027t unique and couldn\u0027t be disambiguated in one\n pass may be matched in later passes.\n@param minLength is the minimum length of an n-gram for these passes\n@param maxLength is the maximum length of an n-gram for these passes\n@param wholeBlock if true, allows blocks that are smaller than the minimum length to be considered as 1 n-gram.\n@param matchBlock if true, only generates n-grams for sequences in previously matched blocks\n@param maxPasses is the number of passes to run with this configuration\n@throws MemoryAccessException\n@throws CancelledException",
      "static": false,
      "params": [
        {
          "name": "minLength",
          "type_long": "int",
          "type_short": "int",
          "comment": "is the minimum length of an n-gram for these passes"
        },
        {
          "name": "maxLength",
          "type_long": "int",
          "type_short": "int",
          "comment": "is the maximum length of an n-gram for these passes"
        },
        {
          "name": "wholeBlock",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true, allows blocks that are smaller than the minimum length to be considered as 1 n-gram."
        },
        {
          "name": "matchBlock",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true, only generates n-grams for sequences in previously matched blocks"
        },
        {
          "name": "maxPasses",
          "type_long": "int",
          "type_short": "int",
          "comment": "is the number of passes to run with this configuration"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": ""
        },
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": ""
        }
      ]
    },
    {
      "name": "calculate",
      "comment": "High-level control of the matching passes. Tries different sequence generation configurations,\n terminating early if all instructions are matched.",
      "javadoc": "High-level control of the matching passes. Tries different sequence generation configurations,\n terminating early if all instructions are matched.\n@throws MemoryAccessException\n@throws CancelledException",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": ""
        },
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": ""
        }
      ]
    },
    {
      "name": "buildFinalMaps",
      "comment": "",
      "javadoc": "{@literal Given the src -\u003e dest map, build the dest -\u003e src map}",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getFirstToSecondIterator",
      "comment": "Gets an iterator of the matching addresses from the first function to the second.",
      "javadoc": "Gets an iterator of the matching addresses from the first function to the second.\n@return the iterator",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.util.Iterator\u003cjava.util.Map.Entry\u003cghidra.program.model.address.Address,ghidra.program.model.address.Address\u003e\u003e",
        "type_short": "Iterator",
        "comment": "the iterator"
      },
      "throws": []
    },
    {
      "name": "getAddressInSecond",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "addressInFirst",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getAddressInFirst",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "addressInSecond",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getFirstFunction",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Function",
        "type_short": "Function",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getSecondFunction",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Function",
        "type_short": "Function",
        "comment": ""
      },
      "throws": []
    }
  ]
}
