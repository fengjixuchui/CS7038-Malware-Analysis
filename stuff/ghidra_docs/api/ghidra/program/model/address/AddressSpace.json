{
  "name": "AddressSpace",
  "comment": "The AddressSpace class is used to represent a unique context for addresses.  Programs can\n have multiple address spaces and address 0 in one space is not the same as address 0 in\n another space.",
  "javadoc": "The AddressSpace class is used to represent a unique context for addresses.  Programs can\n have multiple address spaces and address 0 in one space is not the same as address 0 in\n another space.",
  "static": false,
  "implements": [
    "java.lang.Comparable"
  ],
  "fields": [
    {
      "name": "TYPE_CONSTANT",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "0"
    },
    {
      "name": "TYPE_RAM",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "1"
    },
    {
      "name": "TYPE_CODE",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "2"
    },
    {
      "name": "TYPE_UNIQUE",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "3"
    },
    {
      "name": "TYPE_REGISTER",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "4"
    },
    {
      "name": "TYPE_STACK",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "5"
    },
    {
      "name": "TYPE_JOIN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "6"
    },
    {
      "name": "TYPE_OTHER",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "7"
    },
    {
      "name": "TYPE_SYMBOL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "9"
    },
    {
      "name": "TYPE_EXTERNAL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "10"
    },
    {
      "name": "TYPE_VARIABLE",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "11"
    },
    {
      "name": "TYPE_DELETED",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "13"
    },
    {
      "name": "TYPE_UNKNOWN",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "14"
    },
    {
      "name": "TYPE_NONE",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "15"
    },
    {
      "name": "TYPE_IPTR_CONSTANT",
      "comment": "",
      "javadoc": "@see #TYPE_CONSTANT",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "0"
    },
    {
      "name": "TYPE_IPTR_INTERNAL",
      "comment": "",
      "javadoc": "@see #TYPE_UNIQUE",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "3"
    },
    {
      "name": "TYPE_IPTR_SPACEBASE",
      "comment": "",
      "javadoc": "@see #TYPE_STACK",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "5"
    },
    {
      "name": "ID_SIZE_MASK",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "112"
    },
    {
      "name": "ID_SIZE_SHIFT",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "4"
    },
    {
      "name": "ID_TYPE_MASK",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "15"
    },
    {
      "name": "ID_UNIQUE_SHIFT",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "7"
    },
    {
      "name": "OTHER_SPACE",
      "comment": "The OTHER_SPACE is used to store data from the original program file that doesn\u0027t\n get loaded into the final memory image and for user-defined spaces.",
      "javadoc": "The \u003ccode\u003eOTHER_SPACE\u003c/code\u003e is used to store data from the original program file that doesn\u0027t\n get loaded into the final memory image and for user-defined spaces.",
      "static": true,
      "type_long": "ghidra.program.model.address.AddressSpace",
      "type_short": "AddressSpace",
      "constant_value": null
    },
    {
      "name": "EXTERNAL_SPACE",
      "comment": "The EXTERNAL_SPACE is used to contain all external locations (i.e., data and functions) \n defined within a given library namespace.  All external locations within a program\n are given a unique offset within the EXTERNAL space.",
      "javadoc": "The \u003ccode\u003eEXTERNAL_SPACE\u003c/code\u003e is used to contain all external locations (i.e., data and functions) \n defined within a given library namespace.  All external locations within a program\n are given a unique offset within the EXTERNAL space.",
      "static": true,
      "type_long": "ghidra.program.model.address.AddressSpace",
      "type_short": "AddressSpace",
      "constant_value": null
    },
    {
      "name": "VARIABLE_SPACE",
      "comment": "The VARIABLE_SPACE is used to contain all variables and parameters \n defined within a given namespace (i.e., function).  All variables within a program\n are given a unique offset within the VARIABLE space.",
      "javadoc": "The \u003ccode\u003eVARIABLE_SPACE\u003c/code\u003e is used to contain all variables and parameters \n defined within a given namespace (i.e., function).  All variables within a program\n are given a unique offset within the VARIABLE space.",
      "static": true,
      "type_long": "ghidra.program.model.address.AddressSpace",
      "type_short": "AddressSpace",
      "constant_value": null
    },
    {
      "name": "HASH_SPACE",
      "comment": "The HASH_SPACE provides a 60-bit space for encoding of unique hashcodes.",
      "javadoc": "The \u003ccode\u003eHASH_SPACE\u003c/code\u003e provides a 60-bit space for encoding of unique hashcodes.",
      "static": true,
      "type_long": "ghidra.program.model.address.AddressSpace",
      "type_short": "AddressSpace",
      "constant_value": null
    },
    {
      "name": "DEFAULT_REGISTER_SPACE",
      "comment": "A language may only define a single REGISTER space.  If one is not defined, this \n DEFAULT_REGISTER_SPACE definition will be used.",
      "javadoc": "A language may only define a single REGISTER space.  If one is not defined, this \n DEFAULT_REGISTER_SPACE definition will be used.",
      "static": true,
      "type_long": "ghidra.program.model.address.AddressSpace",
      "type_short": "AddressSpace",
      "constant_value": null
    }
  ],
  "methods": [
    {
      "name": "getName",
      "comment": "Returns the name of this address space.",
      "javadoc": "Returns the name of this address space.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getSpaceID",
      "comment": "Get the ID for this space",
      "javadoc": "Get the ID for this space\n@return space ID",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "space ID"
      },
      "throws": []
    },
    {
      "name": "getSize",
      "comment": "Returns the number of bits that are used to form the address.  Thus\n the maximum offset for this address space will be 2^size-1.",
      "javadoc": "Returns the number of bits that are used to form the address.  Thus\n the maximum offset for this address space will be 2^size-1.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getAddressableUnitSize",
      "comment": "Returns the number of data bytes which correspond to each addressable \n location within this space (i.e., word-size in bytes).\n NOTE: When transforming a byte-offset to an addressable word\n offset the method #getAddressableWordOffset(long) should\n be used instead of simple division.  When transforming an addressable word-offset\n to a byte-offset simple multiplication may be used.  Neither of these\n transformations perform address space bounds checking.\n \n   byteOffset \u003d wordOffset * addressUnitSize\n   wordOffset \u003d getAddressableWordOffset(byteOffset)\n ",
      "javadoc": "Returns the number of data bytes which correspond to each addressable \n location within this space (i.e., word-size in bytes).\n NOTE: When transforming a byte-offset to an addressable word\n offset the method {@link #getAddressableWordOffset(long)} should\n be used instead of simple division.  When transforming an addressable word-offset\n to a byte-offset simple multiplication may be used.  Neither of these\n transformations perform address space bounds checking.\n \u003cpre\u003e\n   byteOffset \u003d wordOffset * addressUnitSize\n   wordOffset \u003d getAddressableWordOffset(byteOffset)\n \u003c/pre\u003e",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getAddressableWordOffset",
      "comment": "Get the addressable memory word offset which corresponds to the specified \n memory byte offset.  This method handles some of the issues of unsigned \n math when stuck using Java\u0027s signed long primitives. No space bounds\n checking is performed.",
      "javadoc": "Get the addressable memory word offset which corresponds to the specified \n memory byte offset.  This method handles some of the issues of unsigned \n math when stuck using Java\u0027s signed long primitives. No space bounds\n checking is performed.\n@param byteOffset memory byte offset\n@return addressable memory word offset",
      "static": false,
      "params": [
        {
          "name": "byteOffset",
          "type_long": "long",
          "type_short": "long",
          "comment": "memory byte offset"
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "addressable memory word offset"
      },
      "throws": []
    },
    {
      "name": "getPointerSize",
      "comment": "Returns the absolute size of a pointer into this space (in bytes).",
      "javadoc": "Returns the absolute size of a pointer into this space (in bytes).\n@see Program#getDefaultPointerSize() for a user adjustable pointer size which is derived from the\n CompilerSpec store pointer size.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getType",
      "comment": "Returns the type of this address space",
      "javadoc": "Returns the type of this address space",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getUnique",
      "comment": "Returns the unique index for this address space",
      "javadoc": "Returns the unique index for this address space",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getAddress",
      "comment": "Parses the String into an address.",
      "javadoc": "Parses the String into an address.\n@param addrString the string to parse as an address.\n@return an address if the string parsed successfully or null if the\n AddressSpace specified in the addrString is not this space.\n@throws AddressFormatException if the string cannot be parsed or the\n parsed offset is larger than the size for this space.",
      "static": false,
      "params": [
        {
          "name": "addrString",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the string to parse as an address."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "an address if the string parsed successfully or null if the\n AddressSpace specified in the addrString is not this space."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.address.AddressFormatException",
          "type_short": "AddressFormatException",
          "comment": "if the string cannot be parsed or the\n parsed offset is larger than the size for this space."
        }
      ]
    },
    {
      "name": "getAddress",
      "comment": "Parses the String into an address.",
      "javadoc": "Parses the String into an address.\n@param addrString the string to parse as an address.\n@param caseSensitive specifies if addressSpace names must match case.\n@return an address if the string parsed successfully or null if the\n AddressSpace specified in the addrString is not this space.\n@throws AddressFormatException if the string cannot be parsed or the\n parsed offset is larger than the size for this space.",
      "static": false,
      "params": [
        {
          "name": "addrString",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the string to parse as an address."
        },
        {
          "name": "caseSensitive",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "specifies if addressSpace names must match case."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "an address if the string parsed successfully or null if the\n AddressSpace specified in the addrString is not this space."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.address.AddressFormatException",
          "type_short": "AddressFormatException",
          "comment": "if the string cannot be parsed or the\n parsed offset is larger than the size for this space."
        }
      ]
    },
    {
      "name": "getAddress",
      "comment": "Returns a new address in this space with the given byte offset.\n NOTE: This method is the same as invoking getAddress(long byteOffset, false).",
      "javadoc": "Returns a new address in this space with the given byte offset.\n NOTE: This method is the same as invoking getAddress(long byteOffset, false).\n@param byteOffset the byte offset for the new address.\n@return address with given byte offset\n@throws AddressOutOfBoundsException if the offset is less than 0 or greater\n than the max offset allowed for this space.",
      "static": false,
      "params": [
        {
          "name": "byteOffset",
          "type_long": "long",
          "type_short": "long",
          "comment": "the byte offset for the new address."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "address with given byte offset"
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.address.AddressOutOfBoundsException",
          "type_short": "AddressOutOfBoundsException",
          "comment": "if the offset is less than 0 or greater\n than the max offset allowed for this space."
        }
      ]
    },
    {
      "name": "getAddress",
      "comment": "Returns a new address in this space with the given offset.  \n NOTE: for those spaces with an addressable unit size other than 1, the address\n returned may not correspond to an addressable unit/word boundary if a byte-offset \n is specified.",
      "javadoc": "Returns a new address in this space with the given offset.  \n NOTE: for those spaces with an addressable unit size other than 1, the address\n returned may not correspond to an addressable unit/word boundary if a byte-offset \n is specified.\n@param offset the offset for the new address.\n@param isAddressableWordOffset if true the specified offset is an addressable unit/word offset,\n otherwise offset is a byte offset.  See {@link #getAddressableUnitSize()}\n to understand the distinction (i.e., wordOffset \u003d byteOffset * addressableUnitSize).\n@return address with given offset\n@throws AddressOutOfBoundsException if the offset is less than 0 or greater\n than the max offset allowed for this space.",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "long",
          "type_short": "long",
          "comment": "the offset for the new address."
        },
        {
          "name": "isAddressableWordOffset",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true the specified offset is an addressable unit/word offset,\n otherwise offset is a byte offset.  See #getAddressableUnitSize()\n to understand the distinction (i.e., wordOffset \u003d byteOffset * addressableUnitSize)."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "address with given offset"
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.address.AddressOutOfBoundsException",
          "type_short": "AddressOutOfBoundsException",
          "comment": "if the offset is less than 0 or greater\n than the max offset allowed for this space."
        }
      ]
    },
    {
      "name": "getTruncatedAddress",
      "comment": "Returns a new address in this space with the given offset.  The specified \n offset will be truncated within the space and will not throw an exception.\n NOTE: for those spaces with an addressable unit size other than 1, the address\n returned may not correspond to a word boundary (addressable unit) if a byte-offset \n is specified.",
      "javadoc": "Returns a new address in this space with the given offset.  The specified \n offset will be truncated within the space and will not throw an exception.\n NOTE: for those spaces with an addressable unit size other than 1, the address\n returned may not correspond to a word boundary (addressable unit) if a byte-offset \n is specified.\n@param offset the offset for the new address.\n@param isAddressableWordOffset if true the specified offset is an addressable unit/word offset,\n otherwise offset is a byte offset.  See {@link #getAddressableUnitSize()}\n to understand the distinction (i.e., wordOffset \u003d byteOffset * addressableUnitSize).\n@return address with given byte offset truncated to the physical space size",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "long",
          "type_short": "long",
          "comment": "the offset for the new address."
        },
        {
          "name": "isAddressableWordOffset",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true the specified offset is an addressable unit/word offset,\n otherwise offset is a byte offset.  See #getAddressableUnitSize()\n to understand the distinction (i.e., wordOffset \u003d byteOffset * addressableUnitSize)."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "address with given byte offset truncated to the physical space size"
      },
      "throws": []
    },
    {
      "name": "getAddressInThisSpaceOnly",
      "comment": "Get a byte address from this address space.  Don\u0027t allow overlay spaces\n to remap the address into a base space when the address is not\n contained in the bounds of the overlay region.",
      "javadoc": "Get a byte address from this address space.  Don\u0027t allow overlay spaces\n to remap the address into a base space when the address is not\n contained in the bounds of the overlay region.\n@param byteOffset the byte offset for the new address.\n@return an address if the offset is valid.\n@throws AddressOutOfBoundsException if the offset is less than 0 or greater\n than the max offset allowed for this space.",
      "static": false,
      "params": [
        {
          "name": "byteOffset",
          "type_long": "long",
          "type_short": "long",
          "comment": "the byte offset for the new address."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "an address if the offset is valid."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.address.AddressOutOfBoundsException",
          "type_short": "AddressOutOfBoundsException",
          "comment": "if the offset is less than 0 or greater\n than the max offset allowed for this space."
        }
      ]
    },
    {
      "name": "truncateOffset",
      "comment": "Truncate the specified byte offset within this space to produce a valid offset.",
      "javadoc": "Truncate the specified byte offset within this space to produce a valid offset.\n@param byteOffset any byte offset\n@return truncated byte offset",
      "static": false,
      "params": [
        {
          "name": "byteOffset",
          "type_long": "long",
          "type_short": "long",
          "comment": "any byte offset"
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "truncated byte offset"
      },
      "throws": []
    },
    {
      "name": "truncateAddressableWordOffset",
      "comment": "Truncate the specified addressable unit/word offset within this space to produce a \n valid offset.",
      "javadoc": "Truncate the specified addressable unit/word offset within this space to produce a \n valid offset.\n@param wordOffset any addressable unit/word offset\n@return truncated word offset",
      "static": false,
      "params": [
        {
          "name": "wordOffset",
          "type_long": "long",
          "type_short": "long",
          "comment": "any addressable unit/word offset"
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "truncated word offset"
      },
      "throws": []
    },
    {
      "name": "getOverlayAddress",
      "comment": "Get an address that is relative to this address space.\n If this is an overlay space and the address falls within\n this space, return an address based in this space.",
      "javadoc": "Get an address that is relative to this address space.\n If this is an overlay space and the address falls within\n this space, return an address based in this space.\n@param addr address possibly falling within this overlay space.\n@return an address relative to this overlay",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "address possibly falling within this overlay space."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "an address relative to this overlay"
      },
      "throws": []
    },
    {
      "name": "subtract",
      "comment": "Calculates the displacement between addr1 and addr2 (addr1 - addr2)",
      "javadoc": "Calculates the displacement between addr1 and addr2 (addr1 - addr2)\n@param addr1 the address to subtract from.\n@param addr2 the address to subtract.\n@return the difference. (\u003ccode\u003eaddr1.offset - addr2.offset\u003c/code\u003e).\n@throws IllegalArgumentException if the two addresses are not in the\n same address space.",
      "static": false,
      "params": [
        {
          "name": "addr1",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to subtract from."
        },
        {
          "name": "addr2",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to subtract."
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the difference. (addr1.offset - addr2.offset)."
      },
      "throws": []
    },
    {
      "name": "subtractWrap",
      "comment": "Creates a new address by subtracting displacement from addr\u0027s offset.",
      "javadoc": "Creates a new address by subtracting displacement from addr\u0027s offset.\n@param addr the original address. The new address will wrap in a manner\n that depends on the address space. For a generic address space this will\n wrap at the extents of the address space. For a segmented address space\n it will wrap at the extents of the segment.\n@param displacement the displacement to subtract.\n@return a new address created by subtracting the displacement from addr.offset.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the original address. The new address will wrap in a manner\n that depends on the address space. For a generic address space this will\n wrap at the extents of the address space. For a segmented address space\n it will wrap at the extents of the segment."
        },
        {
          "name": "displacement",
          "type_long": "long",
          "type_short": "long",
          "comment": "the displacement to subtract."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "a new address created by subtracting the displacement from addr.offset."
      },
      "throws": []
    },
    {
      "name": "subtractWrapSpace",
      "comment": "Creates a new address by subtracting the displacement from the given \n address. If the offset is greater than the max offset of the address space, the high\n order bits are masked off, making the address wrap.  For non-segmented addresses this\n will be the same as subtractWrap().  For segmented addresses, the address will wrap when\n the 20 bit (oxfffff) offset is exceeded, as opposed to when the segment offset is exceeded.",
      "javadoc": "Creates a new address by subtracting the displacement from the given \n address. If the offset is greater than the max offset of the address space, the high\n order bits are masked off, making the address wrap.  For non-segmented addresses this\n will be the same as subtractWrap().  For segmented addresses, the address will wrap when\n the 20 bit (oxfffff) offset is exceeded, as opposed to when the segment offset is exceeded.\n@param addr the address to subtract the displacement from.\n@param displacement the displacement to subtract.\n@return The new Address formed by subtracting the displacement from the specified address.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to subtract the displacement from."
        },
        {
          "name": "displacement",
          "type_long": "long",
          "type_short": "long",
          "comment": "the displacement to subtract."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "The new Address formed by subtracting the displacement from the specified address."
      },
      "throws": []
    },
    {
      "name": "subtractNoWrap",
      "comment": "Creates a new address by subtracting displacement from addr\u0027s offset.\n The new offset will NOT wrap!",
      "javadoc": "Creates a new address by subtracting displacement from addr\u0027s offset.\n The new offset will NOT wrap!\n@param addr the original address\n@param displacement the displacement to subtract.\n@return The new address created by subtracting displacement from addr.offset.\n@throws AddressOverflowException if the subtraction would cause a wrap,",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the original address"
        },
        {
          "name": "displacement",
          "type_long": "long",
          "type_short": "long",
          "comment": "the displacement to subtract."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "The new address created by subtracting displacement from addr.offset."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.address.AddressOverflowException",
          "type_short": "AddressOverflowException",
          "comment": "if the subtraction would cause a wrap,"
        }
      ]
    },
    {
      "name": "subtract",
      "comment": "Creates a new address (possibly in a new space) by subtracting the given \n displacement from the given address.",
      "javadoc": "Creates a new address (possibly in a new space) by subtracting the given \n displacement from the given address.\n@param addr original address being subtracted from\n@param displacement amount to subtract\n@return the new address\n@throws AddressOutOfBoundsException if the result does not correspond to any address.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "original address being subtracted from"
        },
        {
          "name": "displacement",
          "type_long": "long",
          "type_short": "long",
          "comment": "amount to subtract"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "the new address"
      },
      "throws": []
    },
    {
      "name": "addWrap",
      "comment": "Creates a new address by adding displacement to the given address. The\n resulting address may wrap. The new address will wrap in a manner that\n depends on the address space. For a generic address space this will wrap\n at the extents of the address space. For a segmented address space it\n will wrap at the extents of the segment.",
      "javadoc": "Creates a new address by adding displacement to the given address. The\n resulting address may wrap. The new address will wrap in a manner that\n depends on the address space. For a generic address space this will wrap\n at the extents of the address space. For a segmented address space it\n will wrap at the extents of the segment.\n@param addr the original address.\n@param displacement the displacement to add.\n@return the new address created by adding displacement to addr.offset.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the original address."
        },
        {
          "name": "displacement",
          "type_long": "long",
          "type_short": "long",
          "comment": "the displacement to add."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "the new address created by adding displacement to addr.offset."
      },
      "throws": []
    },
    {
      "name": "addWrapSpace",
      "comment": "Creates a new address by adding the displacement to the given \n address. If the offset is greater than the max offset of the address space, the high\n order bits are masked off, making the address wrap.  For non-segmented addresses this\n will be the same as addWrap().  For segmented addresses, the address will wrap when\n the 20 bit (oxfffff) offset is exceeded, as opposed to when the segment offset is exceeded.",
      "javadoc": "Creates a new address by adding the displacement to the given \n address. If the offset is greater than the max offset of the address space, the high\n order bits are masked off, making the address wrap.  For non-segmented addresses this\n will be the same as addWrap().  For segmented addresses, the address will wrap when\n the 20 bit (oxfffff) offset is exceeded, as opposed to when the segment offset is exceeded.\n@param addr the address to add the displacement to.\n@param displacement the displacement to add.\n@return The new Address formed by adding the displacement to the specified addresst.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to add the displacement to."
        },
        {
          "name": "displacement",
          "type_long": "long",
          "type_short": "long",
          "comment": "the displacement to add."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "The new Address formed by adding the displacement to the specified addresst."
      },
      "throws": []
    },
    {
      "name": "addNoWrap",
      "comment": "Creates a new address by adding displacement to the given address. The\n new address will NOT wrap!",
      "javadoc": "Creates a new address by adding displacement to the given address. The\n new address will NOT wrap!\n@param addr the original address.\n@param displacement the displacement to add.\n@return The new address created by adding displacement to addr.offset.\n@throws AddressOverflowException if the addition would cause a wrap,",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the original address."
        },
        {
          "name": "displacement",
          "type_long": "long",
          "type_short": "long",
          "comment": "the displacement to add."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "The new address created by adding displacement to addr.offset."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.address.AddressOverflowException",
          "type_short": "AddressOverflowException",
          "comment": "if the addition would cause a wrap,"
        }
      ]
    },
    {
      "name": "addNoWrap",
      "comment": "Creates a new address by adding displacement to the given address. The\n new address will NOT wrap!",
      "javadoc": "Creates a new address by adding displacement to the given address. The\n new address will NOT wrap!\n@param addr the original address.\n@param displacement the displacement to add.\n@return The new address created by adding displacement to addr.offset.\n@throws AddressOverflowException if the addition would cause a wrap,",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.GenericAddress",
          "type_short": "GenericAddress",
          "comment": "the original address."
        },
        {
          "name": "displacement",
          "type_long": "java.math.BigInteger",
          "type_short": "BigInteger",
          "comment": "the displacement to add."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "The new address created by adding displacement to addr.offset."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.address.AddressOverflowException",
          "type_short": "AddressOverflowException",
          "comment": "if the addition would cause a wrap,"
        }
      ]
    },
    {
      "name": "add",
      "comment": "Creates a new address (possibly in a new space) by adding the given \n displacement from the given address.",
      "javadoc": "Creates a new address (possibly in a new space) by adding the given \n displacement from the given address.\n@param addr original address being subtracted from\n@param displacement amount to subtract\n@return the new address\n@throws AddressOutOfBoundsException if the result does not correspond to any address.",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "original address being subtracted from"
        },
        {
          "name": "displacement",
          "type_long": "long",
          "type_short": "long",
          "comment": "amount to subtract"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "the new address"
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.address.AddressOutOfBoundsException",
          "type_short": "AddressOutOfBoundsException",
          "comment": "if the result does not correspond to any address."
        }
      ]
    },
    {
      "name": "isValidRange",
      "comment": "Check the specified address range for validity within this space.\n Segmented spaces will restrict a range to a single segment.",
      "javadoc": "Check the specified address range for validity within this space.\n Segmented spaces will restrict a range to a single segment.\n@param byteOffset\n@param length\n@return true if range is valid for this space",
      "static": false,
      "params": [
        {
          "name": "byteOffset",
          "type_long": "long",
          "type_short": "long",
          "comment": ""
        },
        {
          "name": "length",
          "type_long": "long",
          "type_short": "long",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if range is valid for this space"
      },
      "throws": []
    },
    {
      "name": "isSuccessor",
      "comment": "Tests whether addr2 immediately follows addr1.",
      "javadoc": "Tests whether addr2 immediately follows addr1.\n@param addr1 the first address.\n@param addr2 the second address.",
      "static": false,
      "params": [
        {
          "name": "addr1",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the first address."
        },
        {
          "name": "addr2",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the second address."
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getMaxAddress",
      "comment": "Get the max address allowed for this AddressSpace.",
      "javadoc": "Get the max address allowed for this AddressSpace.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getMinAddress",
      "comment": "Get the min address allowed for this AddressSpace",
      "javadoc": "Get the min address allowed for this AddressSpace",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getPhysicalSpace",
      "comment": "Returns the physical space associated with an address space.  There\n is always exactly one physical space associated with an address\n space (it may be its own physical space).",
      "javadoc": "Returns the physical space associated with an address space.  There\n is always exactly one physical space associated with an address\n space (it may be its own physical space).\n@return the associated physical space.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.AddressSpace",
        "type_short": "AddressSpace",
        "comment": "the associated physical space."
      },
      "throws": []
    },
    {
      "name": "makeValidOffset",
      "comment": "Tests if the offset if valid. If the space is signed, then it sign extends\n the offset.",
      "javadoc": "Tests if the offset if valid. If the space is signed, then it sign extends\n the offset.\n@param offset the offset to test and/or sign extend\n@return the valid positive offset or appropriate sign extended offset.\n@throws AddressOutOfBoundsException if offset is invalid",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "long",
          "type_short": "long",
          "comment": "the offset to test and/or sign extend"
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the valid positive offset or appropriate sign extended offset."
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.address.AddressOutOfBoundsException",
          "type_short": "AddressOutOfBoundsException",
          "comment": "if offset is invalid"
        }
      ]
    },
    {
      "name": "isMemorySpace",
      "comment": "Returns true if this space represents a memory address.  NOTE: It is important to \n make the distinction between Loaded and Non-Loaded memory addresses.  Program importers\n may create memory blocks associated with Non-Loaded file content which are not associated\n with processor defined memory regions.  While Loaded file content is placed into\n memory blocks which are associated with specific memory address spaces defined\n by the processor language specification.",
      "javadoc": "Returns true if this space represents a memory address.  NOTE: It is important to \n make the distinction between Loaded and Non-Loaded memory addresses.  Program importers\n may create memory blocks associated with Non-Loaded file content which are not associated\n with processor defined memory regions.  While Loaded file content is placed into\n memory blocks which are associated with specific memory address spaces defined\n by the processor language specification.\n@see #isLoadedMemorySpace()\n@see #isNonLoadedMemorySpace()",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isLoadedMemorySpace",
      "comment": "Returns true if this space represents represents a Loaded Memory\n region (e.g., processor RAM).",
      "javadoc": "Returns true if this space represents represents a Loaded Memory\n region (e.g., processor RAM).",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isNonLoadedMemorySpace",
      "comment": "Returns true if this space represents represents a Non-Loaded storage region\n for retaining non-loaded file data (e.g., OTHER)",
      "javadoc": "Returns true if this space represents represents a Non-Loaded storage region\n for retaining non-loaded file data (e.g., OTHER)",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isRegisterSpace",
      "comment": "Returns true if this space represents a register location",
      "javadoc": "Returns true if this space represents a register location",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isVariableSpace",
      "comment": "Returns true if this space represents a variable location",
      "javadoc": "Returns true if this space represents a variable location",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isStackSpace",
      "comment": "Returns true if this space represents a stack location",
      "javadoc": "Returns true if this space represents a stack location",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isHashSpace",
      "comment": "Returns true if this space represents a location in the HASH space.",
      "javadoc": "Returns true if this space represents a location in the HASH space.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isExternalSpace",
      "comment": "Returns true if this space in the EXTERNAL_SPACE",
      "javadoc": "Returns true if this space in the EXTERNAL_SPACE",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isUniqueSpace",
      "comment": "Returns true if this space in the unique space",
      "javadoc": "Returns true if this space in the unique space",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isConstantSpace",
      "comment": "Returns true if this space in the constant space",
      "javadoc": "Returns true if this space in the constant space",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "hasMappedRegisters",
      "comment": "Returns true if this space has registers that are mapped into it.\n This means that registers could actually have pointers to them.",
      "javadoc": "Returns true if this space has registers that are mapped into it.\n This means that registers could actually have pointers to them.\n@return true if this space has any registers mapped in it.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if this space has any registers mapped in it."
      },
      "throws": []
    },
    {
      "name": "showSpaceName",
      "comment": "Returns true if the address should display its addressSpace name.",
      "javadoc": "Returns true if the address should display its addressSpace name.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "isOverlaySpace",
      "comment": "Returns true if this addressSpace is an OverlayAddressSpace",
      "javadoc": "Returns true if this addressSpace is an OverlayAddressSpace",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "hasSignedOffset",
      "comment": "Returns true if space uses signed offset",
      "javadoc": "Returns true if space uses signed offset",
      "static": false,
      "params": [],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": ""
      },
      "throws": []
    }
  ]
}
