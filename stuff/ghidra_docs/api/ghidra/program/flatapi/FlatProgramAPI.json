{
  "name": "FlatProgramAPI",
  "comment": "This class is a flattened version of the Program API.\n \n NOTE:\n \n \tNO METHODS *SHOULD* EVER BE REMOVED FROM THIS CLASS.\n \tNO METHOD SIGNATURES *SHOULD* EVER BE CHANGED IN THIS CLASS.\n \n \n This class is used by GhidraScript.\n \n Changing this class will break user scripts.\n ",
  "javadoc": "This class is a flattened version of the Program API.\n \u003cp\u003e\n NOTE:\n \u003col\u003e\n \t\u003cli\u003eNO METHODS *SHOULD* EVER BE REMOVED FROM THIS CLASS.\n \t\u003cli\u003eNO METHOD SIGNATURES *SHOULD* EVER BE CHANGED IN THIS CLASS.\n \u003c/ol\u003e\n \u003cp\u003e\n This class is used by GhidraScript.\n \u003cp\u003e\n Changing this class will break user scripts.\n \u003cp\u003e",
  "static": false,
  "implements": [],
  "extends": "java.lang.Object",
  "fields": [
    {
      "name": "MAX_REFERENCES_TO",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "4096"
    },
    {
      "name": "currentProgram",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.program.model.listing.Program",
      "type_short": "Program",
      "constant_value": null
    },
    {
      "name": "monitor",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "ghidra.util.task.TaskMonitor",
      "type_short": "TaskMonitor",
      "constant_value": null
    },
    {
      "name": "transactionID",
      "comment": "",
      "javadoc": "",
      "static": false,
      "type_long": "int",
      "type_short": "int",
      "constant_value": null
    }
  ],
  "methods": [
    {
      "name": "\u003cinit\u003e",
      "comment": "Constructs a new flat program API.\n It will not be usable until the \u0027set\u0027 method has been called.",
      "javadoc": "Constructs a new flat program API.\n It will not be usable until the \u0027set\u0027 method has been called.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "\u003cinit\u003e",
      "comment": "Constructs a new flat program API.",
      "javadoc": "Constructs a new flat program API.\n@param program the program",
      "static": false,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": "the program"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "\u003cinit\u003e",
      "comment": "Constructs a new flat program API.",
      "javadoc": "Constructs a new flat program API.\n@param program the program\n@param monitor the task monitor",
      "static": false,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": "the program"
        },
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": "the task monitor"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "set",
      "comment": "Sets the current state.",
      "javadoc": "Sets the current state.\n@param program the program\n@param monitor the task monitor",
      "static": false,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": "the program"
        },
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": "the task monitor"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getCurrentProgram",
      "comment": "Gets the current program.",
      "javadoc": "Gets the current program.\n@return the program",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Program",
        "type_short": "Program",
        "comment": "the program"
      },
      "throws": []
    },
    {
      "name": "getMonitor",
      "comment": "Gets the current task monitor.",
      "javadoc": "Gets the current task monitor.\n@return the task monitor",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.util.task.TaskMonitor",
        "type_short": "TaskMonitor",
        "comment": "the task monitor"
      },
      "throws": []
    },
    {
      "name": "start",
      "comment": "Starts a transaction on the current program.",
      "javadoc": "Starts a transaction on the current program.",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "end",
      "comment": "Ends the transactions on the current program.",
      "javadoc": "Ends the transactions on the current program.\n@param commit true if changes should be committed",
      "static": false,
      "params": [
        {
          "name": "commit",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if changes should be committed"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getProgramFile",
      "comment": "Returns the path to the program\u0027s executable file.\n For example, c:\\temp\\test.exe.",
      "javadoc": "Returns the path to the program\u0027s executable file.\n For example, \u003ccode\u003ec:\\temp\\test.exe\u003c/code\u003e.\n@return path to program\u0027s executable file",
      "static": false,
      "params": [],
      "return": {
        "type_long": "java.io.File",
        "type_short": "File",
        "comment": "path to program\u0027s executable file"
      },
      "throws": []
    },
    {
      "name": "disassemble",
      "comment": "Start disassembling at the specified address.\n The disassembler will follow code flows.",
      "javadoc": "Start disassembling at the specified address.\n The disassembler will follow code flows.\n@param address the address to begin disassembling\n@return true if the program was successfully disassembled",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to begin disassembling"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the program was successfully disassembled"
      },
      "throws": []
    },
    {
      "name": "analyze",
      "comment": "Starts auto-analysis on the specified program and performs complete analysis\n of the entire program.  This is usually only necessary if full analysis was never\n performed. This method will block until analysis completes.",
      "javadoc": "Starts auto-analysis on the specified program and performs complete analysis\n of the entire program.  This is usually only necessary if full analysis was never\n performed. This method will block until analysis completes.\n@param program the program to analyze\n@deprecated the method {@link #analyzeAll} or {@link #analyzeChanges} should be invoked.\n These separate methods were created to clarify their true behavior since many times it is\n only necessary to analyze changes and not the entire program which can take much\n longer and affect more of the program than is necessary.",
      "static": false,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": "the program to analyze"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "analyzeAll",
      "comment": "Starts auto-analysis on the specified program and performs complete analysis\n of the entire program.  This is usually only necessary if full analysis was never\n performed. This method will block until analysis completes.",
      "javadoc": "Starts auto-analysis on the specified program and performs complete analysis\n of the entire program.  This is usually only necessary if full analysis was never\n performed. This method will block until analysis completes.\n@param program the program to analyze",
      "static": false,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": "the program to analyze"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "analyzeChanges",
      "comment": "Starts auto-analysis if not started and waits for pending analysis to complete.\n Only pending analysis on program changes is performed, including changes resulting\n from any analysis activity.  This method will block until analysis completes.\n NOTE: The auto-analysis manager will only detect program changes once it has been\n instantiated for a program (i.e, AutoAnalysisManager.getAnalysisManager(program) ).\n This is automatically done for the initial currentProgram, however, if a script is\n opening/instantiating its own programs it may be necessary to do this prior to\n making changes to the program.",
      "javadoc": "Starts auto-analysis if not started and waits for pending analysis to complete.\n Only pending analysis on program changes is performed, including changes resulting\n from any analysis activity.  This method will block until analysis completes.\n NOTE: The auto-analysis manager will only detect program changes once it has been\n instantiated for a program (i.e, AutoAnalysisManager.getAnalysisManager(program) ).\n This is automatically done for the initial currentProgram, however, if a script is\n opening/instantiating its own programs it may be necessary to do this prior to\n making changes to the program.\n@param program the program to analyze",
      "static": false,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": "the program to analyze"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "clearListing",
      "comment": "Clears the code unit (instruction or data) defined at the address.",
      "javadoc": "Clears the code unit (instruction or data) defined at the address.\n@param address the address to clear the code unit\n@throws CancelledException if cancelled",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to clear the code unit"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": "if cancelled"
        }
      ]
    },
    {
      "name": "clearListing",
      "comment": "Clears the code units (instructions or data) in the specified range.",
      "javadoc": "Clears the code units (instructions or data) in the specified range.\n@param start the start address\n@param end the end address\n@throws CancelledException if cancelled",
      "static": false,
      "params": [
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the start address"
        },
        {
          "name": "end",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the end address"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": "if cancelled"
        }
      ]
    },
    {
      "name": "clearListing",
      "comment": "Clears the code units (instructions or data) in the specified set",
      "javadoc": "Clears the code units (instructions or data) in the specified set\n@param set the set to clear\n@throws CancelledException if cancelled",
      "static": false,
      "params": [
        {
          "name": "set",
          "type_long": "ghidra.program.model.address.AddressSetView",
          "type_short": "AddressSetView",
          "comment": "the set to clear"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": "if cancelled"
        }
      ]
    },
    {
      "name": "clearListing",
      "comment": "Clears the listing in the specified address set.",
      "javadoc": "Clears the listing in the specified address set.\n@param set the address set where to clear\n@param code true if code units should be cleared (instructions and defined data)\n@param symbols true if symbols should be cleared\n@param comments true if comments should be cleared\n@param properties true if properties should be cleared\n@param functions true if functions should be cleared\n@param registers true if registers should be cleared\n@param equates true if equates should be cleared\n@param userReferences true if user references should be cleared\n@param analysisReferences true if analysis references should be cleared\n@param importReferences true if import references should be cleared\n@param defaultReferences true if default references should be cleared\n@param bookmarks true if bookmarks should be cleared\n@return true if the address set was successfully cleared",
      "static": false,
      "params": [
        {
          "name": "set",
          "type_long": "ghidra.program.model.address.AddressSetView",
          "type_short": "AddressSetView",
          "comment": "the address set where to clear"
        },
        {
          "name": "code",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if code units should be cleared (instructions and defined data)"
        },
        {
          "name": "symbols",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if symbols should be cleared"
        },
        {
          "name": "comments",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if comments should be cleared"
        },
        {
          "name": "properties",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if properties should be cleared"
        },
        {
          "name": "functions",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if functions should be cleared"
        },
        {
          "name": "registers",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if registers should be cleared"
        },
        {
          "name": "equates",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if equates should be cleared"
        },
        {
          "name": "userReferences",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if user references should be cleared"
        },
        {
          "name": "analysisReferences",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if analysis references should be cleared"
        },
        {
          "name": "importReferences",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if import references should be cleared"
        },
        {
          "name": "defaultReferences",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if default references should be cleared"
        },
        {
          "name": "bookmarks",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if bookmarks should be cleared"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the address set was successfully cleared"
      },
      "throws": []
    },
    {
      "name": "createMemoryBlock",
      "comment": "Create a new memory block.\n If the input stream is null, then an uninitialized block will be created.",
      "javadoc": "Create a new memory block.\n If the input stream is null, then an uninitialized block will be created.\n@param name the name of the block\n@param start start address of the block\n@param input source of the data used to fill the block.\n@param length the size of the block\n@param overlay true will create an overlay, false will not\n@return the newly created memory block\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the block"
        },
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "start address of the block"
        },
        {
          "name": "input",
          "type_long": "java.io.InputStream",
          "type_short": "InputStream",
          "comment": "source of the data used to fill the block."
        },
        {
          "name": "length",
          "type_long": "long",
          "type_short": "long",
          "comment": "the size of the block"
        },
        {
          "name": "overlay",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true will create an overlay, false will not"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "the newly created memory block"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createMemoryBlock",
      "comment": "Create a new memory block.",
      "javadoc": "Create a new memory block.\n@param name the name of the block\n@param start start address of the block\n@param bytes the bytes of the memory block\n@param overlay true will create an overlay, false will not\n@return the newly created memory block\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the block"
        },
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "start address of the block"
        },
        {
          "name": "bytes",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "the bytes of the memory block"
        },
        {
          "name": "overlay",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true will create an overlay, false will not"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "the newly created memory block"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "getMemoryBlock",
      "comment": "Returns the first memory block with the specified name.\n NOTE: if more than block exists with the same name, the first\n block with that name will be returned.",
      "javadoc": "Returns the first memory block with the specified name.\n NOTE: if more than block exists with the same name, the first\n block with that name will be returned.\n@param name the name of the requested block\n@return the the memory block with the specified name",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the requested block"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "the the memory block with the specified name"
      },
      "throws": []
    },
    {
      "name": "getMemoryBlock",
      "comment": "Returns the memory block containing the specified address,\n or null if no memory block contains the address.",
      "javadoc": "Returns the memory block containing the specified address,\n or null if no memory block contains the address.\n@param address the address\n@return the memory block containing the specified address",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock",
        "type_short": "MemoryBlock",
        "comment": "the memory block containing the specified address"
      },
      "throws": []
    },
    {
      "name": "getMemoryBlocks",
      "comment": "Returns an array containing all the memory blocks\n in the current program.",
      "javadoc": "Returns an array containing all the memory blocks\n in the current program.\n@return an array containing all the memory blocks",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.mem.MemoryBlock[]",
        "type_short": "ghidra.program.model.mem.MemoryBlock[]",
        "comment": "an array containing all the memory blocks"
      },
      "throws": []
    },
    {
      "name": "removeMemoryBlock",
      "comment": "Remove the memory block.\n NOTE: ALL ANNOTATION (disassembly, comments, etc) defined in this\n memory block will also be removed!",
      "javadoc": "Remove the memory block.\n NOTE: ALL ANNOTATION (disassembly, comments, etc) defined in this\n memory block will also be removed!\n@param block the block to be removed\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "block",
          "type_long": "ghidra.program.model.mem.MemoryBlock",
          "type_short": "MemoryBlock",
          "comment": "the block to be removed"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createLabel",
      "comment": "Creates a label at the specified address in the global namespace.\n If makePrimary\u003d\u003dtrue, then the new label is made primary.",
      "javadoc": "Creates a label at the specified address in the global namespace.\n If makePrimary\u003d\u003dtrue, then the new label is made primary.\n@param address the address to create the symbol\n@param name the name of the symbol\n@param makePrimary true if the symbol should be made primary\n@return the newly created code or function symbol\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to create the symbol"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbol"
        },
        {
          "name": "makePrimary",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if the symbol should be made primary"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the newly created code or function symbol"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createSymbol",
      "comment": "",
      "javadoc": "@deprecated use {@link #createLabel(Address, String, boolean)} instead.\n Deprecated in Ghidra 7.4",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": ""
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "makePrimary",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": ""
        }
      ]
    },
    {
      "name": "createLabel",
      "comment": "Creates a label at the specified address in the global namespace.\n If makePrimary\u003d\u003dtrue, then the new label is made primary.\n If makeUnique\u003d\u003dtrue, then if the name is a duplicate, the address\n will be concatenated to name to make it unique.",
      "javadoc": "Creates a label at the specified address in the global namespace.\n If makePrimary\u003d\u003dtrue, then the new label is made primary.\n If makeUnique\u003d\u003dtrue, then if the name is a duplicate, the address\n will be concatenated to name to make it unique.\n@param address the address to create the symbol\n@param name the name of the symbol\n@param makePrimary true if the symbol should be made primary\n@param sourceType the source type.\n@return the newly created code or function symbol\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to create the symbol"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbol"
        },
        {
          "name": "makePrimary",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if the symbol should be made primary"
        },
        {
          "name": "sourceType",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source type."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the newly created code or function symbol"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createLabel",
      "comment": "Creates a label at the specified address in the specified namespace.\n If makePrimary\u003d\u003dtrue, then the new label is made primary if permitted.\n If makeUnique\u003d\u003dtrue, then if the name is a duplicate, the address\n will be concatenated to name to make it unique.",
      "javadoc": "Creates a label at the specified address in the specified namespace.\n If makePrimary\u003d\u003dtrue, then the new label is made primary if permitted.\n If makeUnique\u003d\u003dtrue, then if the name is a duplicate, the address\n will be concatenated to name to make it unique.\n@param address the address to create the symbol\n@param name the name of the symbol\n@param namespace label\u0027s parent namespace\n@param makePrimary true if the symbol should be made primary\n@param sourceType the source type.\n@return the newly created code or function symbol\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to create the symbol"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbol"
        },
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "label\u0027s parent namespace"
        },
        {
          "name": "makePrimary",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if the symbol should be made primary"
        },
        {
          "name": "sourceType",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source type."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the newly created code or function symbol"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createSymbol",
      "comment": "",
      "javadoc": "@deprecated use {@link #createLabel(Address, String, boolean, SourceType)} instead. Deprecated in Ghidra 7.4",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": ""
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "makePrimary",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": ""
        },
        {
          "name": "makeUnique",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": ""
        },
        {
          "name": "sourceType",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": ""
        }
      ]
    },
    {
      "name": "addEntryPoint",
      "comment": "Adds an entry point at the specified address.",
      "javadoc": "Adds an entry point at the specified address.\n@param address address to create entry point",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "address to create entry point"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "removeEntryPoint",
      "comment": "Removes the entry point at the specified address.",
      "javadoc": "Removes the entry point at the specified address.\n@param address address of entry point to remove",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "address of entry point to remove"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "removeSymbol",
      "comment": "Deletes the symbol with the specified name at the specified address.",
      "javadoc": "Deletes the symbol with the specified name at the specified address.\n@param address the address of the symbol to delete\n@param name the name of the symbol to delete\n@return true if the symbol was deleted",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address of the symbol to delete"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbol to delete"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the symbol was deleted"
      },
      "throws": []
    },
    {
      "name": "setPlateComment",
      "comment": "Sets a PLATE comment at the specified address",
      "javadoc": "Sets a PLATE comment at the specified address\n@param address the address to set the PLATE comment\n@param comment the PLATE comment\n@return true if the PLATE comment was successfully set",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to set the PLATE comment"
        },
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the PLATE comment"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the PLATE comment was successfully set"
      },
      "throws": []
    },
    {
      "name": "setPreComment",
      "comment": "Sets a PRE comment at the specified address",
      "javadoc": "Sets a PRE comment at the specified address\n@param address the address to set the PRE comment\n@param comment the PRE comment\n@return true if the PRE comment was successfully set",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to set the PRE comment"
        },
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the PRE comment"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the PRE comment was successfully set"
      },
      "throws": []
    },
    {
      "name": "setPostComment",
      "comment": "Sets a POST comment at the specified address",
      "javadoc": "Sets a POST comment at the specified address\n@param address the address to set the POST comment\n@param comment the POST comment\n@return true if the POST comment was successfully set",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to set the POST comment"
        },
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the POST comment"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the POST comment was successfully set"
      },
      "throws": []
    },
    {
      "name": "setEOLComment",
      "comment": "Sets an EOL comment at the specified address",
      "javadoc": "Sets an EOL comment at the specified address\n@param address the address to set the EOL comment\n@param comment the EOL comment\n@return true if the EOL comment was successfully set",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to set the EOL comment"
        },
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the EOL comment"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the EOL comment was successfully set"
      },
      "throws": []
    },
    {
      "name": "setRepeatableComment",
      "comment": "Sets a repeatable comment at the specified address",
      "javadoc": "Sets a repeatable comment at the specified address\n@param address the address to set the repeatable comment\n@param comment the repeatable comment\n@return true if the repeatable comment was successfully set",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to set the repeatable comment"
        },
        {
          "name": "comment",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the repeatable comment"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if the repeatable comment was successfully set"
      },
      "throws": []
    },
    {
      "name": "getPlateComment",
      "comment": "Returns the PLATE comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling GhidraScript#getPlateCommentAsRendered(Address) will\n return the text of the comment as it is rendered in the display.",
      "javadoc": "Returns the PLATE comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling {@link GhidraScript#getPlateCommentAsRendered(Address)} will\n return the text of the comment as it is rendered in the display.\n@param address the address to get the comment\n@return the PLATE comment at the specified address or null\n if one does not exist\n@see GhidraScript#getPlateCommentAsRendered(Address)",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to get the comment"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the PLATE comment at the specified address or null\n if one does not exist"
      },
      "throws": []
    },
    {
      "name": "getPreComment",
      "comment": "Returns the PRE comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling GhidraScript#getPreCommentAsRendered(Address) will\n return the text of the comment as it is rendered in the display.",
      "javadoc": "Returns the PRE comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling {@link GhidraScript#getPreCommentAsRendered(Address)} will\n return the text of the comment as it is rendered in the display.\n@param address the address to get the comment\n@return the PRE comment at the specified address or null\n if one does not exist\n@see GhidraScript#getPreCommentAsRendered(Address)",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to get the comment"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the PRE comment at the specified address or null\n if one does not exist"
      },
      "throws": []
    },
    {
      "name": "getPostComment",
      "comment": "Returns the POST comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling GhidraScript#getPostCommentAsRendered(Address) will\n return the text of the comment as it is rendered in the display.",
      "javadoc": "Returns the POST comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling {@link GhidraScript#getPostCommentAsRendered(Address)} will\n return the text of the comment as it is rendered in the display.\n@param address the address to get the comment\n@return the POST comment at the specified address or null\n if one does not exist\n@see GhidraScript#getPostCommentAsRendered(Address)",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to get the comment"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the POST comment at the specified address or null\n if one does not exist"
      },
      "throws": []
    },
    {
      "name": "getEOLComment",
      "comment": "Returns the EOL comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling GhidraScript#getEOLCommentAsRendered(Address) will\n return the text of the comment as it is rendered in the display.",
      "javadoc": "Returns the EOL comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling {@link GhidraScript#getEOLCommentAsRendered(Address)} will\n return the text of the comment as it is rendered in the display.\n@param address the address to get the comment\n@return the EOL comment at the specified address or null\n if one does not exist\n@see GhidraScript#getEOLCommentAsRendered(Address)",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to get the comment"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the EOL comment at the specified address or null\n if one does not exist"
      },
      "throws": []
    },
    {
      "name": "getRepeatableComment",
      "comment": "Returns the repeatable comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling GhidraScript#getRepeatableCommentAsRendered(Address) will\n return the text of the comment as it is rendered in the display.",
      "javadoc": "Returns the repeatable comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling {@link GhidraScript#getRepeatableCommentAsRendered(Address)} will\n return the text of the comment as it is rendered in the display.\n@param address the address to get the comment\n@return the repeatable comment at the specified address or null\n if one does not exist\n@see GhidraScript#getRepeatableCommentAsRendered(Address)",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to get the comment"
        }
      ],
      "return": {
        "type_long": "java.lang.String",
        "type_short": "String",
        "comment": "the repeatable comment at the specified address or null\n if one does not exist"
      },
      "throws": []
    },
    {
      "name": "find",
      "comment": "Finds the first occurrence of the byte\n starting from the address. If the start address\n is null, then the find will start from the minimum address\n of the program.",
      "javadoc": "Finds the first occurrence of the byte\n starting from the address. If the start address\n is null, then the find will start from the minimum address\n of the program.\n@param start the address to start searching\n@param value the byte to search for\n@return the first address where the byte was found",
      "static": false,
      "params": [
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to start searching"
        },
        {
          "name": "value",
          "type_long": "byte",
          "type_short": "byte",
          "comment": "the byte to search for"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "the first address where the byte was found"
      },
      "throws": []
    },
    {
      "name": "find",
      "comment": "Finds the first occurrence of the byte array sequence\n starting from the address. If the start address\n is null, then the find will start from the minimum address\n of the program.",
      "javadoc": "Finds the first occurrence of the byte array sequence\n starting from the address. If the start address\n is null, then the find will start from the minimum address\n of the program.\n@param start the address to start searching\n@param values the byte array sequence to search for\n@return the first address where the byte was found, or\n null if the bytes were not found",
      "static": false,
      "params": [
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to start searching"
        },
        {
          "name": "values",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "the byte array sequence to search for"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "the first address where the byte was found, or\n null if the bytes were not found"
      },
      "throws": []
    },
    {
      "name": "findBytes",
      "comment": "Finds the first occurrence of the byte array sequence that matches the given byte string,\n starting from the address. If the start address is null, then the find will start\n from the minimum address of the program.\n \n The byteString may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n ",
      "javadoc": "Finds the first occurrence of the byte array sequence that matches the given byte string,\n starting from the address. If the start address is null, then the find will start\n from the minimum address of the program.\n \u003cp\u003e\n The \u003ccode\u003ebyteString\u003c/code\u003e may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \u003cpre\u003e\n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n \u003c/pre\u003e\n@param start the address to start searching.  If null, then the start of the program\n        will be used.\n@param byteString the byte pattern for which to search\n@return the first address where the byte was found, or null if the bytes were not found\n@throws IllegalArgumentException if the byteString is not a valid regular expression\n@see #findBytes(Address, String, int)",
      "static": false,
      "params": [
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to start searching.  If null, then the start of the program\n        will be used."
        },
        {
          "name": "byteString",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the byte pattern for which to search"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "the first address where the byte was found, or null if the bytes were not found"
      },
      "throws": []
    },
    {
      "name": "findBytes",
      "comment": "Finds the first  occurrences of the byte array sequence that matches\n the given byte string, starting from the address. If the start address is null, then the\n find will start from the minimum address of the program.\n \n The byteString may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n ",
      "javadoc": "Finds the first {@code \u003cmatchLimit\u003e} occurrences of the byte array sequence that matches\n the given byte string, starting from the address. If the start address is null, then the\n find will start from the minimum address of the program.\n \u003cp\u003e\n The \u003ccode\u003ebyteString\u003c/code\u003e may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \u003cpre\u003e\n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n \u003c/pre\u003e\n@param start the address to start searching.  If null, then the start of the program\n        will be used.\n@param byteString the byte pattern for which to search\n@param matchLimit The number of matches to which the search should be restricted\n@return the start addresses that contain byte patterns that match the given byteString\n@throws IllegalArgumentException if the byteString is not a valid regular expression\n@see #findBytes(Address, String)",
      "static": false,
      "params": [
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to start searching.  If null, then the start of the program\n        will be used."
        },
        {
          "name": "byteString",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the byte pattern for which to search"
        },
        {
          "name": "matchLimit",
          "type_long": "int",
          "type_short": "int",
          "comment": "The number of matches to which the search should be restricted"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address[]",
        "type_short": "ghidra.program.model.address.Address[]",
        "comment": "the start addresses that contain byte patterns that match the given byteString"
      },
      "throws": []
    },
    {
      "name": "findBytes",
      "comment": "Finds the first  occurrences of the byte array sequence that matches\n the given byte string, starting from the address. If the start address is null, then the\n find will start from the minimum address of the program.\n \n The byteString may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n ",
      "javadoc": "Finds the first {@code \u003cmatchLimit\u003e} occurrences of the byte array sequence that matches\n the given byte string, starting from the address. If the start address is null, then the\n find will start from the minimum address of the program.\n \u003cp\u003e\n The \u003ccode\u003ebyteString\u003c/code\u003e may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \u003cpre\u003e\n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n \u003c/pre\u003e\n@param start the address to start searching.  If null, then the start of the program\n        will be used.\n@param byteString the byte pattern for which to search\n@param matchLimit The number of matches to which the search should be restricted\n@param alignment byte alignment to use for search starts. For example, a value of\n    1 searches from every byte.  A value of 2 only matches runs that begin on a even\n    address boundary.\n@return the start addresses that contain byte patterns that match the given byteString\n@throws IllegalArgumentException if the byteString is not a valid regular expression\n@see #findBytes(Address, String)",
      "static": false,
      "params": [
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to start searching.  If null, then the start of the program\n        will be used."
        },
        {
          "name": "byteString",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the byte pattern for which to search"
        },
        {
          "name": "matchLimit",
          "type_long": "int",
          "type_short": "int",
          "comment": "The number of matches to which the search should be restricted"
        },
        {
          "name": "alignment",
          "type_long": "int",
          "type_short": "int",
          "comment": "byte alignment to use for search starts. For example, a value of\n    1 searches from every byte.  A value of 2 only matches runs that begin on a even\n    address boundary."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address[]",
        "type_short": "ghidra.program.model.address.Address[]",
        "comment": "the start addresses that contain byte patterns that match the given byteString"
      },
      "throws": []
    },
    {
      "name": "findBytes",
      "comment": "Finds a byte pattern within an addressSet.\n\n Note: The ranges within the addressSet are NOT treated as a contiguous set when searching\n \n The byteString may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n ",
      "javadoc": "Finds a byte pattern within an addressSet.\n\n Note: The ranges within the addressSet are NOT treated as a contiguous set when searching\n \u003cp\u003e\n The \u003ccode\u003ebyteString\u003c/code\u003e may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \u003cpre\u003e\n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n \u003c/pre\u003e\n@param set the addressSet specifying which addresses to search.\n@param byteString the byte pattern for which to search\n@param matchLimit The number of matches to which the search should be restricted\n@param alignment byte alignment to use for search starts. For example, a value of\n    1 searches from every byte.  A value of 2 only matches runs that begin on a even\n    address boundary.\n@return the start addresses that contain byte patterns that match the given byteString\n@throws IllegalArgumentException if the byteString is not a valid regular expression\n@see #findBytes(Address, String)",
      "static": false,
      "params": [
        {
          "name": "set",
          "type_long": "ghidra.program.model.address.AddressSetView",
          "type_short": "AddressSetView",
          "comment": "the addressSet specifying which addresses to search."
        },
        {
          "name": "byteString",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the byte pattern for which to search"
        },
        {
          "name": "matchLimit",
          "type_long": "int",
          "type_short": "int",
          "comment": "The number of matches to which the search should be restricted"
        },
        {
          "name": "alignment",
          "type_long": "int",
          "type_short": "int",
          "comment": "byte alignment to use for search starts. For example, a value of\n    1 searches from every byte.  A value of 2 only matches runs that begin on a even\n    address boundary."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address[]",
        "type_short": "ghidra.program.model.address.Address[]",
        "comment": "the start addresses that contain byte patterns that match the given byteString"
      },
      "throws": []
    },
    {
      "name": "findBytes",
      "comment": "Finds a byte pattern within an addressSet.\n\n Note: When searchAcrossAddressGaps is set to true, the ranges within the addressSet are\n treated as a contiguous set when searching.\n\n \n The byteString may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n ",
      "javadoc": "Finds a byte pattern within an addressSet.\n\n Note: When searchAcrossAddressGaps is set to true, the ranges within the addressSet are\n treated as a contiguous set when searching.\n\n \u003cp\u003e\n The \u003ccode\u003ebyteString\u003c/code\u003e may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \u003cpre\u003e\n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n \u003c/pre\u003e\n@param set the addressSet specifying which addresses to search.\n@param byteString the byte pattern for which to search\n@param matchLimit The number of matches to which the search should be restricted\n@param alignment byte alignment to use for search starts. For example, a value of\n        1 searches from every byte.  A value of 2 only matches runs that begin on a even\n        address boundary.\n@param searchAcrossAddressGaps when set to \u0027true\u0027 searches for matches across the gaps\n        of each addressRange contained in the addresSet.\n@return the start addresses that contain byte patterns that match the given byteString\n@throws IllegalArgumentException if the byteString is not a valid regular expression\n@see #findBytes(Address, String)",
      "static": false,
      "params": [
        {
          "name": "set",
          "type_long": "ghidra.program.model.address.AddressSetView",
          "type_short": "AddressSetView",
          "comment": "the addressSet specifying which addresses to search."
        },
        {
          "name": "byteString",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the byte pattern for which to search"
        },
        {
          "name": "matchLimit",
          "type_long": "int",
          "type_short": "int",
          "comment": "The number of matches to which the search should be restricted"
        },
        {
          "name": "alignment",
          "type_long": "int",
          "type_short": "int",
          "comment": "byte alignment to use for search starts. For example, a value of\n        1 searches from every byte.  A value of 2 only matches runs that begin on a even\n        address boundary."
        },
        {
          "name": "searchAcrossAddressGaps",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "when set to \u0027true\u0027 searches for matches across the gaps\n        of each addressRange contained in the addresSet."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address[]",
        "type_short": "ghidra.program.model.address.Address[]",
        "comment": "the start addresses that contain byte patterns that match the given byteString"
      },
      "throws": []
    },
    {
      "name": "find",
      "comment": "Finds the first occurrence of \u0027text\u0027 in the program listing.\n The search order is defined as:\n \n PLATE comments\n PRE comments\n labels\n code unit mnemonics and operands\n EOL comments\n repeatable comments\n POST comments\n ",
      "javadoc": "Finds the first occurrence of \u0027text\u0027 in the program listing.\n The search order is defined as:\n \u003col\u003e\n \u003cli\u003ePLATE comments\u003c/li\u003e\n \u003cli\u003ePRE comments\u003c/li\u003e\n \u003cli\u003elabels\u003c/li\u003e\n \u003cli\u003ecode unit mnemonics and operands\u003c/li\u003e\n \u003cli\u003eEOL comments\u003c/li\u003e\n \u003cli\u003erepeatable comments\u003c/li\u003e\n \u003cli\u003ePOST comments\u003c/li\u003e\n \u003c/ol\u003e\n@param text the text to search for\n@return the first address where the \u0027text\u0027 was found, or null\n  if the text was not found",
      "static": false,
      "params": [
        {
          "name": "text",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the text to search for"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "the first address where the \u0027text\u0027 was found, or null\n  if the text was not found"
      },
      "throws": []
    },
    {
      "name": "findStrings",
      "comment": "Search for sequences of Ascii strings in program memory.  See AsciiCharSetRecognizer\n to see exactly what chars are considered ASCII for purposes of this search.",
      "javadoc": "Search for sequences of Ascii strings in program memory.  See {@link AsciiCharSetRecognizer}\n to see exactly what chars are considered ASCII for purposes of this search.\n@param addressSet The address set to search. Use null to search all memory;\n@param minimumStringLength The smallest number of chars in a sequence to be considered a\n \"string\".\n@param alignment specifies any alignment requirements for the start of the string.  An\n alignment of 1, means the string can start at any address.  An alignment of 2 means the\n string must start on an even address and so on.  Only allowed values are 1,2, and 4.\n@param requireNullTermination If true, only strings that end in a null will be returned.\n@param includeAllCharWidths if true, UTF16 and UTF32 size strings will be included in\n addition to UTF8.\n@return a list of \"FoundString\" objects which contain the addresses, length, and type of\n possible strings.",
      "static": false,
      "params": [
        {
          "name": "addressSet",
          "type_long": "ghidra.program.model.address.AddressSetView",
          "type_short": "AddressSetView",
          "comment": "The address set to search. Use null to search all memory;"
        },
        {
          "name": "minimumStringLength",
          "type_long": "int",
          "type_short": "int",
          "comment": "The smallest number of chars in a sequence to be considered a\n \"string\"."
        },
        {
          "name": "alignment",
          "type_long": "int",
          "type_short": "int",
          "comment": "specifies any alignment requirements for the start of the string.  An\n alignment of 1, means the string can start at any address.  An alignment of 2 means the\n string must start on an even address and so on.  Only allowed values are 1,2, and 4."
        },
        {
          "name": "requireNullTermination",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "If true, only strings that end in a null will be returned."
        },
        {
          "name": "includeAllCharWidths",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true, UTF16 and UTF32 size strings will be included in\n addition to UTF8."
        }
      ],
      "return": {
        "type_long": "java.util.List\u003cghidra.program.util.string.FoundString\u003e",
        "type_short": "List",
        "comment": "a list of \"FoundString\" objects which contain the addresses, length, and type of\n possible strings."
      },
      "throws": []
    },
    {
      "name": "findPascalStrings",
      "comment": "Search for sequences of Pascal Ascii strings in program memory.  See\n AsciiCharSetRecognizer to see exactly what chars are considered ASCII for purposes\n of this search.",
      "javadoc": "Search for sequences of Pascal Ascii strings in program memory.  See\n {@link AsciiCharSetRecognizer} to see exactly what chars are considered ASCII for purposes\n of this search.\n@param addressSet The address set to search. Use null to search all memory;\n@param minimumStringLength The smallest number of chars in a sequence to be considered a\n \"string\".\n@param alignment specifies any alignment requirements for the start of the string.  An\n alignment of 1, means the string can start at any address.  An alignment of 2 means the\n string must start on an even address and so on.  Only allowed values are 1,2, and 4.\n@param includePascalUnicode if true, UTF16 size strings will be included in addition to UTF8.\n@return a list of \"FoundString\" objects which contain the addresses, length, and type of\n possible strings.",
      "static": false,
      "params": [
        {
          "name": "addressSet",
          "type_long": "ghidra.program.model.address.AddressSetView",
          "type_short": "AddressSetView",
          "comment": "The address set to search. Use null to search all memory;"
        },
        {
          "name": "minimumStringLength",
          "type_long": "int",
          "type_short": "int",
          "comment": "The smallest number of chars in a sequence to be considered a\n \"string\"."
        },
        {
          "name": "alignment",
          "type_long": "int",
          "type_short": "int",
          "comment": "specifies any alignment requirements for the start of the string.  An\n alignment of 1, means the string can start at any address.  An alignment of 2 means the\n string must start on an even address and so on.  Only allowed values are 1,2, and 4."
        },
        {
          "name": "includePascalUnicode",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "if true, UTF16 size strings will be included in addition to UTF8."
        }
      ],
      "return": {
        "type_long": "java.util.List\u003cghidra.program.util.string.FoundString\u003e",
        "type_short": "List",
        "comment": "a list of \"FoundString\" objects which contain the addresses, length, and type of\n possible strings."
      },
      "throws": []
    },
    {
      "name": "createFunction",
      "comment": "Creates a function at entry point with the specified name",
      "javadoc": "Creates a function at entry point with the specified name\n@param entryPoint the entry point of the function\n@param name the name of the function or null for a default function\n@return the new function or null if the function was not created",
      "static": false,
      "params": [
        {
          "name": "entryPoint",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the entry point of the function"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the function or null for a default function"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Function",
        "type_short": "Function",
        "comment": "the new function or null if the function was not created"
      },
      "throws": []
    },
    {
      "name": "removeFunction",
      "comment": "Removes the function from the current program.",
      "javadoc": "Removes the function from the current program.\n@param function the function to remove",
      "static": false,
      "params": [
        {
          "name": "function",
          "type_long": "ghidra.program.model.listing.Function",
          "type_short": "Function",
          "comment": "the function to remove"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "removeFunctionAt",
      "comment": "Removes the function with the given entry point.",
      "javadoc": "Removes the function with the given entry point.\n@param entryPoint the entry point of the function to remove",
      "static": false,
      "params": [
        {
          "name": "entryPoint",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the entry point of the function to remove"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getFunctionAt",
      "comment": "Returns the function with the specified entry point, or\n null if no function exists.",
      "javadoc": "Returns the function with the specified entry point, or\n null if no function exists.\n@param entryPoint the function entry point address\n@return the function with the specified entry point, or\n null if no function exists",
      "static": false,
      "params": [
        {
          "name": "entryPoint",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the function entry point address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Function",
        "type_short": "Function",
        "comment": "the function with the specified entry point, or\n null if no function exists"
      },
      "throws": []
    },
    {
      "name": "getFunctionContaining",
      "comment": "Returns the function containing the specified address.",
      "javadoc": "Returns the function containing the specified address.\n@param address the address\n@return the function containing the specified address",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Function",
        "type_short": "Function",
        "comment": "the function containing the specified address"
      },
      "throws": []
    },
    {
      "name": "getFunctionBefore",
      "comment": "Returns the function defined before the specified function in address order.",
      "javadoc": "Returns the function defined before the specified function in address order.\n@param function the function\n@return the function defined before the specified function",
      "static": false,
      "params": [
        {
          "name": "function",
          "type_long": "ghidra.program.model.listing.Function",
          "type_short": "Function",
          "comment": "the function"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Function",
        "type_short": "Function",
        "comment": "the function defined before the specified function"
      },
      "throws": []
    },
    {
      "name": "getFunctionBefore",
      "comment": "Returns the function defined before the specified address.",
      "javadoc": "Returns the function defined before the specified address.\n@param address the address\n@return the function defined before the specified address",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Function",
        "type_short": "Function",
        "comment": "the function defined before the specified address"
      },
      "throws": []
    },
    {
      "name": "getFunctionAfter",
      "comment": "Returns the function defined before the specified function in address order.",
      "javadoc": "Returns the function defined before the specified function in address order.\n@param function the function\n@return the function defined before the specified function",
      "static": false,
      "params": [
        {
          "name": "function",
          "type_long": "ghidra.program.model.listing.Function",
          "type_short": "Function",
          "comment": "the function"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Function",
        "type_short": "Function",
        "comment": "the function defined before the specified function"
      },
      "throws": []
    },
    {
      "name": "getFunctionAfter",
      "comment": "Returns the function defined after the specified address.",
      "javadoc": "Returns the function defined after the specified address.\n@param address the address\n@return the function defined after the specified address",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Function",
        "type_short": "Function",
        "comment": "the function defined after the specified address"
      },
      "throws": []
    },
    {
      "name": "getFunction",
      "comment": "Returns the function with the specified name, or\n null if no function exists. (Now returns the first one it finds with that name)",
      "javadoc": "Returns the function with the specified name, or\n null if no function exists. (Now returns the first one it finds with that name)\n@param name the name of the function\n@return the function with the specified name, or\n null if no function exists\n@deprecated this method makes no sense in the new world order where function  names\n \t\t\t   no longer have to be unique. Use {@link #getGlobalFunctions(String)}\n \t\t\t   Deprecated in Ghidra 7.4",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the function"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Function",
        "type_short": "Function",
        "comment": "the function with the specified name, or\n null if no function exists"
      },
      "throws": []
    },
    {
      "name": "getGlobalFunctions",
      "comment": "Returns a list of all functions in the global namespace with the given name.",
      "javadoc": "Returns a list of all functions in the global namespace with the given name.\n@param name the name of the function\n@return the function with the specified name, or",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the function"
        }
      ],
      "return": {
        "type_long": "java.util.List\u003cghidra.program.model.listing.Function\u003e",
        "type_short": "List",
        "comment": "the function with the specified name, or"
      },
      "throws": []
    },
    {
      "name": "getFirstFunction",
      "comment": "Returns the first function in the current program.",
      "javadoc": "Returns the first function in the current program.\n@return the first function in the current program",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Function",
        "type_short": "Function",
        "comment": "the first function in the current program"
      },
      "throws": []
    },
    {
      "name": "getLastFunction",
      "comment": "Returns the last function in the current program.",
      "javadoc": "Returns the last function in the current program.\n@return the last function in the current program",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Function",
        "type_short": "Function",
        "comment": "the last function in the current program"
      },
      "throws": []
    },
    {
      "name": "getFirstInstruction",
      "comment": "Returns the first instruction in the current program.",
      "javadoc": "Returns the first instruction in the current program.\n@return the first instruction in the current program",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Instruction",
        "type_short": "Instruction",
        "comment": "the first instruction in the current program"
      },
      "throws": []
    },
    {
      "name": "getFirstInstruction",
      "comment": "Returns the first instruction in the function.",
      "javadoc": "Returns the first instruction in the function.\n@param function the function\n@return the first instruction in the function",
      "static": false,
      "params": [
        {
          "name": "function",
          "type_long": "ghidra.program.model.listing.Function",
          "type_short": "Function",
          "comment": "the function"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Instruction",
        "type_short": "Instruction",
        "comment": "the first instruction in the function"
      },
      "throws": []
    },
    {
      "name": "getLastInstruction",
      "comment": "Returns the last instruction in the current program.",
      "javadoc": "Returns the last instruction in the current program.\n@return the last instruction in the current program",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Instruction",
        "type_short": "Instruction",
        "comment": "the last instruction in the current program"
      },
      "throws": []
    },
    {
      "name": "getInstructionAt",
      "comment": "Returns the instruction at the specified address or null if no instruction exists.",
      "javadoc": "Returns the instruction at the specified address or null if no instruction exists.\n@param address the instruction address\n@return the instruction at the specified address or null if no instruction exists",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the instruction address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Instruction",
        "type_short": "Instruction",
        "comment": "the instruction at the specified address or null if no instruction exists"
      },
      "throws": []
    },
    {
      "name": "getInstructionContaining",
      "comment": "Returns the instruction containing the specified address or null if no instruction exists.",
      "javadoc": "Returns the instruction containing the specified address or null if no instruction exists.\n@param address the instruction address\n@return the instruction containing the specified address or null if no instruction exists",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the instruction address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Instruction",
        "type_short": "Instruction",
        "comment": "the instruction containing the specified address or null if no instruction exists"
      },
      "throws": []
    },
    {
      "name": "getInstructionBefore",
      "comment": "Returns the instruction defined before the specified instruction or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.",
      "javadoc": "Returns the instruction defined before the specified instruction or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.\n@param instruction the instruction\n@return the instruction defined before the specified instruction or null if no instruction exists",
      "static": false,
      "params": [
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": "the instruction"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Instruction",
        "type_short": "Instruction",
        "comment": "the instruction defined before the specified instruction or null if no instruction exists"
      },
      "throws": []
    },
    {
      "name": "getInstructionBefore",
      "comment": "Returns the instruction defined before the specified address or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.",
      "javadoc": "Returns the instruction defined before the specified address or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.\n@param address the address of the instruction\n@return the instruction defined before the specified address or null if no instruction exists",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address of the instruction"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Instruction",
        "type_short": "Instruction",
        "comment": "the instruction defined before the specified address or null if no instruction exists"
      },
      "throws": []
    },
    {
      "name": "getInstructionAfter",
      "comment": "Returns the instruction defined after the specified instruction or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.",
      "javadoc": "Returns the instruction defined after the specified instruction or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.\n@param instruction the instruction\n@return the instruction defined after the specified instruction or null if no instruction exists",
      "static": false,
      "params": [
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": "the instruction"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Instruction",
        "type_short": "Instruction",
        "comment": "the instruction defined after the specified instruction or null if no instruction exists"
      },
      "throws": []
    },
    {
      "name": "getInstructionAfter",
      "comment": "Returns the instruction defined after the specified address or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.",
      "javadoc": "Returns the instruction defined after the specified address or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.\n@param address the address of the prior instruction\n@return the instruction defined after the specified address or null if no instruction exists",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address of the prior instruction"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Instruction",
        "type_short": "Instruction",
        "comment": "the instruction defined after the specified address or null if no instruction exists"
      },
      "throws": []
    },
    {
      "name": "getFirstData",
      "comment": "Returns the first defined data in the current program.",
      "javadoc": "Returns the first defined data in the current program.\n@return the first defined data in the current program",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the first defined data in the current program"
      },
      "throws": []
    },
    {
      "name": "getLastData",
      "comment": "Returns the last defined data in the current program.",
      "javadoc": "Returns the last defined data in the current program.\n@return the last defined data in the current program",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the last defined data in the current program"
      },
      "throws": []
    },
    {
      "name": "getDataAt",
      "comment": "Returns the defined data at the specified address or null if no data exists.",
      "javadoc": "Returns the defined data at the specified address or null if no data exists.\n@param address the data address\n@return the data at the specified address or null if no data exists",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the data address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the data at the specified address or null if no data exists"
      },
      "throws": []
    },
    {
      "name": "getDataContaining",
      "comment": "Returns the defined data containing the specified address or null if no data exists.",
      "javadoc": "Returns the defined data containing the specified address or null if no data exists.\n@param address the data address\n@return the defined data containing the specified address or null if no data exists",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the data address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the defined data containing the specified address or null if no data exists"
      },
      "throws": []
    },
    {
      "name": "getDataBefore",
      "comment": "Returns the defined data before the specified data or null if no data exists.",
      "javadoc": "Returns the defined data before the specified data or null if no data exists.\n@param data the succeeding data\n@return the defined data before the specified data or null if no data exists",
      "static": false,
      "params": [
        {
          "name": "data",
          "type_long": "ghidra.program.model.listing.Data",
          "type_short": "Data",
          "comment": "the succeeding data"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the defined data before the specified data or null if no data exists"
      },
      "throws": []
    },
    {
      "name": "getDataBefore",
      "comment": "Returns the defined data before the specified address or null if no data exists.",
      "javadoc": "Returns the defined data before the specified address or null if no data exists.\n@param address the data address\n@return the defined data before the specified address or null if no data exists",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the data address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the defined data before the specified address or null if no data exists"
      },
      "throws": []
    },
    {
      "name": "getDataAfter",
      "comment": "Returns the defined data after the specified data or null if no data exists.",
      "javadoc": "Returns the defined data after the specified data or null if no data exists.\n@param data preceeding data\n@return the defined data after the specified data or null if no data exists",
      "static": false,
      "params": [
        {
          "name": "data",
          "type_long": "ghidra.program.model.listing.Data",
          "type_short": "Data",
          "comment": "preceeding data"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the defined data after the specified data or null if no data exists"
      },
      "throws": []
    },
    {
      "name": "getDataAfter",
      "comment": "Returns the defined data after the specified address or null if no data exists.",
      "javadoc": "Returns the defined data after the specified address or null if no data exists.\n@param address the data address\n@return the defined data after the specified address or null if no data exists",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the data address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the defined data after the specified address or null if no data exists"
      },
      "throws": []
    },
    {
      "name": "getUndefinedDataAt",
      "comment": "Returns the undefined data at the specified address or null if no undefined data exists.",
      "javadoc": "Returns the undefined data at the specified address or null if no undefined data exists.\n@param address the undefined data address\n@return the undefined data at the specified address or null if no undefined data exists",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the undefined data address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the undefined data at the specified address or null if no undefined data exists"
      },
      "throws": []
    },
    {
      "name": "getUndefinedDataBefore",
      "comment": "Returns the undefined data before the specified address or null if no undefined data exists.",
      "javadoc": "Returns the undefined data before the specified address or null if no undefined data exists.\n@param address the undefined data address\n@return the undefined data before the specified address or null if no undefined data exists",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the undefined data address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the undefined data before the specified address or null if no undefined data exists"
      },
      "throws": []
    },
    {
      "name": "getUndefinedDataAfter",
      "comment": "Returns the undefined data after the specified address or null if no undefined data exists.",
      "javadoc": "Returns the undefined data after the specified address or null if no undefined data exists.\n@param address the undefined data address\n@return the undefined data after the specified address or null if no undefined data exists",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the undefined data address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the undefined data after the specified address or null if no undefined data exists"
      },
      "throws": []
    },
    {
      "name": "getSymbolAt",
      "comment": "Returns the symbol with the specified address and name, or\n null if no symbol exists.",
      "javadoc": "Returns the symbol with the specified address and name, or\n null if no symbol exists.\n@param address the symbol address\n@param name the symbol name\n@return the symbol with the specified address and name, or\n null if no symbol exists\n@deprecated Since the same label name can be at the same address if in a different namespace,\n this method is ambiguous. Use {@link #getSymbolAt(Address, String, Namespace)} instead.",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the symbol address"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the symbol name"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the symbol with the specified address and name, or\n null if no symbol exists"
      },
      "throws": []
    },
    {
      "name": "getSymbolAt",
      "comment": "Returns the symbol with the specified address, name, and namespace",
      "javadoc": "Returns the symbol with the specified address, name, and namespace\n@param address the symbol address\n@param name the symbol name\n@param namespace the parent namespace for the symbol.\n@return the symbol with the specified address, name, and namespace, or\n null if no symbol exists",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the symbol address"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the symbol name"
        },
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the parent namespace for the symbol."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the symbol with the specified address, name, and namespace, or\n null if no symbol exists"
      },
      "throws": []
    },
    {
      "name": "getSymbolAfter",
      "comment": "Returns the next non-default primary symbol defined\n after the given symbol.",
      "javadoc": "Returns the next non-default primary symbol defined\n after the given symbol.\n@param symbol the symbol to use as a starting point\n@return the next non-default primary symbol",
      "static": false,
      "params": [
        {
          "name": "symbol",
          "type_long": "ghidra.program.model.symbol.Symbol",
          "type_short": "Symbol",
          "comment": "the symbol to use as a starting point"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the next non-default primary symbol"
      },
      "throws": []
    },
    {
      "name": "getSymbolAfter",
      "comment": "Returns the next non-default primary symbol defined\n after the given address.",
      "javadoc": "Returns the next non-default primary symbol defined\n after the given address.\n@param address the address to use as a starting point\n@return the next non-default primary symbol",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to use as a starting point"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the next non-default primary symbol"
      },
      "throws": []
    },
    {
      "name": "getSymbolBefore",
      "comment": "Returns the previous non-default primary symbol defined\n before the given symbol.",
      "javadoc": "Returns the previous non-default primary symbol defined\n before the given symbol.\n@param symbol the symbol to use as a starting point\n@return the previous non-default primary symbol",
      "static": false,
      "params": [
        {
          "name": "symbol",
          "type_long": "ghidra.program.model.symbol.Symbol",
          "type_short": "Symbol",
          "comment": "the symbol to use as a starting point"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the previous non-default primary symbol"
      },
      "throws": []
    },
    {
      "name": "getSymbolBefore",
      "comment": "Returns the previous non-default primary symbol defined\n after the previous address.",
      "javadoc": "Returns the previous non-default primary symbol defined\n after the previous address.\n@param address the address to use as a starting point\n@return the next non-default primary symbol",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to use as a starting point"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the next non-default primary symbol"
      },
      "throws": []
    },
    {
      "name": "getSymbolAt",
      "comment": "Returns the PRIMARY symbol at the specified address, or\n null if no symbol exists.",
      "javadoc": "Returns the PRIMARY symbol at the specified address, or\n null if no symbol exists.\n@param address the symbol address\n@return the PRIMARY symbol at the specified address, or\n null if no symbol exists",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the symbol address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the PRIMARY symbol at the specified address, or\n null if no symbol exists"
      },
      "throws": []
    },
    {
      "name": "getSymbol",
      "comment": "Returns the symbol with the given name in the given namespace if there is only one.\n Pass null for namespace to indicate the global namespace.",
      "javadoc": "Returns the symbol with the given name in the given namespace if there is only one.\n Pass \u003ccode\u003enull\u003c/code\u003e for namespace to indicate the global namespace.\n@param name the name of the symbol\n@param namespace the parent namespace, or null for global namespace\n@return the symbol with the given name in the given namespace\n@throws IllegalStateException if there is more than one symbol with that name.\n@deprecated use {@link #getSymbols(String, Namespace)}",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbol"
        },
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the parent namespace, or null for global namespace"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Symbol",
        "type_short": "Symbol",
        "comment": "the symbol with the given name in the given namespace"
      },
      "throws": []
    },
    {
      "name": "getSymbols",
      "comment": "Returns a list of all the symbols with the given name in the given namespace.",
      "javadoc": "Returns a list of all the symbols with the given name in the given namespace.\n@param name the name of the symbols to retrieve.\n@param namespace the namespace containing the symbols, or null for the global namespace.\n@return a list of all the symbols with the given name in the given namespace.",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbols to retrieve."
        },
        {
          "name": "namespace",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the namespace containing the symbols, or null for the global namespace."
        }
      ],
      "return": {
        "type_long": "java.util.List\u003cghidra.program.model.symbol.Symbol\u003e",
        "type_short": "List",
        "comment": "a list of all the symbols with the given name in the given namespace."
      },
      "throws": []
    },
    {
      "name": "getNamespace",
      "comment": "Returns the non-function namespace with the given name contained inside the\n specified parent namespace.\n Pass null for namespace to indicate the global namespace.",
      "javadoc": "Returns the non-function namespace with the given name contained inside the\n specified parent namespace.\n Pass \u003ccode\u003enull\u003c/code\u003e for namespace to indicate the global namespace.\n@param parent the parent namespace, or null for global namespace\n@param namespaceName the requested namespace\u0027s name\n@return the namespace with the given name or null if not found",
      "static": false,
      "params": [
        {
          "name": "parent",
          "type_long": "ghidra.program.model.symbol.Namespace",
          "type_short": "Namespace",
          "comment": "the parent namespace, or null for global namespace"
        },
        {
          "name": "namespaceName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the requested namespace\u0027s name"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Namespace",
        "type_short": "Namespace",
        "comment": "the namespace with the given name or null if not found"
      },
      "throws": []
    },
    {
      "name": "createFragment",
      "comment": "Creates a fragment in the root folder of the default program tree.",
      "javadoc": "Creates a fragment in the root folder of the default program tree.\n@param fragmentName the name of the fragment\n@param start the start address\n@param end the end address (NOT INCLUSIVE)\n@return the newly created fragment\n@throws DuplicateNameException if the given fragment name already exists\n@throws NotFoundException if any address in the fragment would be outside of the program\n@deprecated This method is deprecated because it did not allow you to include the\n largest possible address.  Instead use the one that takes a start address and a length.",
      "static": false,
      "params": [
        {
          "name": "fragmentName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the fragment"
        },
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the start address"
        },
        {
          "name": "end",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the end address (NOT INCLUSIVE)"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.ProgramFragment",
        "type_short": "ProgramFragment",
        "comment": "the newly created fragment"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "if the given fragment name already exists"
        },
        {
          "type_long": "ghidra.util.exception.NotFoundException",
          "type_short": "NotFoundException",
          "comment": "if any address in the fragment would be outside of the program"
        }
      ]
    },
    {
      "name": "createFragment",
      "comment": "Creates a fragment in the root folder of the default program tree.",
      "javadoc": "Creates a fragment in the root folder of the default program tree.\n@param fragmentName the name of the fragment\n@param start the start address\n@param length the length of the fragment\n@return the newly created fragment\n@throws DuplicateNameException if the given fragment name already exists\n@throws NotFoundException if any address in the fragment would be outside of the program",
      "static": false,
      "params": [
        {
          "name": "fragmentName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the fragment"
        },
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the start address"
        },
        {
          "name": "length",
          "type_long": "long",
          "type_short": "long",
          "comment": "the length of the fragment"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.ProgramFragment",
        "type_short": "ProgramFragment",
        "comment": "the newly created fragment"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "if the given fragment name already exists"
        },
        {
          "type_long": "ghidra.util.exception.NotFoundException",
          "type_short": "NotFoundException",
          "comment": "if any address in the fragment would be outside of the program"
        }
      ]
    },
    {
      "name": "createFragment",
      "comment": "Creates a fragment in the given folder of the default program tree.",
      "javadoc": "Creates a fragment in the given folder of the default program tree.\n@param module the parent module (or folder)\n@param fragmentName the name of the fragment\n@param start the start address\n@param end the end address (NOT INCLUSIVE)\n@return the newly created fragment\n@throws DuplicateNameException if the given fragment name already exists\n@throws NotFoundException if any address in the fragment would be outside of the program\n@deprecated This method is deprecated because it did not allow you to include the\n largest possible address.  Instead use the one that takes a start address and a length.",
      "static": false,
      "params": [
        {
          "name": "module",
          "type_long": "ghidra.program.model.listing.ProgramModule",
          "type_short": "ProgramModule",
          "comment": "the parent module (or folder)"
        },
        {
          "name": "fragmentName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the fragment"
        },
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the start address"
        },
        {
          "name": "end",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the end address (NOT INCLUSIVE)"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.ProgramFragment",
        "type_short": "ProgramFragment",
        "comment": "the newly created fragment"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "if the given fragment name already exists"
        },
        {
          "type_long": "ghidra.util.exception.NotFoundException",
          "type_short": "NotFoundException",
          "comment": "if any address in the fragment would be outside of the program"
        }
      ]
    },
    {
      "name": "createFragment",
      "comment": "Creates a fragment in the given folder of the default program tree.",
      "javadoc": "Creates a fragment in the given folder of the default program tree.\n@param module the parent module (or folder)\n@param fragmentName the name of the fragment\n@param start the start address\n@param length the length of the fragment\n@return the newly created fragment\n@throws DuplicateNameException if the given fragment name already exists\n@throws NotFoundException if any address in the fragment would be outside of the program",
      "static": false,
      "params": [
        {
          "name": "module",
          "type_long": "ghidra.program.model.listing.ProgramModule",
          "type_short": "ProgramModule",
          "comment": "the parent module (or folder)"
        },
        {
          "name": "fragmentName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the fragment"
        },
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the start address"
        },
        {
          "name": "length",
          "type_long": "long",
          "type_short": "long",
          "comment": "the length of the fragment"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.ProgramFragment",
        "type_short": "ProgramFragment",
        "comment": "the newly created fragment"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.DuplicateNameException",
          "type_short": "DuplicateNameException",
          "comment": "if the given fragment name already exists"
        },
        {
          "type_long": "ghidra.util.exception.NotFoundException",
          "type_short": "NotFoundException",
          "comment": "if any address in the fragment would be outside of the program"
        }
      ]
    },
    {
      "name": "getFragment",
      "comment": "Returns the fragment with the specified name\n defined in the given module.",
      "javadoc": "Returns the fragment with the specified name\n defined in the given module.\n@param module the parent module\n@param fragmentName the fragment name\n@return the fragment or null if one does not exist",
      "static": false,
      "params": [
        {
          "name": "module",
          "type_long": "ghidra.program.model.listing.ProgramModule",
          "type_short": "ProgramModule",
          "comment": "the parent module"
        },
        {
          "name": "fragmentName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the fragment name"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.ProgramFragment",
        "type_short": "ProgramFragment",
        "comment": "the fragment or null if one does not exist"
      },
      "throws": []
    },
    {
      "name": "createAddressSet",
      "comment": "Creates a new mutable address set.",
      "javadoc": "Creates a new mutable address set.\n@return a new mutable address set",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.AddressSet",
        "type_short": "AddressSet",
        "comment": "a new mutable address set"
      },
      "throws": []
    },
    {
      "name": "getAddressFactory",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.program.model.address.AddressFactory",
        "type_short": "AddressFactory",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getDataTypes",
      "comment": "Searches through the datatype manager of the current program and\n returns an array of datatypes that match the specified name.\n The datatype manager supports datatypes of the same name in different categories.\n A zero-length array indicates that no datatypes with the specified name exist.",
      "javadoc": "Searches through the datatype manager of the current program and\n returns an array of datatypes that match the specified name.\n The datatype manager supports datatypes of the same name in different categories.\n A zero-length array indicates that no datatypes with the specified name exist.\n@param name the name of the desired datatype\n@return an array of datatypes that match the specified name",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the desired datatype"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.DataType[]",
        "type_short": "ghidra.program.model.data.DataType[]",
        "comment": "an array of datatypes that match the specified name"
      },
      "throws": []
    },
    {
      "name": "createData",
      "comment": "Creates a new defined Data object at the given address.",
      "javadoc": "Creates a new defined Data object at the given address.\n@param address the address at which to create a new Data object.\n@param datatype the Data Type that describes the type of Data object to create.\n@return the newly created Data object\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address at which to create a new Data object."
        },
        {
          "name": "datatype",
          "type_long": "ghidra.program.model.data.DataType",
          "type_short": "DataType",
          "comment": "the Data Type that describes the type of Data object to create."
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the newly created Data object"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createByte",
      "comment": "Creates a byte datatype at the given address.",
      "javadoc": "Creates a byte datatype at the given address.\n@param address the address to create the byte\n@return the newly created Data object\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to create the byte"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the newly created Data object"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createWord",
      "comment": "Creates a word datatype at the given address.",
      "javadoc": "Creates a word datatype at the given address.\n@param address the address to create the word\n@return the newly created Data object\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to create the word"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the newly created Data object"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createDWord",
      "comment": "Creates a dword datatype at the given address.",
      "javadoc": "Creates a dword datatype at the given address.\n@param address the address to create the dword\n@return the newly created Data object\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to create the dword"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the newly created Data object"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createDwords",
      "comment": "Creates a list of dword datatypes starting at the given address.",
      "javadoc": "Creates a list of dword datatypes starting at the given address.\n@param start the start address to create the dwords\n@param count the number of dwords to create\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the start address to create the dwords"
        },
        {
          "name": "count",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of dwords to create"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createQWord",
      "comment": "Creates a qword datatype at the given address.",
      "javadoc": "Creates a qword datatype at the given address.\n@param address the address to create the qword\n@return the newly created Data object\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to create the qword"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the newly created Data object"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createFloat",
      "comment": "Creates a float datatype at the given address.",
      "javadoc": "Creates a float datatype at the given address.\n@param address the address to create the float\n@return the newly created Data object\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to create the float"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the newly created Data object"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createDouble",
      "comment": "Creates a double datatype at the given address.",
      "javadoc": "Creates a double datatype at the given address.\n@param address the address to create the double\n@return the newly created Data object\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to create the double"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the newly created Data object"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createChar",
      "comment": "Creates a char datatype at the given address.",
      "javadoc": "Creates a char datatype at the given address.\n@param address the address to create the char\n@return the newly created Data object\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to create the char"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the newly created Data object"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createAsciiString",
      "comment": "Creates a null terminated ascii string starting\n at the specified address.",
      "javadoc": "Creates a null terminated ascii string starting\n at the specified address.\n@param address the address to create the string\n@return the newly created Data object\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to create the string"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the newly created Data object"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "createAsciiString",
      "comment": "Create an ASCII string at the specified address.",
      "javadoc": "Create an ASCII string at the specified address.\n@param address the address\n@param length length of string (a value of 0 or negative will force use\n of dynamic null terminated string)\n@return string data created\n@throws CodeUnitInsertionException if there is a data conflict",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address"
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "length of string (a value of 0 or negative will force use\n of dynamic null terminated string)"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "string data created"
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.util.CodeUnitInsertionException",
          "type_short": "CodeUnitInsertionException",
          "comment": "if there is a data conflict"
        }
      ]
    },
    {
      "name": "createUnicodeString",
      "comment": "Creates a null terminated unicode string starting at the specified address.",
      "javadoc": "Creates a null terminated unicode string starting at the specified address.\n@param address the address to create the string\n@return the newly created Data object\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to create the string"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Data",
        "type_short": "Data",
        "comment": "the newly created Data object"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "removeData",
      "comment": "Removes the given data from the current program.",
      "javadoc": "Removes the given data from the current program.\n@param data the data to remove\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "data",
          "type_long": "ghidra.program.model.listing.Data",
          "type_short": "Data",
          "comment": "the data to remove"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "removeDataAt",
      "comment": "Removes the data containing the given address from the current program.",
      "javadoc": "Removes the data containing the given address from the current program.\n@param address the address to remove data\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to remove data"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "removeInstruction",
      "comment": "Removes the given instruction from the current program.",
      "javadoc": "Removes the given instruction from the current program.\n@param instruction the instruction to remove\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": "the instruction to remove"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "removeInstructionAt",
      "comment": "Removes the instruction containing the given address from the current program.",
      "javadoc": "Removes the instruction containing the given address from the current program.\n@param address the address to remove instruction\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to remove instruction"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "addInstructionXref",
      "comment": "Adds a cross reference (XREF).",
      "javadoc": "Adds a cross reference (XREF).\n@param from the source address of the reference\n@param to the destination address of the reference\n@param opIndex the operand index (-1 indicates the mnemonic)\n@param type the flow type\n@return the newly created reference\n@see ghidra.program.model.symbol.FlowType\n@see ghidra.program.model.symbol.Reference",
      "static": false,
      "params": [
        {
          "name": "from",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the source address of the reference"
        },
        {
          "name": "to",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the destination address of the reference"
        },
        {
          "name": "opIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the operand index (-1 indicates the mnemonic)"
        },
        {
          "name": "type",
          "type_long": "ghidra.program.model.symbol.FlowType",
          "type_short": "FlowType",
          "comment": "the flow type"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Reference",
        "type_short": "Reference",
        "comment": "the newly created reference"
      },
      "throws": []
    },
    {
      "name": "toAddr",
      "comment": "Returns a new address with the specified offset in the default address space.",
      "javadoc": "Returns a new address with the specified offset in the default address space.\n@param offset the offset for the new address\n@return a new address with the specified offset in the default address space",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "int",
          "type_short": "int",
          "comment": "the offset for the new address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "a new address with the specified offset in the default address space"
      },
      "throws": []
    },
    {
      "name": "toAddr",
      "comment": "Returns a new address with the specified offset in the default address space.",
      "javadoc": "Returns a new address with the specified offset in the default address space.\n@param offset the offset for the new address\n@return a new address with the specified offset in the default address space",
      "static": false,
      "params": [
        {
          "name": "offset",
          "type_long": "long",
          "type_short": "long",
          "comment": "the offset for the new address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "a new address with the specified offset in the default address space"
      },
      "throws": []
    },
    {
      "name": "toAddr",
      "comment": "Returns a new address inside the specified program as indicated by the string.",
      "javadoc": "Returns a new address inside the specified program as indicated by the string.\n@param addressString string representation of the address desired\n@return the address. Otherwise, return null if the string fails to evaluate\n to a legitimate address",
      "static": false,
      "params": [
        {
          "name": "addressString",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "string representation of the address desired"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "the address. Otherwise, return null if the string fails to evaluate\n to a legitimate address"
      },
      "throws": []
    },
    {
      "name": "getByte",
      "comment": "Returns the \u0027byte\u0027 value at the specified address in memory.",
      "javadoc": "Returns the \u0027byte\u0027 value at the specified address in memory.\n@param address the address\n@return the \u0027byte\u0027 value at the specified address in memory\n@throws MemoryAccessException if the memory is not readable",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address"
        }
      ],
      "return": {
        "type_long": "byte",
        "type_short": "byte",
        "comment": "the \u0027byte\u0027 value at the specified address in memory"
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if the memory is not readable"
        }
      ]
    },
    {
      "name": "getBytes",
      "comment": "Reads length number of bytes starting at the specified address.\n Note: this could be inefficient if length is large",
      "javadoc": "Reads length number of bytes starting at the specified address.\n Note: this could be inefficient if length is large\n@param address the address to start reading\n@param length the number of bytes to read\n@return an array of bytes\n@throws MemoryAccessException if memory does not exist or is uninitialized\n@see ghidra.program.model.mem.Memory",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to start reading"
        },
        {
          "name": "length",
          "type_long": "int",
          "type_short": "int",
          "comment": "the number of bytes to read"
        }
      ],
      "return": {
        "type_long": "byte[]",
        "type_short": "byte[]",
        "comment": "an array of bytes"
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if memory does not exist or is uninitialized"
        }
      ]
    },
    {
      "name": "setByte",
      "comment": "Sets the \u0027byte\u0027 value at the specified address.",
      "javadoc": "Sets the \u0027byte\u0027 value at the specified address.\n@param address the address to set the \u0027byte\u0027\n@param value the value to set\n@throws MemoryAccessException if memory does not exist or is uninitialized",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to set the \u0027byte\u0027"
        },
        {
          "name": "value",
          "type_long": "byte",
          "type_short": "byte",
          "comment": "the value to set"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if memory does not exist or is uninitialized"
        }
      ]
    },
    {
      "name": "setBytes",
      "comment": "Sets the \u0027byte\u0027 values starting at the specified address.",
      "javadoc": "Sets the \u0027byte\u0027 values starting at the specified address.\n@param address the address to set the bytes\n@param values the values to set\n@throws MemoryAccessException if memory does not exist or is uninitialized",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to set the bytes"
        },
        {
          "name": "values",
          "type_long": "byte[]",
          "type_short": "byte[]",
          "comment": "the values to set"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if memory does not exist or is uninitialized"
        }
      ]
    },
    {
      "name": "getShort",
      "comment": "Returns the \u0027short\u0027 value at the specified address in memory.",
      "javadoc": "Returns the \u0027short\u0027 value at the specified address in memory.\n@param address the address\n@return the \u0027short\u0027 value at the specified address in memory\n@throws MemoryAccessException if the memory is not readable",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address"
        }
      ],
      "return": {
        "type_long": "short",
        "type_short": "short",
        "comment": "the \u0027short\u0027 value at the specified address in memory"
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if the memory is not readable"
        }
      ]
    },
    {
      "name": "setShort",
      "comment": "Sets the \u0027short\u0027 value at the specified address.",
      "javadoc": "Sets the \u0027short\u0027 value at the specified address.\n@param address the address to set the \u0027short\u0027\n@param value the value to set\n@throws MemoryAccessException if memory does not exist or is uninitialized",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to set the \u0027short\u0027"
        },
        {
          "name": "value",
          "type_long": "short",
          "type_short": "short",
          "comment": "the value to set"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if memory does not exist or is uninitialized"
        }
      ]
    },
    {
      "name": "getInt",
      "comment": "Returns the \u0027integer\u0027 value at the specified address in memory.",
      "javadoc": "Returns the \u0027integer\u0027 value at the specified address in memory.\n@param address the address\n@return the \u0027integer\u0027 value at the specified address in memory\n@throws MemoryAccessException if the memory is not readable",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address"
        }
      ],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the \u0027integer\u0027 value at the specified address in memory"
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if the memory is not readable"
        }
      ]
    },
    {
      "name": "setInt",
      "comment": "Sets the \u0027integer\u0027 value at the specified address.",
      "javadoc": "Sets the \u0027integer\u0027 value at the specified address.\n@param address the address to set the \u0027integer\u0027\n@param value the value to set\n@throws MemoryAccessException if memory does not exist or is uninitialized",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to set the \u0027integer\u0027"
        },
        {
          "name": "value",
          "type_long": "int",
          "type_short": "int",
          "comment": "the value to set"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if memory does not exist or is uninitialized"
        }
      ]
    },
    {
      "name": "getLong",
      "comment": "Returns the \u0027long\u0027 value at the specified address in memory.",
      "javadoc": "Returns the \u0027long\u0027 value at the specified address in memory.\n@param address the address\n@return the \u0027long\u0027 value at the specified address in memory\n@throws MemoryAccessException if the memory is not readable",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address"
        }
      ],
      "return": {
        "type_long": "long",
        "type_short": "long",
        "comment": "the \u0027long\u0027 value at the specified address in memory"
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if the memory is not readable"
        }
      ]
    },
    {
      "name": "setLong",
      "comment": "Sets the \u0027long\u0027 value at the specified address.",
      "javadoc": "Sets the \u0027long\u0027 value at the specified address.\n@param address the address to set the \u0027long\u0027\n@param value the value to set\n@throws MemoryAccessException if memory does not exist or is uninitialized",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to set the \u0027long\u0027"
        },
        {
          "name": "value",
          "type_long": "long",
          "type_short": "long",
          "comment": "the value to set"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if memory does not exist or is uninitialized"
        }
      ]
    },
    {
      "name": "getFloat",
      "comment": "Returns the \u0027float\u0027 value at the specified address in memory.",
      "javadoc": "Returns the \u0027float\u0027 value at the specified address in memory.\n@param address the address\n@return the \u0027float\u0027 value at the specified address in memory\n@throws MemoryAccessException if the memory is not readable",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address"
        }
      ],
      "return": {
        "type_long": "float",
        "type_short": "float",
        "comment": "the \u0027float\u0027 value at the specified address in memory"
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if the memory is not readable"
        }
      ]
    },
    {
      "name": "setFloat",
      "comment": "Sets the \u0027float\u0027 value at the specified address.",
      "javadoc": "Sets the \u0027float\u0027 value at the specified address.\n@param address the address to set the \u0027float\u0027\n@param value the value to set\n@throws MemoryAccessException if memory does not exist or is uninitialized",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to set the \u0027float\u0027"
        },
        {
          "name": "value",
          "type_long": "float",
          "type_short": "float",
          "comment": "the value to set"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if memory does not exist or is uninitialized"
        }
      ]
    },
    {
      "name": "getDouble",
      "comment": "Returns the \u0027double\u0027 value at the specified address in memory.",
      "javadoc": "Returns the \u0027double\u0027 value at the specified address in memory.\n@param address the address\n@return the \u0027double\u0027 value at the specified address in memory\n@throws MemoryAccessException if the memory is not readable",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address"
        }
      ],
      "return": {
        "type_long": "double",
        "type_short": "double",
        "comment": "the \u0027double\u0027 value at the specified address in memory"
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if the memory is not readable"
        }
      ]
    },
    {
      "name": "setDouble",
      "comment": "Sets the \u0027double\u0027 value at the specified address.",
      "javadoc": "Sets the \u0027double\u0027 value at the specified address.\n@param address the address to set the \u0027double\u0027\n@param value the value to set\n@throws MemoryAccessException if memory does not exist or is uninitialized",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to set the \u0027double\u0027"
        },
        {
          "name": "value",
          "type_long": "double",
          "type_short": "double",
          "comment": "the value to set"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.program.model.mem.MemoryAccessException",
          "type_short": "MemoryAccessException",
          "comment": "if memory does not exist or is uninitialized"
        }
      ]
    },
    {
      "name": "getReferencesFrom",
      "comment": "Returns an array of the references FROM the given address.",
      "javadoc": "Returns an array of the references FROM the given address.\n@param address the from address of the references\n@return an array of the references FROM the given address",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the from address of the references"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Reference[]",
        "type_short": "ghidra.program.model.symbol.Reference[]",
        "comment": "an array of the references FROM the given address"
      },
      "throws": []
    },
    {
      "name": "getReferencesTo",
      "comment": "Returns an array of the references TO the given address.\n Note: If more than 4096 references exists to this address,\n only the first 4096 will be returned.\n If you need to access all the references, please\n refer to the method ReferenceManager::getReferencesTo(Address).",
      "javadoc": "Returns an array of the references TO the given address.\n Note: If more than 4096 references exists to this address,\n only the first 4096 will be returned.\n If you need to access all the references, please\n refer to the method \u003ccode\u003eReferenceManager::getReferencesTo(Address)\u003c/code\u003e.\n@param address the from address of the references\n@return an array of the references TO the given address",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the from address of the references"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Reference[]",
        "type_short": "ghidra.program.model.symbol.Reference[]",
        "comment": "an array of the references TO the given address"
      },
      "throws": []
    },
    {
      "name": "getReference",
      "comment": "Returns the reference from the instruction to the given address.",
      "javadoc": "Returns the reference from the instruction to the given address.\n@param instruction the instruction\n@param toAddress the destination address\n@return the reference from the instruction to the given address",
      "static": false,
      "params": [
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": "the instruction"
        },
        {
          "name": "toAddress",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the destination address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Reference",
        "type_short": "Reference",
        "comment": "the reference from the instruction to the given address"
      },
      "throws": []
    },
    {
      "name": "getReference",
      "comment": "Returns the reference from the data to the given address.",
      "javadoc": "Returns the reference from the data to the given address.\n@param data the data\n@param toAddress the destination address\n@return the reference from the data to the given address",
      "static": false,
      "params": [
        {
          "name": "data",
          "type_long": "ghidra.program.model.listing.Data",
          "type_short": "Data",
          "comment": "the data"
        },
        {
          "name": "toAddress",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the destination address"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Reference",
        "type_short": "Reference",
        "comment": "the reference from the data to the given address"
      },
      "throws": []
    },
    {
      "name": "createMemoryReference",
      "comment": "Creates a memory reference from the given instruction.",
      "javadoc": "Creates a memory reference from the given instruction.\n@param instruction the instruction\n@param operandIndex the operand index on the instruction\n@param toAddress the TO address\n@param flowType the flow type of the reference\n@return the newly created memory reference",
      "static": false,
      "params": [
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": "the instruction"
        },
        {
          "name": "operandIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the operand index on the instruction"
        },
        {
          "name": "toAddress",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the TO address"
        },
        {
          "name": "flowType",
          "type_long": "ghidra.program.model.symbol.RefType",
          "type_short": "RefType",
          "comment": "the flow type of the reference"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Reference",
        "type_short": "Reference",
        "comment": "the newly created memory reference"
      },
      "throws": []
    },
    {
      "name": "createMemoryReference",
      "comment": "Creates a memory reference from the given data.",
      "javadoc": "Creates a memory reference from the given data.\n@param data the data\n@param toAddress the TO address\n@param dataRefType the type of the reference\n@return the newly created memory reference",
      "static": false,
      "params": [
        {
          "name": "data",
          "type_long": "ghidra.program.model.listing.Data",
          "type_short": "Data",
          "comment": "the data"
        },
        {
          "name": "toAddress",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the TO address"
        },
        {
          "name": "dataRefType",
          "type_long": "ghidra.program.model.symbol.RefType",
          "type_short": "RefType",
          "comment": "the type of the reference"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Reference",
        "type_short": "Reference",
        "comment": "the newly created memory reference"
      },
      "throws": []
    },
    {
      "name": "createExternalReference",
      "comment": "Creates an external reference from the given instruction.\n For instructions with flow, the FlowType will be assumed, otherwise\n RefType#DATA will be assumed.  To specify the appropriate\n RefType use the alternate form of this method.",
      "javadoc": "Creates an external reference from the given instruction.\n For instructions with flow, the FlowType will be assumed, otherwise\n {@link RefType#DATA} will be assumed.  To specify the appropriate\n RefType use the alternate form of this method.\n@param instruction the instruction\n@param operandIndex the operand index on the instruction\n@param libraryName the name of the library being referred\n@param externalLabel the name of function in the library being referred\n@param externalAddr the address of the function in the library being referred\n@return the newly created external reference\n@throws Exception if an exception occurs",
      "static": false,
      "params": [
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": "the instruction"
        },
        {
          "name": "operandIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the operand index on the instruction"
        },
        {
          "name": "libraryName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the library being referred"
        },
        {
          "name": "externalLabel",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of function in the library being referred"
        },
        {
          "name": "externalAddr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address of the function in the library being referred"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Reference",
        "type_short": "Reference",
        "comment": "the newly created external reference"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if an exception occurs"
        }
      ]
    },
    {
      "name": "createExternalReference",
      "comment": "Creates an external reference from the given instruction.",
      "javadoc": "Creates an external reference from the given instruction.\n@param instruction the instruction\n@param operandIndex the operand index on the instruction\n@param libraryName the name of the library being referred\n@param externalLabel the name of function in the library being referred\n@param externalAddr the address of the function in the library being referred\n@param refType the appropriate external reference type (e.g., DATA, COMPUTED_CALL, etc.)\n@return the newly created external reference\n@throws Exception if an exception occurs",
      "static": false,
      "params": [
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": "the instruction"
        },
        {
          "name": "operandIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the operand index on the instruction"
        },
        {
          "name": "libraryName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the library being referred"
        },
        {
          "name": "externalLabel",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of function in the library being referred"
        },
        {
          "name": "externalAddr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address of the function in the library being referred"
        },
        {
          "name": "refType",
          "type_long": "ghidra.program.model.symbol.RefType",
          "type_short": "RefType",
          "comment": "the appropriate external reference type (e.g., DATA, COMPUTED_CALL, etc.)"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Reference",
        "type_short": "Reference",
        "comment": "the newly created external reference"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if an exception occurs"
        }
      ]
    },
    {
      "name": "createExternalReference",
      "comment": "Creates an external reference from the given data.  The reference type RefType#DATA\n will be used.",
      "javadoc": "Creates an external reference from the given data.  The reference type {@link RefType#DATA}\n will be used.\n@param data the data\n@param libraryName the name of the library being referred\n@param externalLabel the name of function in the library being referred\n@param externalAddr the address of the function in the library being referred\n@return the newly created external reference\n@throws Exception if an exception occurs",
      "static": false,
      "params": [
        {
          "name": "data",
          "type_long": "ghidra.program.model.listing.Data",
          "type_short": "Data",
          "comment": "the data"
        },
        {
          "name": "libraryName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the library being referred"
        },
        {
          "name": "externalLabel",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of function in the library being referred"
        },
        {
          "name": "externalAddr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address of the function in the library being referred"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Reference",
        "type_short": "Reference",
        "comment": "the newly created external reference"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if an exception occurs"
        }
      ]
    },
    {
      "name": "createStackReference",
      "comment": "Create a stack reference from the given instruction",
      "javadoc": "Create a stack reference from the given instruction\n@param instruction the instruction\n@param operandIndex the operand index on the instruction\n@param stackOffset the stack offset of the reference\n@param isWrite true if the reference is WRITE access or false if the\n reference is READ access\n@return the newly created stack reference",
      "static": false,
      "params": [
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": "the instruction"
        },
        {
          "name": "operandIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the operand index on the instruction"
        },
        {
          "name": "stackOffset",
          "type_long": "int",
          "type_short": "int",
          "comment": "the stack offset of the reference"
        },
        {
          "name": "isWrite",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if the reference is WRITE access or false if the\n reference is READ access"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Reference",
        "type_short": "Reference",
        "comment": "the newly created stack reference"
      },
      "throws": []
    },
    {
      "name": "removeReference",
      "comment": "Removes the given reference.",
      "javadoc": "Removes the given reference.\n@param reference the reference to remove",
      "static": false,
      "params": [
        {
          "name": "reference",
          "type_long": "ghidra.program.model.symbol.Reference",
          "type_short": "Reference",
          "comment": "the reference to remove"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "setReferencePrimary",
      "comment": "Sets the given reference as primary.",
      "javadoc": "Sets the given reference as primary.\n@param reference the reference to mark as primary",
      "static": false,
      "params": [
        {
          "name": "reference",
          "type_long": "ghidra.program.model.symbol.Reference",
          "type_short": "Reference",
          "comment": "the reference to mark as primary"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "setReferencePrimary",
      "comment": "Sets the given reference as primary.",
      "javadoc": "Sets the given reference as primary.\n@param reference the reference\n@param primary true if primary, false not primary",
      "static": false,
      "params": [
        {
          "name": "reference",
          "type_long": "ghidra.program.model.symbol.Reference",
          "type_short": "Reference",
          "comment": "the reference"
        },
        {
          "name": "primary",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if primary, false not primary"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "createEquate",
      "comment": "Creates a new equate on the scalar value\n at the operand index of the instruction.",
      "javadoc": "Creates a new equate on the scalar value\n at the operand index of the instruction.\n@param instruction the instruction\n@param operandIndex the operand index on the instruction\n@param equateName the name of the equate\n@return the newly created equate\n@throws Exception if a scalar does not exist of the specified\n operand index of the instruction",
      "static": false,
      "params": [
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": "the instruction"
        },
        {
          "name": "operandIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the operand index on the instruction"
        },
        {
          "name": "equateName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the equate"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Equate",
        "type_short": "Equate",
        "comment": "the newly created equate"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if a scalar does not exist of the specified\n operand index of the instruction"
        }
      ]
    },
    {
      "name": "createEquate",
      "comment": "Creates a new equate on the scalar value\n at the value of the data.",
      "javadoc": "Creates a new equate on the scalar value\n at the value of the data.\n@param data the data\n@param equateName the name of the equate\n@return the newly created equate\n@throws InvalidInputException if a scalar does not exist on the data\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "data",
          "type_long": "ghidra.program.model.listing.Data",
          "type_short": "Data",
          "comment": "the data"
        },
        {
          "name": "equateName",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the equate"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Equate",
        "type_short": "Equate",
        "comment": "the newly created equate"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "getEquate",
      "comment": "Returns the equate defined at the operand index of the instruction with the given value.",
      "javadoc": "Returns the equate defined at the operand index of the instruction with the given value.\n@param instruction the instruction\n@param operandIndex the operand index\n@param value scalar equate value\n@return the equate defined at the operand index of the instruction",
      "static": false,
      "params": [
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": "the instruction"
        },
        {
          "name": "operandIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the operand index"
        },
        {
          "name": "value",
          "type_long": "long",
          "type_short": "long",
          "comment": "scalar equate value"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Equate",
        "type_short": "Equate",
        "comment": "the equate defined at the operand index of the instruction"
      },
      "throws": []
    },
    {
      "name": "getEquates",
      "comment": "Returns the equates defined at the operand index of the instruction.",
      "javadoc": "Returns the equates defined at the operand index of the instruction.\n@param instruction the instruction\n@param operandIndex the operand index\n@return the equate defined at the operand index of the instruction",
      "static": false,
      "params": [
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": "the instruction"
        },
        {
          "name": "operandIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the operand index"
        }
      ],
      "return": {
        "type_long": "java.util.List\u003cghidra.program.model.symbol.Equate\u003e",
        "type_short": "List",
        "comment": "the equate defined at the operand index of the instruction"
      },
      "throws": []
    },
    {
      "name": "getEquate",
      "comment": "Returns the equate defined on the data.",
      "javadoc": "Returns the equate defined on the data.\n@param data the data\n@return the equate defined on the data",
      "static": false,
      "params": [
        {
          "name": "data",
          "type_long": "ghidra.program.model.listing.Data",
          "type_short": "Data",
          "comment": "the data"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.symbol.Equate",
        "type_short": "Equate",
        "comment": "the equate defined on the data"
      },
      "throws": []
    },
    {
      "name": "removeEquate",
      "comment": "Removes the equate defined at the operand index of the instruction with the given value.",
      "javadoc": "Removes the equate defined at the operand index of the instruction with the given value.\n@param instruction the instruction\n@param operandIndex the operand index\n@param value scalar value corresponding to equate",
      "static": false,
      "params": [
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": "the instruction"
        },
        {
          "name": "operandIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the operand index"
        },
        {
          "name": "value",
          "type_long": "long",
          "type_short": "long",
          "comment": "scalar value corresponding to equate"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "removeEquates",
      "comment": "Removes the equates defined at the operand index of the instruction.",
      "javadoc": "Removes the equates defined at the operand index of the instruction.\n@param instruction the instruction\n@param operandIndex the operand index",
      "static": false,
      "params": [
        {
          "name": "instruction",
          "type_long": "ghidra.program.model.listing.Instruction",
          "type_short": "Instruction",
          "comment": "the instruction"
        },
        {
          "name": "operandIndex",
          "type_long": "int",
          "type_short": "int",
          "comment": "the operand index"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "removeEquate",
      "comment": "Removes the equate defined on the data.",
      "javadoc": "Removes the equate defined on the data.\n@param data the data",
      "static": false,
      "params": [
        {
          "name": "data",
          "type_long": "ghidra.program.model.listing.Data",
          "type_short": "Data",
          "comment": "the data"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "createBookmark",
      "comment": "Creates a NOTE bookmark at the specified address\n \n NOTE: if a NOTE bookmark already exists at the address, it will be replaced.\n This is intentional and is done to match the behavior of setting bookmarks from the UI.",
      "javadoc": "Creates a \u003ccode\u003eNOTE\u003c/code\u003e bookmark at the specified address\n \u003cbr\u003e\n NOTE: if a \u003ccode\u003eNOTE\u003c/code\u003e bookmark already exists at the address, it will be replaced.\n This is intentional and is done to match the behavior of setting bookmarks from the UI.\n@param address the address to create the bookmark\n@param category the bookmark category (it may be null)\n@param note the bookmark text\n@return the newly created bookmark",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to create the bookmark"
        },
        {
          "name": "category",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the bookmark category (it may be null)"
        },
        {
          "name": "note",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the bookmark text"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Bookmark",
        "type_short": "Bookmark",
        "comment": "the newly created bookmark"
      },
      "throws": []
    },
    {
      "name": "getBookmarks",
      "comment": "Returns all of the NOTE bookmarks defined at the specified address",
      "javadoc": "Returns all of the NOTE bookmarks defined at the specified address\n@param address the address to retrieve the bookmark\n@return the bookmarks at the specified address",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to retrieve the bookmark"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.listing.Bookmark[]",
        "type_short": "ghidra.program.model.listing.Bookmark[]",
        "comment": "the bookmarks at the specified address"
      },
      "throws": []
    },
    {
      "name": "removeBookmark",
      "comment": "Removes the specified bookmark.",
      "javadoc": "Removes the specified bookmark.\n@param bookmark the bookmark to remove",
      "static": false,
      "params": [
        {
          "name": "bookmark",
          "type_long": "ghidra.program.model.listing.Bookmark",
          "type_short": "Bookmark",
          "comment": "the bookmark to remove"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "openDataTypeArchive",
      "comment": "Opens a Data Type Archive",
      "javadoc": "Opens a Data Type Archive\n@param archiveFile the archive file to open\n@param readOnly should file be opened read only\n@return the data type manager\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "archiveFile",
          "type_long": "java.io.File",
          "type_short": "File",
          "comment": "the archive file to open"
        },
        {
          "name": "readOnly",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "should file be opened read only"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.data.FileDataTypeManager",
        "type_short": "FileDataTypeManager",
        "comment": "the data type manager"
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "saveProgram",
      "comment": "Saves the changes to the specified program.\n If the program does not already exist in the current project\n then it will be saved into the root folder.\n If a program already exists with the specified\n name, then a time stamp will be appended to the name to make it unique.",
      "javadoc": "Saves the changes to the specified program.\n If the program does not already exist in the current project\n then it will be saved into the root folder.\n If a program already exists with the specified\n name, then a time stamp will be appended to the name to make it unique.\n@param program the program to save\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": "the program to save"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "saveProgram",
      "comment": "Saves changes to the specified program.\n \n If the program does not already exist in the current project\n then it will be saved into a project folder path specified by the path parameter.\n \n If path is NULL, the program will be saved into the root folder.  If parts of the path are\n missing, they will be created if possible.\n \n If a program already exists with the specified name, then a time stamp will be appended\n to the name to make it unique.\n ",
      "javadoc": "Saves changes to the specified program.\n \u003cp\u003e\n If the program does not already exist in the current project\n then it will be saved into a project folder path specified by the path parameter.\n \u003cp\u003e\n If path is NULL, the program will be saved into the root folder.  If parts of the path are\n missing, they will be created if possible.\n \u003cp\u003e\n If a program already exists with the specified name, then a time stamp will be appended\n to the name to make it unique.\n \u003cp\u003e\n@param program the program to save\n@param path list of string path elements (starting at the root of the project) that specify\n the project folder to save the program info.  Example: { \"folder1\", \"subfolder2\",\n \"final_folder\" }\n@throws Exception if there is any exception",
      "static": false,
      "params": [
        {
          "name": "program",
          "type_long": "ghidra.program.model.listing.Program",
          "type_short": "Program",
          "comment": "the program to save"
        },
        {
          "name": "path",
          "type_long": "java.util.List\u003cjava.lang.String\u003e",
          "type_short": "List",
          "comment": "list of string path elements (starting at the root of the project) that specify\n the project folder to save the program info.  Example: { \"folder1\", \"subfolder2\",\n \"final_folder\" }"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.lang.Exception",
          "type_short": "Exception",
          "comment": "if there is any exception"
        }
      ]
    },
    {
      "name": "getProjectRootFolder",
      "comment": "This method looks up the current project and returns\n the root domain folder.",
      "javadoc": "This method looks up the current project and returns\n the root domain folder.\n@return the root domain folder of the current project",
      "static": false,
      "params": [],
      "return": {
        "type_long": "ghidra.framework.model.DomainFolder",
        "type_short": "DomainFolder",
        "comment": "the root domain folder of the current project"
      },
      "throws": []
    },
    {
      "name": "findComment",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [
        {
          "name": "type",
          "type_long": "int",
          "type_short": "int",
          "comment": ""
        },
        {
          "name": "text",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": ""
      },
      "throws": []
    }
  ]
}
