{
  "name": "SymbolDatabaseAdapter",
  "comment": "Adapter to access records in the symbol table.",
  "javadoc": "Adapter to access records in the symbol table.",
  "static": false,
  "implements": [],
  "extends": "java.lang.Object",
  "fields": [
    {
      "name": "SYMBOL_TABLE_NAME",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "java.lang.String",
      "type_short": "String",
      "constant_value": "\"Symbols\""
    },
    {
      "name": "SYMBOL_NAME_COL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "0"
    },
    {
      "name": "SYMBOL_ADDR_COL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "1"
    },
    {
      "name": "SYMBOL_PARENT_COL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "2"
    },
    {
      "name": "SYMBOL_TYPE_COL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "3"
    },
    {
      "name": "SYMBOL_STRING_DATA_COL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "4"
    },
    {
      "name": "SYMBOL_FLAGS_COL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "5"
    },
    {
      "name": "SYMBOL_HASH_COL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "6"
    },
    {
      "name": "SYMBOL_PRIMARY_COL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "7"
    },
    {
      "name": "SYMBOL_DATATYPE_COL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "8"
    },
    {
      "name": "SYMBOL_VAROFFSET_COL",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "int",
      "type_short": "int",
      "constant_value": "9"
    },
    {
      "name": "SYMBOL_SCHEMA",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "db.Schema",
      "type_short": "Schema",
      "constant_value": null
    },
    {
      "name": "SYMBOL_SOURCE_BITS",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "byte",
      "type_short": "byte",
      "constant_value": "3"
    },
    {
      "name": "SYMBOL_PINNED_FLAG",
      "comment": "",
      "javadoc": "",
      "static": true,
      "type_long": "byte",
      "type_short": "byte",
      "constant_value": "4"
    }
  ],
  "methods": [
    {
      "name": "\u003cinit\u003e",
      "comment": "",
      "javadoc": "",
      "static": false,
      "params": [],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getAdapter",
      "comment": "Gets a new SymbolDatabaseAdapter",
      "javadoc": "Gets a new SymbolDatabaseAdapter\n@param dbHandle the database handle\n@param openMode the open mode. See {@link DBConstants}\n@param addrMap the address map\n@param monitor the progress monitor\n@return a new SymbolDatabaseAdapter\n@throws VersionException if the database table does not match the adapter\n@throws CancelledException if the user cancels an upgrade\n@throws IOException if a database io error occurs",
      "static": true,
      "params": [
        {
          "name": "dbHandle",
          "type_long": "db.DBHandle",
          "type_short": "DBHandle",
          "comment": "the database handle"
        },
        {
          "name": "openMode",
          "type_long": "int",
          "type_short": "int",
          "comment": "the open mode. See DBConstants"
        },
        {
          "name": "addrMap",
          "type_long": "ghidra.program.database.map.AddressMap",
          "type_short": "AddressMap",
          "comment": "the address map"
        },
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": "the progress monitor"
        }
      ],
      "return": {
        "type_long": "ghidra.program.database.symbol.SymbolDatabaseAdapter",
        "type_short": "SymbolDatabaseAdapter",
        "comment": "a new SymbolDatabaseAdapter"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.VersionException",
          "type_short": "VersionException",
          "comment": "if the database table does not match the adapter"
        },
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": "if the user cancels an upgrade"
        },
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if a database io error occurs"
        }
      ]
    },
    {
      "name": "findReadOnlyAdapter",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "handle",
          "type_long": "db.DBHandle",
          "type_short": "DBHandle",
          "comment": ""
        },
        {
          "name": "addrMap",
          "type_long": "ghidra.program.database.map.AddressMap",
          "type_short": "AddressMap",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.database.symbol.SymbolDatabaseAdapter",
        "type_short": "SymbolDatabaseAdapter",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.VersionException",
          "type_short": "VersionException",
          "comment": ""
        },
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        }
      ]
    },
    {
      "name": "upgrade",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "dbHandle",
          "type_long": "db.DBHandle",
          "type_short": "DBHandle",
          "comment": ""
        },
        {
          "name": "addrMap",
          "type_long": "ghidra.program.database.map.AddressMap",
          "type_short": "AddressMap",
          "comment": ""
        },
        {
          "name": "oldAdapter",
          "type_long": "ghidra.program.database.symbol.SymbolDatabaseAdapter",
          "type_short": "SymbolDatabaseAdapter",
          "comment": ""
        },
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.database.symbol.SymbolDatabaseAdapter",
        "type_short": "SymbolDatabaseAdapter",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.VersionException",
          "type_short": "VersionException",
          "comment": ""
        },
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        },
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": ""
        }
      ]
    },
    {
      "name": "copyToTempAndFixupRecords",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "addrMap",
          "type_long": "ghidra.program.database.map.AddressMap",
          "type_short": "AddressMap",
          "comment": ""
        },
        {
          "name": "oldAdapter",
          "type_long": "ghidra.program.database.symbol.SymbolDatabaseAdapter",
          "type_short": "SymbolDatabaseAdapter",
          "comment": ""
        },
        {
          "name": "tmpHandle",
          "type_long": "db.DBHandle",
          "type_short": "DBHandle",
          "comment": ""
        },
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "ghidra.program.database.symbol.SymbolDatabaseAdapter",
        "type_short": "SymbolDatabaseAdapter",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        },
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": ""
        },
        {
          "type_long": "ghidra.util.exception.VersionException",
          "type_short": "VersionException",
          "comment": ""
        }
      ]
    },
    {
      "name": "copyTempToNewAdapter",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "tmpAdapter",
          "type_long": "ghidra.program.database.symbol.SymbolDatabaseAdapter",
          "type_short": "SymbolDatabaseAdapter",
          "comment": ""
        },
        {
          "name": "newAdapter",
          "type_long": "ghidra.program.database.symbol.SymbolDatabaseAdapter",
          "type_short": "SymbolDatabaseAdapter",
          "comment": ""
        },
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": ""
        },
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": ""
        }
      ]
    },
    {
      "name": "createSymbol",
      "comment": "Create a new symbol",
      "javadoc": "Create a new symbol\n@param name name of the symbol\n@param address the address for the symbol\n@param namespaceID the id of the containing namespace symbol\n@param symbolType the type of this symbol\n@param stringData place to store a String value that depends on the symbol type\n@param source the source type of this symbol\n Some symbol types, such as function symbols, can set the source to Symbol.DEFAULT\n@param dataTypeId the id of an associated datatype or null if there is no associated datatype\n@param varOffset the variable offset will be the ordinal for a parameter or first use offset\n for a local variable\n@param isPrimary true if the symbol is primary. Only applicable for labels and functions\n@return the new record\n@throws IOException if there was a problem accessing the database\n@throws IllegalArgumentException if you try to set the source to DEFAULT for a symbol type\n that doesn\u0027t allow it",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "name of the symbol"
        },
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address for the symbol"
        },
        {
          "name": "namespaceID",
          "type_long": "long",
          "type_short": "long",
          "comment": "the id of the containing namespace symbol"
        },
        {
          "name": "symbolType",
          "type_long": "ghidra.program.model.symbol.SymbolType",
          "type_short": "SymbolType",
          "comment": "the type of this symbol"
        },
        {
          "name": "stringData",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "place to store a String value that depends on the symbol type"
        },
        {
          "name": "dataTypeId",
          "type_long": "java.lang.Long",
          "type_short": "Long",
          "comment": "the id of an associated datatype or null if there is no associated datatype"
        },
        {
          "name": "varOffset",
          "type_long": "java.lang.Integer",
          "type_short": "Integer",
          "comment": "the variable offset will be the ordinal for a parameter or first use offset\n for a local variable"
        },
        {
          "name": "source",
          "type_long": "ghidra.program.model.symbol.SourceType",
          "type_short": "SourceType",
          "comment": "the source type of this symbol\n Some symbol types, such as function symbols, can set the source to Symbol.DEFAULT"
        },
        {
          "name": "isPrimary",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if the symbol is primary. Only applicable for labels and functions"
        }
      ],
      "return": {
        "type_long": "db.DBRecord",
        "type_short": "DBRecord",
        "comment": "the new record"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if there was a problem accessing the database"
        }
      ]
    },
    {
      "name": "getSymbolRecord",
      "comment": "Get the record with the given symbol ID",
      "javadoc": "Get the record with the given symbol ID\n@param symbolID key for the database record\n@return record with the given symbolID\n@throws IOException if there was a problem accessing the database",
      "static": false,
      "params": [
        {
          "name": "symbolID",
          "type_long": "long",
          "type_short": "long",
          "comment": "key for the database record"
        }
      ],
      "return": {
        "type_long": "db.DBRecord",
        "type_short": "DBRecord",
        "comment": "record with the given symbolID"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if there was a problem accessing the database"
        }
      ]
    },
    {
      "name": "removeSymbol",
      "comment": "Remove the record for the given symbol ID",
      "javadoc": "Remove the record for the given symbol ID\n@param symbolID key for the database record\n@throws IOException if there was a problem accessing the database",
      "static": false,
      "params": [
        {
          "name": "symbolID",
          "type_long": "long",
          "type_short": "long",
          "comment": "key for the database record"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if there was a problem accessing the database"
        }
      ]
    },
    {
      "name": "hasSymbol",
      "comment": "Check if the address has a symbol defined at it",
      "javadoc": "Check if the address has a symbol defined at it\n@param addr address to filter on\n@return true if there exists a record with the given address\n@throws IOException if there was a problem accessing the database",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "address to filter on"
        }
      ],
      "return": {
        "type_long": "boolean",
        "type_short": "boolean",
        "comment": "true if there exists a record with the given address"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if there was a problem accessing the database"
        }
      ]
    },
    {
      "name": "getSymbolIDs",
      "comment": "Get the symbolIDs at the given address",
      "javadoc": "Get the symbolIDs at the given address\n@param addr address to filter on\n@return array of database LongField keys contained within a Field array\n@throws IOException if there was a problem accessing the database",
      "static": false,
      "params": [
        {
          "name": "addr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "address to filter on"
        }
      ],
      "return": {
        "type_long": "db.Field[]",
        "type_short": "db.Field[]",
        "comment": "array of database LongField keys contained within a Field array"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if there was a problem accessing the database"
        }
      ]
    },
    {
      "name": "getSymbolCount",
      "comment": "Get the number of symbols",
      "javadoc": "Get the number of symbols\n@return the number of symbols",
      "static": false,
      "params": [],
      "return": {
        "type_long": "int",
        "type_short": "int",
        "comment": "the number of symbols"
      },
      "throws": []
    },
    {
      "name": "getSymbolsByAddress",
      "comment": "Get an iterator over all the symbols in ascending address order",
      "javadoc": "Get an iterator over all the symbols in ascending address order\n@param forward the direction to iterator\n@return a record iterator over all symbols\n@throws IOException if there was a problem accessing the database",
      "static": false,
      "params": [
        {
          "name": "forward",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "the direction to iterator"
        }
      ],
      "return": {
        "type_long": "db.RecordIterator",
        "type_short": "RecordIterator",
        "comment": "a record iterator over all symbols"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if there was a problem accessing the database"
        }
      ]
    },
    {
      "name": "getSymbolsByAddress",
      "comment": "Get an iterator over all the symbols starting at startAddr",
      "javadoc": "Get an iterator over all the symbols starting at startAddr\n@param startAddr start address of where to get symbols\n@param forward true to iterate from low to high addresses\n@return a record iterator over all symbols starting at the given start address\n@throws IOException if there was a problem accessing the database",
      "static": false,
      "params": [
        {
          "name": "startAddr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "start address of where to get symbols"
        },
        {
          "name": "forward",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true to iterate from low to high addresses"
        }
      ],
      "return": {
        "type_long": "db.RecordIterator",
        "type_short": "RecordIterator",
        "comment": "a record iterator over all symbols starting at the given start address"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if there was a problem accessing the database"
        }
      ]
    },
    {
      "name": "updateSymbolRecord",
      "comment": "Update the table with the given record",
      "javadoc": "Update the table with the given record\n@param record the record to update in the database\n@throws IOException if there was a problem accessing the database",
      "static": false,
      "params": [
        {
          "name": "record",
          "type_long": "db.DBRecord",
          "type_short": "DBRecord",
          "comment": "the record to update in the database"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if there was a problem accessing the database"
        }
      ]
    },
    {
      "name": "getSymbols",
      "comment": "Get all of the symbols.",
      "javadoc": "Get all of the symbols.\n@return a record iterator over all symbols\n@throws IOException if there was a problem accessing the database",
      "static": false,
      "params": [],
      "return": {
        "type_long": "db.RecordIterator",
        "type_short": "RecordIterator",
        "comment": "a record iterator over all symbols"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if there was a problem accessing the database"
        }
      ]
    },
    {
      "name": "getSymbols",
      "comment": "Get symbols in the given range",
      "javadoc": "Get symbols in the given range\n@param start the start address of the range\n@param end the last address of the range\n@param forward true if iterating from start to end, otherwise iterate from end to start\n@return a record iterator for all symbols in the range\n@throws IOException if a database io error occurs",
      "static": false,
      "params": [
        {
          "name": "start",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the start address of the range"
        },
        {
          "name": "end",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the last address of the range"
        },
        {
          "name": "forward",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if iterating from start to end, otherwise iterate from end to start"
        }
      ],
      "return": {
        "type_long": "db.RecordIterator",
        "type_short": "RecordIterator",
        "comment": "a record iterator for all symbols in the range"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if a database io error occurs"
        }
      ]
    },
    {
      "name": "getSymbols",
      "comment": "Get symbols in the given range",
      "javadoc": "Get symbols in the given range\n@param set the set of addresses to iterate over\n@param forward true if iterating from start to end, otherwise iterate from end to start\n@return a record iterator for all symbols in the range\n@throws IOException if a database io error occurs",
      "static": false,
      "params": [
        {
          "name": "set",
          "type_long": "ghidra.program.model.address.AddressSetView",
          "type_short": "AddressSetView",
          "comment": "the set of addresses to iterate over"
        },
        {
          "name": "forward",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if iterating from start to end, otherwise iterate from end to start"
        }
      ],
      "return": {
        "type_long": "db.RecordIterator",
        "type_short": "RecordIterator",
        "comment": "a record iterator for all symbols in the range"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if a database io error occurs"
        }
      ]
    },
    {
      "name": "getPrimarySymbols",
      "comment": "Returns an iterator over the primary symbols in the given range",
      "javadoc": "Returns an iterator over the primary symbols in the given range\n@param set the address set to iterator over when getting primary symbol records\n@param forward true if iterating from start to end, otherwise iterate from end to start\n@return a record iterator for all symbols in the range\n@throws IOException if a database io error occurs",
      "static": false,
      "params": [
        {
          "name": "set",
          "type_long": "ghidra.program.model.address.AddressSetView",
          "type_short": "AddressSetView",
          "comment": "the address set to iterator over when getting primary symbol records"
        },
        {
          "name": "forward",
          "type_long": "boolean",
          "type_short": "boolean",
          "comment": "true if iterating from start to end, otherwise iterate from end to start"
        }
      ],
      "return": {
        "type_long": "db.RecordIterator",
        "type_short": "RecordIterator",
        "comment": "a record iterator for all symbols in the range"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if a database io error occurs"
        }
      ]
    },
    {
      "name": "getPrimarySymbol",
      "comment": "Returns the symbol record for the primary symbol at the given address",
      "javadoc": "Returns the symbol record for the primary symbol at the given address\n@param address the address to get its primary symbol record\n@return the primary symbol record at the given address or null if no label or function\n exists at that address\n@throws IOException if a database io error occurs",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the address to get its primary symbol record"
        }
      ],
      "return": {
        "type_long": "db.DBRecord",
        "type_short": "DBRecord",
        "comment": "the primary symbol record at the given address or null if no label or function\n exists at that address"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if a database io error occurs"
        }
      ]
    },
    {
      "name": "moveAddress",
      "comment": "Update the address in all records to reflect the movement of a symbol address.",
      "javadoc": "Update the address in all records to reflect the movement of a symbol address.\n@param oldAddr the original symbol address\n@param newAddr the new symbol address\n@throws IOException if a database io error occurs",
      "static": false,
      "params": [
        {
          "name": "oldAddr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the original symbol address"
        },
        {
          "name": "newAddr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the new symbol address"
        }
      ],
      "return": {
        "type_long": "void",
        "type_short": "void",
        "comment": ""
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if a database io error occurs"
        }
      ]
    },
    {
      "name": "deleteAddressRange",
      "comment": "Delete all records which contain addresses within the specified range",
      "javadoc": "Delete all records which contain addresses within the specified range\n@param startAddr minimum address in range\n@param endAddr maximum address in range\n@param monitor progress monitor\n@return returns the set of addresses where symbols where not deleted because they were anchored\n@throws CancelledException if the user cancels the operation\n@throws IOException if a database io error occurs",
      "static": false,
      "params": [
        {
          "name": "startAddr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "minimum address in range"
        },
        {
          "name": "endAddr",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "maximum address in range"
        },
        {
          "name": "monitor",
          "type_long": "ghidra.util.task.TaskMonitor",
          "type_short": "TaskMonitor",
          "comment": "progress monitor"
        }
      ],
      "return": {
        "type_long": "java.util.Set\u003cghidra.program.model.address.Address\u003e",
        "type_short": "Set",
        "comment": "returns the set of addresses where symbols where not deleted because they were anchored"
      },
      "throws": [
        {
          "type_long": "ghidra.util.exception.CancelledException",
          "type_short": "CancelledException",
          "comment": "if the user cancels the operation"
        },
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if a database io error occurs"
        }
      ]
    },
    {
      "name": "getSymbolsByNamespace",
      "comment": "Get all symbols contained within the specified namespace",
      "javadoc": "Get all symbols contained within the specified namespace\n@param id the namespace id\n@return an iterator over all symbols in the given namespace\n@throws IOException if a database io error occurs",
      "static": false,
      "params": [
        {
          "name": "id",
          "type_long": "long",
          "type_short": "long",
          "comment": "the namespace id"
        }
      ],
      "return": {
        "type_long": "db.RecordIterator",
        "type_short": "RecordIterator",
        "comment": "an iterator over all symbols in the given namespace"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if a database io error occurs"
        }
      ]
    },
    {
      "name": "getSymbolsByName",
      "comment": "Get symbols that have the specified name",
      "javadoc": "Get symbols that have the specified name\n@param name name to search\n@return a record iterator over the symbols with the given name\n@throws IOException if a database io error occurs",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "name to search"
        }
      ],
      "return": {
        "type_long": "db.RecordIterator",
        "type_short": "RecordIterator",
        "comment": "a record iterator over the symbols with the given name"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if a database io error occurs"
        }
      ]
    },
    {
      "name": "getSymbolsByNameAndNamespace",
      "comment": "Get all symbols contained in the given Namespace that have the given name",
      "javadoc": "Get all symbols contained in the given {@link Namespace} that have the given name\n@param name the symbol name\n@param id the id of the parent namespace\n@return a record iterator all the symbols in the given namespace with the given name\n@throws IOException if a database io error occurs",
      "static": false,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the symbol name"
        },
        {
          "name": "id",
          "type_long": "long",
          "type_short": "long",
          "comment": "the id of the parent namespace"
        }
      ],
      "return": {
        "type_long": "db.RecordIterator",
        "type_short": "RecordIterator",
        "comment": "a record iterator all the symbols in the given namespace with the given name"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if a database io error occurs"
        }
      ]
    },
    {
      "name": "getSymbolRecord",
      "comment": "Get the symbol Record with the given address, name, and namespace id or null if there is\n no match",
      "javadoc": "Get the symbol Record with the given address, name, and namespace id or null if there is\n no match\n@param address the symbol address\n@param name the symbol name\n@param namespaceId the id of the parent namespace of the symbol\n@return a record that matches the address, name, and namespaceId or null if there is no match\n@throws IOException if a database io error occurs",
      "static": false,
      "params": [
        {
          "name": "address",
          "type_long": "ghidra.program.model.address.Address",
          "type_short": "Address",
          "comment": "the symbol address"
        },
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the symbol name"
        },
        {
          "name": "namespaceId",
          "type_long": "long",
          "type_short": "long",
          "comment": "the id of the parent namespace of the symbol"
        }
      ],
      "return": {
        "type_long": "db.DBRecord",
        "type_short": "DBRecord",
        "comment": "a record that matches the address, name, and namespaceId or null if there is no match"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if a database io error occurs"
        }
      ]
    },
    {
      "name": "getMaxSymbolAddress",
      "comment": "Returns the maximum symbol address within the specified address space\n Intended for update use only",
      "javadoc": "Returns the maximum symbol address within the specified address space\n Intended for update use only\n@param space address space\n@return maximum symbol address within space or null if none are found\n@throws IOException if a database io error occurs",
      "static": false,
      "params": [
        {
          "name": "space",
          "type_long": "ghidra.program.model.address.AddressSpace",
          "type_short": "AddressSpace",
          "comment": "address space"
        }
      ],
      "return": {
        "type_long": "ghidra.program.model.address.Address",
        "type_short": "Address",
        "comment": "maximum symbol address within space or null if none are found"
      },
      "throws": [
        {
          "type_long": "java.io.IOException",
          "type_short": "IOException",
          "comment": "if a database io error occurs"
        }
      ]
    },
    {
      "name": "getTable",
      "comment": "Returns the underlying symbol table (for upgrade use only)",
      "javadoc": "Returns the underlying symbol table (for upgrade use only)\n@return the database table for this adapter",
      "static": false,
      "params": [],
      "return": {
        "type_long": "db.Table",
        "type_short": "Table",
        "comment": "the database table for this adapter"
      },
      "throws": []
    },
    {
      "name": "computeLocatorHash",
      "comment": "Computes a hash value for a symbol that facilitates fast lookups of symbols given\n a name, namespace, and address. The hash is formed so that it can also be used for fast\n lookups of all symbols that have the same name and namespace regardless of address.",
      "javadoc": "Computes a hash value for a symbol that facilitates fast lookups of symbols given\n a name, namespace, and address. The hash is formed so that it can also be used for fast\n lookups of all symbols that have the same name and namespace regardless of address.\n@param name the symbol name\n@param namespaceID the namespace id\n@param addressKey the encoded address\n@return a database Long field containing the computed hash",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the symbol name"
        },
        {
          "name": "namespaceID",
          "type_long": "long",
          "type_short": "long",
          "comment": "the namespace id"
        },
        {
          "name": "addressKey",
          "type_long": "long",
          "type_short": "long",
          "comment": "the encoded address"
        }
      ],
      "return": {
        "type_long": "db.LongField",
        "type_short": "LongField",
        "comment": "a database Long field containing the computed hash"
      },
      "throws": []
    },
    {
      "name": "getNameAndNamespaceFilterIterator",
      "comment": "",
      "javadoc": "",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": ""
        },
        {
          "name": "namespaceId",
          "type_long": "long",
          "type_short": "long",
          "comment": ""
        },
        {
          "name": "it",
          "type_long": "db.RecordIterator",
          "type_short": "RecordIterator",
          "comment": ""
        }
      ],
      "return": {
        "type_long": "db.RecordIterator",
        "type_short": "RecordIterator",
        "comment": ""
      },
      "throws": []
    },
    {
      "name": "getNameNamespaceAddressFilterIterator",
      "comment": "Wraps a record iterator to make sure it only returns records for symbols that match\n the given name and name space and address",
      "javadoc": "Wraps a record iterator to make sure it only returns records for symbols that match\n the given name and name space and address\n@param name the name of the symbol\n@param namespaceId the name space id of the symbol\n@param addressKey the address key of the symbol\n@param it the record iterator to wrap with the query\n@return a filtered RecordIterator that only returns records that match the name, name space,\n and address",
      "static": true,
      "params": [
        {
          "name": "name",
          "type_long": "java.lang.String",
          "type_short": "String",
          "comment": "the name of the symbol"
        },
        {
          "name": "namespaceId",
          "type_long": "long",
          "type_short": "long",
          "comment": "the name space id of the symbol"
        },
        {
          "name": "addressKey",
          "type_long": "long",
          "type_short": "long",
          "comment": "the address key of the symbol"
        },
        {
          "name": "it",
          "type_long": "db.RecordIterator",
          "type_short": "RecordIterator",
          "comment": "the record iterator to wrap with the query"
        }
      ],
      "return": {
        "type_long": "db.RecordIterator",
        "type_short": "RecordIterator",
        "comment": "a filtered RecordIterator that only returns records that match the name, name space,\n and address"
      },
      "throws": []
    },
    {
      "name": "getPrimaryFilterRecordIterator",
      "comment": "Wraps a record iterator to filter out any symbols that are not primary",
      "javadoc": "Wraps a record iterator to filter out any symbols that are not primary\n@param it the record iterator to wrap\n@return a record iterator that only returns primary symbols",
      "static": true,
      "params": [
        {
          "name": "it",
          "type_long": "db.RecordIterator",
          "type_short": "RecordIterator",
          "comment": "the record iterator to wrap"
        }
      ],
      "return": {
        "type_long": "db.RecordIterator",
        "type_short": "RecordIterator",
        "comment": "a record iterator that only returns primary symbols"
      },
      "throws": []
    }
  ]
}
